# 技术设计

## 背景与约束
- 当前架构：Fastify + 原生 HTML/CSS/JS，前端无构建链。
- 部署约束：生产为 Linux Docker，外部访问为“母机公网 IP + 端口”；容器间通信走内网。
- 兼容约束：拆分后对外行为必须等价，避免“结构改造带来功能变化”。

## 目标
1. 将 `src/openclaw-config.js` 从“单文件多职责”改为“模块化单职责”。
2. 将 `public/app.js` 从“超级控制器”改为“核心层 + 页面层”。
3. 拆分后保持接口契约、用户交互和配置语义不变。

## 不做（Non-Goals）
- 不新增业务功能。
- 不调整页面路由与导航信息结构。
- 不改变现有配置文件字段定义。

## 一、`src/openclaw-config.js` 拆分方案

### 1) 目标目录
```text
src/openclaw-config/
├── schema.js          # zod schema 与类型约束
├── helpers.js         # 纯函数工具（解析、归一化、脱敏辅助）
├── extract.js         # OpenClaw config -> panel settings
├── apply.js           # panel settings -> OpenClaw config
└── storage.js         # load/save + 原子写入
src/openclaw-config.js # 兼容门面，保持旧导出
```

### 2) 依赖方向（硬约束）
- `extract.js` / `apply.js` 可依赖 `schema.js` 与 `helpers.js`。
- `storage.js` 不依赖 `extract.js` / `apply.js`。
- `src/openclaw-config.js` 只做 re-export，不放业务逻辑。
- 禁止循环依赖。

### 3) 对外契约（保持不变）
继续从 `src/openclaw-config.js` 导出：
- `loadOpenClawConfig`
- `extractSettings`
- `applySettings`
- `saveOpenClawConfig`
- `openClawSettingsSchema`

## 二、`public/app.js` 拆分方案

### 1) 目标目录
```text
public/js/
├── core/
│   ├── dom.js                # 通用 DOM 读写工具
│   ├── message-center.js     # 全局提示、时间线提示
│   ├── theme.js              # 主题切换
│   ├── runtime-state.js      # 全局状态容器（只放共享状态）
│   └── bootstrap.js          # 按页面装载 init
├── shared/
│   ├── model-utils.js        # 模型 ref/模式/URL 联动纯函数
│   └── channel-utils.js      # 渠道字段归一化纯函数
└── pages/
    ├── dashboard-page.js
    ├── model-page.js
    ├── channels-page.js
    ├── telegram-page.js
    ├── feishu-page.js
    ├── discord-page.js
    ├── slack-page.js
    ├── skills-page.js
    ├── chat-page.js
    ├── service-page.js
    ├── update-page.js
    ├── logs-page.js
    └── config-generator-page.js
public/app.js                 # 最终仅保留入口与注册表
```

### 2) 拆分原则
- 每个页面模块只处理本页 DOM 与交互。
- 跨页面共享逻辑下沉到 `core` 或 `shared`，禁止页面间互相 import。
- 事件绑定必须“按页激活”，没有对应 DOM 时不得执行。
- 保留 `public/app.js` 作为稳定入口，避免改动所有 HTML script 引用。

### 3) 页面初始化契约
每个页面模块统一导出：
- `initXxxPage(context)`
- 可选 `destroyXxxPage()`（后续如果需要页面缓存/热切换）

`context` 至少包含：
- `requestJson`（来自 `app-api.js`）
- `api`（带统一错误包装）
- `setMessage`
- 必要共享状态 getter/setter

## 三、测试策略与门禁

### 1) 拆分前基线（防回归）
- 固化基线：
  - 现有 `npm test` 结果；
  - 关键 API 手工回放步骤；
  - 关键页面行为清单（保存配置、模型切换、服务启停、更新检查、聊天发送）。
- 先记录，再拆分，避免“没有基线就无法判断回归”。

### 2) 后端拆分测试
- 单元：`test/unit/openclaw-config.test.js` 扩展以下断言：
  1. `extractSettings` 对高级 Telegram 字段输出不变；
  2. `applySettings` 对 JSON 字段/secret 保留策略不变；
  3. `load/save` 读写与备份行为不变。
- 回归：跑全量 `npm test`。

### 3) 前端拆分测试
- 自动化：保持现有回归测试全通过。
- 手工 smoke（Docker 运行态，必须复现）：
  1. `/dashboard`：刷新、模型快速切换；
  2. `/model`：默认模型保存、新增提供商（基础模式）；
  3. `/channels/telegram`：基础引导保存并启用、验证码配对；
  4. `/service`：启动/停止后状态自动刷新；
  5. `/update`：自动检查、手动升级入口；
  6. `/chat-console`：会话切换、发送、流式输出。

### 4) Linux 一致性验证
- 在 Linux Docker 至少执行一次与 Windows 同口径回放。
- 验证项必须包含端口/地址展示：前端外部地址必须为“公网 IP + 端口”。

## 四、结构合理性保障
- 单文件治理阈值：
  - `openclaw-config` 任一模块建议 < 300 行；
  - 页面模块建议 < 500 行，超过即继续拆子模块。
- 单向依赖：`core/shared -> pages`，禁止反向依赖。
- 稳定门面：旧导入路径不变，降低改造面。
- 评审清单：每步检查“职责是否单一、是否可替换、是否可单测”。

## 五、功能等价保障
- 保持 API、配置字段、按钮行为、提示文案语义不变（除明确修 bug 场景）。
- 每阶段提交后立即跑测试 + Docker 重建，不允许“攒到最后统一验证”。
- 每个阶段都留可回退 commit 点，故障时可秒回滚。

## 六、执行顺序
1. 建立拆分基线与测试门禁。
2. 先拆 `src/openclaw-config.js`（后端可测、风险可控）。
3. 再拆 `public/app.js`（先两页试点，再全量页面）。
4. 全量回归 + Linux 复验 + 文档更新。
