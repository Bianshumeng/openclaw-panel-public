This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: src/**, public/**, deploy/**, plan/**
- Files matching these patterns are excluded: node_modules/**, dist/**, coverage/**, .git/**
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
deploy/docker-init.sh
deploy/docker-rollback.sh
deploy/docker-update.sh
deploy/install.sh
deploy/openclaw-panel.service
deploy/panel.config.docker.json
plan/2026-02-15_OpenClaw面板Docker化/规格变更/OpenClaw面板.md
plan/2026-02-15_OpenClaw面板Docker化/技术设计.md
plan/2026-02-15_OpenClaw面板Docker化/任务清单.md
plan/2026-02-15_OpenClaw面板Docker化/提案.md
plan/2026-02-16_前端九页独立化改造/规格变更/OpenClaw面板.md
plan/2026-02-16_前端九页独立化改造/技术设计.md
plan/2026-02-16_前端九页独立化改造/任务清单.md
plan/2026-02-16_前端九页独立化改造/提案.md
plan/2026-02-16_前端九页独立化改造/evidence/3.3_两页试点验证.md
plan/2026-02-16_前端九页独立化改造/evidence/4.x_九页独立化验证.md
plan/2026-02-16_ClawX源码调研/规格变更/OpenClaw面板.md
plan/2026-02-16_ClawX源码调研/技术设计.md
plan/2026-02-16_ClawX源码调研/任务清单.md
plan/2026-02-16_ClawX源码调研/深挖报告_0.2_GatewayRPC能力矩阵.md
plan/2026-02-16_ClawX源码调研/深挖报告_0.3_Chat流式事件链路.md
plan/2026-02-16_ClawX源码调研/深挖报告_0.4_Skills管理边界与权限模型.md
plan/2026-02-16_ClawX源码调研/深挖报告_0.5_Docker运行态稳定性基线.md
plan/2026-02-16_ClawX源码调研/深挖报告_0.6_Win开发与Linux生产一致性门禁清单.md
plan/2026-02-16_ClawX源码调研/深挖报告_1.1_Gateway适配层联调闭环.md
plan/2026-02-16_ClawX源码调研/深挖报告_1.2_Dashboard聚合服务层.md
plan/2026-02-16_ClawX源码调研/深挖报告_1.3_Skills服务层.md
plan/2026-02-16_ClawX源码调研/深挖报告_1.4_Chat服务层.md
plan/2026-02-16_ClawX源码调研/深挖报告_1.5_Chat流式SSE通道.md
plan/2026-02-16_ClawX源码调研/深挖报告_1.6_ClawX用户视角功能差异矩阵.md
plan/2026-02-16_ClawX源码调研/深挖报告_1.7_Chat主页面用户化改造.md
plan/2026-02-16_ClawX源码调研/深挖报告_1.8_Chat附件上传与路径映射.md
plan/2026-02-16_ClawX源码调研/深挖报告_1.9_Chat富渲染与局部错误提示.md
plan/2026-02-16_ClawX源码调研/深挖报告_2.1_仪表盘状态总览增强.md
plan/2026-02-16_ClawX源码调研/深挖报告_2.2_仪表盘模型快速切换.md
plan/2026-02-16_ClawX源码调研/深挖报告_2.3_状态总览侧栏迁移.md
plan/2026-02-16_ClawX源码调研/深挖报告_2.4_仪表盘Shoelace试点改造.md
plan/2026-02-16_ClawX源码调研/深挖报告_3.1_模型与提供商双通道解耦.md
plan/2026-02-16_ClawX源码调研/深挖报告_3.2_基础模板与自定义模式切换强化.md
plan/2026-02-16_ClawX源码调研/深挖报告_3.3_默认模型列表与配置生成器模型ID对齐.md
plan/2026-02-16_ClawX源码调研/深挖报告_3.4_API模式下拉与模型联动.md
plan/2026-02-16_ClawX源码调研/深挖报告_4.1_渠道管理归属清晰.md
plan/2026-02-16_ClawX源码调研/深挖报告_4.2_渠道配置与连通性测试闭环.md
plan/2026-02-16_ClawX源码调研/深挖报告_4.3_Discord与Slack状态展示降级兼容.md
plan/2026-02-16_ClawX源码调研/深挖报告_5.1_Skills列表与状态展示增强.md
plan/2026-02-16_ClawX源码调研/深挖报告_5.2_Skills启停二次确认交互.md
plan/2026-02-16_ClawX源码调研/深挖报告_5.3_Skills配置写回与校验回滚.md
plan/2026-02-16_ClawX源码调研/深挖报告_7.1_自动化测试补齐.md
plan/2026-02-16_ClawX源码调研/深挖报告_7.2_关键路径手工回放.md
plan/2026-02-16_ClawX源码调研/深挖报告_7.3_Docker场景稳定性验证.md
plan/2026-02-16_ClawX源码调研/提案.md
plan/2026-02-16_ClawX源码调研/evidence/channel-discord-slack-4.3-live.md
plan/2026-02-16_ClawX源码调研/evidence/channel-save-test-loop-4.2-live.md
plan/2026-02-16_ClawX源码调研/evidence/channel-scope-4.1-live.md
plan/2026-02-16_ClawX源码调研/evidence/chat-attachments-live.json
plan/2026-02-16_ClawX源码调研/evidence/chat-attachments-pathmap-live.json
plan/2026-02-16_ClawX源码调研/evidence/chat-attachments-ui-live.md
plan/2026-02-16_ClawX源码调研/evidence/chat-rich-render-inlinehint-live.md
plan/2026-02-16_ClawX源码调研/evidence/chat-service-live.json
plan/2026-02-16_ClawX源码调研/evidence/chat-session-new-live.json
plan/2026-02-16_ClawX源码调研/evidence/chat-stream-event-probe-live.json
plan/2026-02-16_ClawX源码调研/evidence/chat-stream-event-probe-live.mjs
plan/2026-02-16_ClawX源码调研/evidence/chat-stream-sse-live.json
plan/2026-02-16_ClawX源码调研/evidence/chat-user-workspace-live.md
plan/2026-02-16_ClawX源码调研/evidence/dashboard-overview-enhanced-live.md
plan/2026-02-16_ClawX源码调研/evidence/dashboard-quick-model-switch-live.md
plan/2026-02-16_ClawX源码调研/evidence/dashboard-shoelace-2.4-live.md
plan/2026-02-16_ClawX源码调研/evidence/dashboard-status-migration-live.md
plan/2026-02-16_ClawX源码调研/evidence/dashboard-summary-live.json
plan/2026-02-16_ClawX源码调研/evidence/docker-stability-7.3-live.md
plan/2026-02-16_ClawX源码调研/evidence/docker-stability-live.json
plan/2026-02-16_ClawX源码调研/evidence/docker-stability-probe-live.mjs
plan/2026-02-16_ClawX源码调研/evidence/gateway-adapter-live.json
plan/2026-02-16_ClawX源码调研/evidence/gateway-rpc-matrix-live.json
plan/2026-02-16_ClawX源码调研/evidence/manual-replay-7.2-live.md
plan/2026-02-16_ClawX源码调研/evidence/model-api-linkage-3.4-live.md
plan/2026-02-16_ClawX源码调研/evidence/model-id-alignment-3.3-live.md
plan/2026-02-16_ClawX源码调研/evidence/model-provider-dual-path-3.1-live.md
plan/2026-02-16_ClawX源码调研/evidence/model-provider-mode-switch-3.2-live.md
plan/2026-02-16_ClawX源码调研/evidence/skills-boundary-live.json
plan/2026-02-16_ClawX源码调研/evidence/skills-boundary-probe-live.mjs
plan/2026-02-16_ClawX源码调研/evidence/skills-config-writeback-5.3-live.md
plan/2026-02-16_ClawX源码调研/evidence/skills-list-status-5.1-live.md
plan/2026-02-16_ClawX源码调研/evidence/skills-service-live.json
plan/2026-02-16_ClawX源码调研/evidence/skills-toggle-confirm-5.2-live.md
plan/2026-02-16_ClawX源码调研/evidence/test-automation-7.1-live.md
plan/2026-02-17_配置核心与前端主脚本拆分/技术设计.md
plan/2026-02-17_配置核心与前端主脚本拆分/任务清单.md
plan/2026-02-17_配置核心与前端主脚本拆分/提案.md
plan/2026-02-17_配置核心与前端主脚本拆分/evidence/1.2_1.3_拆分前基线与一致性口径.md
plan/2026-02-17_配置核心与前端主脚本拆分/evidence/2.x_openclaw-config拆分验证.md
plan/2026-02-17_配置核心与前端主脚本拆分/evidence/3.x_4.x_appjs拆分与回归验证.md
plan/2026-02-17_Telegram启用失败根因修复/规格变更/OpenClaw面板.md
plan/2026-02-17_Telegram启用失败根因修复/任务清单.md
plan/2026-02-17_Telegram启用失败根因修复/提案.md
plan/2026-02-18_更新与模型配置回归修复/任务清单.md
plan/2026-02-18_更新与模型配置回归修复/提案.md
plan/2026-02-18_会话纪要与SSH隧道接入稳定化/会话纪要.md
plan/2026-02-18_会话纪要与SSH隧道接入稳定化/任务清单.md
plan/2026-02-18_会话纪要与SSH隧道接入稳定化/提案.md
plan/2026-02-19_管理面密钥化与非Docker迁移/规格变更/OpenClaw面板.md
plan/2026-02-19_管理面密钥化与非Docker迁移/技术设计.md
plan/2026-02-19_管理面密钥化与非Docker迁移/任务清单.md
plan/2026-02-19_管理面密钥化与非Docker迁移/提案.md
plan/2026-02-24_网关配对自愈与重启按钮/规格变更/OpenClaw面板.md
plan/2026-02-24_网关配对自愈与重启按钮/任务清单.md
plan/2026-02-24_网关配对自愈与重启按钮/提案.md
plan/归档/2026-02-14_OpenClaw面板MVP/规格变更/OpenClaw面板.md
plan/归档/2026-02-14_OpenClaw面板MVP/技术设计.md
plan/归档/2026-02-14_OpenClaw面板MVP/任务清单.md
plan/归档/2026-02-14_OpenClaw面板MVP/提案.md
plan/归档/2026-02-15_OpenClaw渠道扩展_DiscordSlack/规格变更/OpenClaw面板.md
plan/归档/2026-02-15_OpenClaw渠道扩展_DiscordSlack/任务清单.md
plan/归档/2026-02-15_OpenClaw渠道扩展_DiscordSlack/提案.md
plan/归档/2026-02-15_OpenClaw源码对齐面板重构/规格变更/OpenClaw面板.md
plan/归档/2026-02-15_OpenClaw源码对齐面板重构/任务清单.md
plan/归档/2026-02-15_OpenClaw源码对齐面板重构/提案.md
plan/归档/2026-02-16_OpenClaw面板更新入口_测试与CI/规格变更/OpenClaw面板.md
plan/归档/2026-02-16_OpenClaw面板更新入口_测试与CI/技术设计.md
plan/归档/2026-02-16_OpenClaw面板更新入口_测试与CI/任务清单.md
plan/归档/2026-02-16_OpenClaw面板更新入口_测试与CI/提案.md
plan/规格/产品需求.md
plan/规格/后端结构.md
plan/规格/技术栈约束.md
plan/规格/前端规范.md
plan/规格/应用流程.md
plan/规格/OpenClaw面板.md
plan/文档体系说明.md
plan/资料/历史对话总结2026.02.13.21.20.md
plan/资料/历史对话总结2026.02.15.15.05.md
plan/资料/历史对话总结2026.02.17.14.38.md
plan/资料/OpenClaw可视化面板_开发对接说明_v1.md
plan/资料/README.md
plan/资料/Template-Debian-OpenClaw001.md
public/app-api.js
public/app-routes.js
public/app.js
public/config-generator.js
public/index.html
public/js/core/panel-core.js
public/js/pages/chat-page.js
public/js/pages/config-generator-page.js
public/js/pages/model-dashboard-page.js
public/js/pages/skills-page.js
public/js/pages/system-page.js
public/pages/channels-discord.html
public/pages/channels-feishu.html
public/pages/channels-slack.html
public/pages/channels-telegram.html
public/pages/channels.html
public/pages/chat-console.html
public/pages/config-generator.html
public/pages/dashboard.html
public/pages/logs.html
public/pages/model-add.html
public/pages/model.html
public/pages/service.html
public/pages/skills.html
public/pages/update.html
public/styles.css
src/channel-onboarding.js
src/channel-tests.js
src/chat-service.js
src/dashboard-service.js
src/direct-update.js
src/docker-update.js
src/gateway-client.js
src/logs.js
src/openclaw-config.js
src/openclaw-config/apply.js
src/openclaw-config/extract.js
src/openclaw-config/helpers.js
src/openclaw-config/model-catalog.js
src/openclaw-config/schema.js
src/openclaw-config/storage.js
src/panel-config.js
src/server.js
src/skills-service.js
src/smoke-check.js
src/systemd.js
src/utils.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="plan/2026-02-15_OpenClaw面板Docker化/规格变更/OpenClaw面板.md">
# OpenClaw面板 - 变更

## 修改需求
### 需求：运行参数可配置
面板必须支持监听地址、端口、OpenClaw 配置路径、服务名、容器名、日志来源、运行时模式等运行参数可配置。

#### 场景：Docker 模板适配
- 当 模板机采用容器化部署
- 那么 运维人员必须可通过配置切换到 `runtime.mode=docker` 并指定 `openclaw.container_name`

### 需求：服务生命周期控制
面板必须支持对 OpenClaw 运行实例执行启动、停止、重启、状态查询，且兼容 `systemd` 与 `docker` 两种运行时。

#### 场景：Docker 服务控制
- 当 用户在 Docker 模式下执行服务操作
- 那么 系统必须调用容器控制命令并返回明确结果

### 需求：日志可观测
面板必须提供实时日志查看与错误定位能力。

#### 场景：Docker 日志来源
- 当 日志来源设置为 `docker`
- 那么 系统必须读取容器日志并支持尾部读取与实时流
</file>

<file path="plan/2026-02-15_OpenClaw面板Docker化/技术设计.md">
# 技术设计

## 背景与约束
- 目标平台：Debian 13 模板机
- 当前实现依赖：`systemd` 服务控制、`journalctl` 日志读取
- 目标要求：容器化运行、低资源占用、可控升级与回滚

## 目标
- 双容器稳定运行：`openclaw` + `panel`
- 面板保持现有功能：配置中心、服务控制、日志排障
- 支持受控版本更新（固定 tag，不追 `latest`）

## 不做（Non-Goals）
- 不实现多 Bot UI 与编排
- 不引入 Kubernetes 或重型编排

## 技术决策
| 决策点 | 选择 | 原因 | 放弃方案 |
|--------|------|------|----------|
| 容器组织 | 双容器 compose | 进程边界清晰、升级/回滚独立 | 单容器双进程（耦合高） |
| 服务控制 | Docker Runtime 适配层 | 与现有 API 兼容，最小侵入 | 继续硬编码 systemd |
| 日志来源 | `docker logs` + 流式跟随 | 统一容器语义 | 仅保留 journal/file |
| 更新策略 | 受控 tag + 版本清单 | 可预测、可回滚 | 直接追 `latest` |

## 风险与缓解
| 风险 | 缓解措施 |
|------|----------|
| Docker socket 暴露导致权限过大 | 面板仅内网访问 + 反代鉴权 + 最小暴露端口 |
| 上游版本变更导致配置字段漂移 | 发布前验收脚本 + 固定 tag 放行 |
| 升级失败影响在线可用 | 升级前备份 + 自动回滚到上个稳定 tag |

## 迁移/回滚方案
- 迁移步骤：
  1. 准备 compose 与面板镜像
  2. 挂载 OpenClaw 配置卷
  3. 启动 `docker compose up -d`
  4. 面板切换 runtime 到 `docker`
- 回滚步骤：
  1. 将镜像 tag 切回上一个稳定版本
  2. `docker compose up -d`
  3. 核验健康与配置
- 验证方式：
  - `docker compose ps`
  - 面板服务控制接口成功
  - 面板日志流可持续输出
</file>

<file path="plan/2026-02-15_OpenClaw面板Docker化/任务清单.md">
# 任务清单

## 1. 准备阶段
- [x] 1.1 确认当前环境可用 Docker/Compose | 验收：`docker --version`、`docker compose version`
- [x] 1.2 梳理现有 systemd/journal 依赖点 | 验收：定位服务控制与日志读取模块

## 2. 实现阶段
- [x] 2.1 新增容器构建文件 | 验收：`Dockerfile` 可构建面板镜像
- [x] 2.2 新增 compose 编排 | 验收：`openclaw + panel` 双容器可启动
- [x] 2.3 运行时抽象改造 | 验收：支持 `runtime.mode=systemd|docker`
- [x] 2.4 日志源扩展 | 验收：支持 `docker logs` 实时流与摘要
- [x] 2.5 部署脚本与参数模板 | 验收：模板机可一键启动/升级/回滚

## 3. 验证阶段
- [x] 3.1 面板接口回归通过 | 验收：`/api/settings`、`/api/service/*`、`/api/logs/*`
- [x] 3.2 容器联调通过 | 验收：配置写入、启停、日志均可用
- [x] 3.3 回滚演练通过 | 验收：升级失败后可恢复上个标签

## 4. 收尾阶段
- [x] 4.1 更新规格文档 | 验收：`plan/规格/OpenClaw面板.md` 同步 runtime 与部署模式
- [ ] 4.2 归档任务目录 | 验收：移动到 `plan/归档/`

## 经验记录
### 步骤 1 完成记录
- 实际情况：当前开发环境已具备 Docker 与 Compose，可直接在本机联调
- 遇到问题：无
- 技术债：后续需补“多 Bot 驱动层”抽象，当前先聚焦 OpenClaw

### 步骤 3 完成记录
- 实际情况：已完成 `pull -> build -> up` 实容器联调，`openclaw-gateway` 与 `openclaw-panel` 均为运行态
- 遇到问题：GHCR 拉取偶发 `EOF`，已在部署脚本补充拉取重试机制
- 技术债：Windows + WSL 环境运行 Bash 脚本时存在 compose 项目名兼容噪音，生产 Debian 不受影响
</file>

<file path="plan/2026-02-15_OpenClaw面板Docker化/提案.md">
# OpenClaw 面板 Docker 化改造

创建时间：2026-02-15 00:00:00

## 为什么做
当前面板依赖宿主机 `systemd + journalctl`，不利于模板机标准化交付与一键升级。需要改为容器化部署，并为后续“受控版本更新”打基础。

## 改什么
- 引入 `docker-compose` 编排，采用双容器结构：`openclaw` + `panel`
- 面板运行模式从 `systemd` 抽象为 `runtime`，新增 `docker` 运行时实现
- 日志来源新增 `docker`，支持读取 OpenClaw 容器日志
- 提供模板机可复用部署脚本（启动、升级、回滚）
- 保持现有可视化配置能力与页面交互不变

## 影响范围
- 涉及模块：`src/systemd.js`、`src/logs.js`、`src/panel-config.js`、`src/server.js`
- 新增文件：`docker-compose.yml`、`Dockerfile`、`deploy/*.sh`、文档
- 风险等级：L2

## 不做什么（边界）
- 本阶段不做多 Bot 编排界面（只保证 OpenClaw 跑通）
- 本阶段不做完整在线升级 UI（先预留更新通道与版本清单结构）
- 不直接追上游 `latest` 作为生产默认版本

## 验证（必填）
- `docker compose up -d` 后面板可访问、配置可读写
- 面板可控制 OpenClaw 容器启停与状态
- 面板可读取 OpenClaw 容器日志
- 失败演练：模拟升级失败后可回滚到上一个镜像标签

## 回滚（必填）
- 回滚触发条件：启动失败、健康检查失败、关键配置写入异常
- 回滚步骤：恢复上一版本镜像标签并 `docker compose up -d`
</file>

<file path="plan/2026-02-16_前端九页独立化改造/规格变更/OpenClaw面板.md">
# OpenClaw面板 - 变更

## 新增需求
### 需求：九页独立文件架构
将侧边栏九个业务页面从单一 `index.html` 分区结构，迁移为独立页面文件架构，并保持原有 URL 与用户可见功能一致。

#### 场景：用户访问独立页面路由
- 当 用户访问 `/dashboard`、`/model` 等已知页面路由
- 那么 服务端必须返回对应页面文件，页面功能与拆分前行为一致

#### 场景：页面按需加载
- 当 用户进入某个页面
- 那么 仅加载该页面必需的初始化逻辑，其他页面逻辑不应在当前页面执行

#### 场景：试点门禁
- 当 两页试点（Dashboard、Model）未通过自动化与 Docker 验证
- 那么 不得进入其余七页的批量拆分

## 修改需求
### 需求：前端页面组织方式
原有实现基于单页多分区承载九个页面。

修改后：
- 采用“多页面文件 + 共享壳层 + 按页脚本”组织方式；
- 路由路径保持不变；
- 页面拆分过程中必须保证模型、渠道、技能、聊天、日志、更新等核心能力不回退。

## 移除需求
### 需求：无
移除原因：无
迁移方案：无
</file>

<file path="plan/2026-02-16_前端九页独立化改造/技术设计.md">
# 技术设计

## 背景与约束
- 现状：9 个页面通过 `section[data-panel]` 共存于 `public/index.html`，并由 `public/app.js` 同时初始化。
- 约束：
  - 保持 Fastify + 原生 HTML/CSS/JS 架构，不引入新框架。
  - 路由路径保持兼容：`/dashboard`、`/model` 等用户入口不变。
  - 生产环境为 Linux Docker，开发在 Windows Docker；必须维持可迁移性。
  - 所有对外地址/端口遵守“母机 IP + 分配端口”约束，不引入硬编码端口。

## 目标
- 把“单页 9 分区”改为“9 个独立页面文件 + 共享壳层 + 按页脚本”。
- 保持用户视角功能一致，优先提升可维护性与回归可控性。
- 先完成两页试点（Dashboard、Model），作为后续 7 页模板。

## 不做（Non-Goals）
- 不做视觉大改版。
- 不做 API 协议变更。
- 不做 OpenClaw 核心逻辑改造。

## 目标架构
### 1) 页面文件层
- `public/pages/dashboard.html`
- `public/pages/model.html`
- 后续扩展：skills/chat-console/config-generator/channels/update/service/logs。

### 2) 共享壳层层
- 共享侧栏、页头、全局消息区、主题切换逻辑。
- 共享路由映射：`public/app-routes.js` 继续作为唯一真相来源。

### 3) 前端脚本层
- `public/js/core/*`：API 请求、公共工具、全局状态。
- `public/js/pages/dashboard.js`：仪表盘页面逻辑。
- `public/js/pages/model.js`：模型与提供商页面逻辑。
- 后续页面按同样模式继续拆。

### 4) 服务端路由层
- `src/server.js` 对“已知页面路由”返回对应 HTML；未知前端路由回退默认页（兼容旧入口）。

## 拆分策略
### 阶段 A：两页试点（本轮）
- 将 `/dashboard` 与 `/model` 从 `index.html` 中拆出独立页面。
- 为两页建立独立初始化入口，验证：
  - Dashboard：总览刷新、模型快速切换、状态列表渲染。
  - Model：默认模型切换、模板/自定义提供商配置。
- 试点通过后再复制模式至其余 7 页。

### 阶段 B：其余 7 页批量拆分（后续）
- 每页拆分后立即回归对应功能，不打包“全部拆完再测”。
- 每页完成即提交 checkpoint，保留回滚锚点。

## 决策与取舍
| 决策点 | 选择 | 原因 | 放弃方案 |
|--------|------|------|----------|
| 页面组织 | 多 HTML 独立页面 | 降低耦合、减少误伤 | 继续单页堆叠 |
| 框架策略 | 保持原生 JS | 与现有栈一致，风险低 | 引入 SPA 框架重写 |
| 迁移方式 | 先两页试点再扩展 | 控风险、可回滚 | 一次性全量拆分 |
| 路由兼容 | 保持 URL 不变 | 用户无感迁移 | 改 URL 并做重定向 |

## 风险与缓解
| 风险 | 缓解措施 |
|------|----------|
| 共享状态丢失导致行为变化 | 提取 core 状态与 API 层，建立页面初始化契约 |
| 侧栏重复维护导致不一致 | 共享侧栏模板/组件，单点维护导航映射 |
| CSS 作用域冲突 | 先保留全局样式，再逐步模块化，不一次性重写 |
| Docker 重建后页面 404 | 路由映射先加回归用例，确保静态文件可达 |

## 迁移/回滚方案
- 迁移步骤：
  1. 文档落盘并确认门禁；
  2. 完成两页拆分 + 自动化 + Docker 验证；
  3. 根据试点结果更新文档；
  4. 批量拆剩余 7 页。
- 回滚步骤：
  1. 回退到试点前 commit；
  2. 保留问题记录并收敛后重做试点；
  3. 未通过前不进入批量拆分。
- 验证方式：
  - 自动化测试 + Docker 运行态 + 手工关键路径回放。
</file>

<file path="plan/2026-02-16_前端九页独立化改造/任务清单.md">
# 任务清单

## 1. 文档与门禁阶段
- [x] 1.1 完成提案、技术设计、任务清单、规格变更落盘 | 验收：`plan/2026-02-16_前端九页独立化改造/` 文档齐全
- [x] 1.2 明确两页试点验收口径 | 验收：Dashboard/Model 关键路径清单明确

## 2. 基础拆分能力阶段
- [x] 2.1 建立共享壳层与导航复用机制 | 验收：侧栏与页头不重复硬编码 9 份
- [x] 2.2 建立页面级初始化入口（按页加载脚本） | 验收：无关页面脚本不再在当前页执行
- [x] 2.3 服务端已知路由映射到独立 HTML | 验收：`/dashboard`、`/model` 可直达对应文件

## 3. 两页试点阶段（本轮）
- [x] 3.1 拆分 Dashboard 页面为独立文件 | 验收：总览刷新、模型切换、运行态列表正常
- [x] 3.2 拆分 Model 页面为独立文件 | 验收：默认模型切换、提供商模板/自定义配置正常
- [x] 3.3 两页试点回归 + Docker 重建验证 | 验收：`npm test` + `docker compose up -d --build panel` 通过
- [x] 3.4 根据试点结果更新文档 | 验收：任务清单与经验记录同步

## 4. 其余七页批量拆分阶段（后续）
- [x] 4.1 Skills 页面拆分 | 验收：状态、启停、配置回写正常
- [x] 4.2 Chat 页面拆分 | 验收：多会话、流式、停止、附件正常
- [x] 4.3 配置生成器页面拆分 | 验收：生成逻辑与继承选项正常
- [x] 4.4 Channels 页面拆分 | 验收：配置保存与连通性测试正常
- [x] 4.5 Update 页面拆分 | 验收：检查/升级/回滚链路正常
- [x] 4.6 Service 页面拆分 | 验收：服务控制命令可用
- [x] 4.7 Logs 页面拆分 | 验收：日志读取与筛选正常

## 5. 收尾阶段
- [ ] 5.1 合并规格变更到 `plan/规格/OpenClaw面板.md` | 验收：主规格与实现一致
- [ ] 5.2 更新 README 与开发说明 | 验收：新增页面结构和开发入口清楚
- [ ] 5.3 归档任务目录 | 验收：归档前验收证据完整

## 经验记录
### 步骤 1.1 完成记录
- 实际情况：已完成九页独立化改造任务文档落盘，明确先试点两页再批量推广。
- 遇到问题：当前仓库已有未提交改动（`AGENTS.md`、`public/*`、既有任务清单），需要在后续提交中做分组隔离，避免混淆。
- 技术债：共享壳层与页面初始化契约尚未编码，属于下一步核心风险点。

### 步骤 2.2 / 2.3 / 3.1 / 3.2 / 3.3 / 3.4 完成记录
- 实际情况：已完成 `dashboard/model` 两页独立文件拆分，新增 `public/pages/dashboard.html` 与 `public/pages/model.html`，并在 `src/server.js` 增加已知路由到独立文件的映射（`/`、`/dashboard`、`/model`）。
- 实现细节：`public/app.js` 已改为页面感知初始化（按 `data-panel` 是否存在决定是否绑定对应模块），并补齐空元素安全保护，避免独立页缺少无关 DOM 时抛错。
- 验证证据：`npm test` 全量通过；`docker compose up -d --build panel` 成功；`/dashboard` 与 `/model` 已确认返回独立页面文件。
- 遇到问题：浏览器 MCP 当前被已有 profile 占用，无法执行 console 面板校验；本轮以自动化 + 运行态 HTTP 探针替代。
- 技术债：暂无新增阻断债务。

### 步骤 2.1 / 4.1~4.7 完成记录
- 实际情况：已新增 `public/pages/` 九个独立页面文件，并完成全部业务路由映射：`/dashboard`、`/skills`、`/chat-console`、`/model`、`/config-generator`、`/channels`、`/update`、`/service`、`/logs`。
- 实际情况补充：根路径 `/` 已显式映射到 `pages/model.html`，双入口问题已收敛。
- 实现细节：新增 `data-sidebar-nav` 导航容器与 `renderSidebarTabs()`，将侧栏导航生成逻辑集中到 `public/app.js`，避免 9 页重复硬编码导航项。
- 验证证据：`npm test` 全量通过；Docker 重建通过；9 条路由均命中“单页面单面板”输出（每页仅包含对应 `data-panel`）。
- 遇到问题：浏览器 MCP 在当前环境被占用，无法补采控制台日志；已用自动化 + HTTP 探针替代验证。
- 技术债：收尾阶段建议评估是否完全移除旧 `index.html` 多面板回退逻辑，进一步降低维护分叉风险。

### 步骤 4.x 后续修复记录（侧栏闪烁）
- 实际情况：用户反馈“切页时左侧侧栏闪烁”，根因定位为侧栏导航采用运行时动态注入（页面初始为空，JS 执行后填充）。
- 修复动作：将 9 个独立页面的侧栏改为静态预渲染，并移除 `public/app.js` 中 `renderSidebarTabs()` 与对应动态导航常量。
- 验证证据：`npm test` 通过；`docker compose up -d --build panel` 通过；页面刷新后导航可直接展示，不再依赖 JS 注入。
- 技术债：若后续继续扩展导航项，需通过脚本模板统一生成，避免手工改 9 份造成漂移。
</file>

<file path="plan/2026-02-16_前端九页独立化改造/提案.md">
# 前端九页独立化改造

创建时间：2026-02-16 02:10:00

## 为什么做
- 当前前端是“单 HTML + 单大脚本”的单页面板：9 个业务页面都塞在 `public/index.html` 与 `public/app.js`。
- 这种结构在功能继续增加后，页面间耦合会持续放大：改一个页面容易误伤另一个页面，回归成本高。
- 本项目面向小白用户，要求“稳定、简单、可长期维护”；继续堆在单文件会快速演化成高风险维护模式。

## 改什么
- 将现有 9 个侧栏页面从单页分区结构拆为独立页面文件（多路由 + 多 HTML + 分页脚本）。
- 建立共享壳层（侧栏、页头、全局提示、基础样式）与按页加载机制，避免重复代码。
- 第一阶段先做两页试点：`/dashboard` 与 `/model`；验证通过后按同一模式拆其余 7 页。
- 路由保持不变（用户访问地址不变），仅替换实现形态。

## 影响范围
- 前端：`public/index.html`、`public/app.js`、`public/styles.css`（拆分并降耦）。
- 新增：`public/pages/*.html`、`public/js/core/*`、`public/js/pages/*`。
- 后端：`src/server.js`（已知路由到独立页面文件的静态返回策略）。
- 风险等级：L2（跨模块、涉及页面架构重排）。

## 不做什么（边界）
- 不引入 React/Vue/Vite 等新框架和构建链。
- 不修改 OpenClaw/龙虾 Bot 核心源码。
- 不在本任务内大改业务功能，只做结构拆分与等价迁移。
- 不改变既有 API 契约和字段语义。

## 验证（存在风险时必填）
- 自动化：`npm test` 必须通过。
- 运行态：`docker compose up -d --build panel` 后，`/dashboard`、`/model` 页面可用且核心操作通过。
- 手工回放：模型切换、仪表盘刷新、快速跳转、配置写回至少各一次。
- 环境一致性：记录 Windows Docker 与 Linux 生产门禁差异项，确保后续可在 Linux 复验。

## 回滚（存在风险时必填）
- 回滚触发条件：拆分后出现页面不可访问、核心操作失败、跨页样式/逻辑串扰。
- 回滚步骤：
  1. 回退到拆分前稳定 commit；
  2. 保留当前文档与问题清单，按问题最小化重做；
  3. 重新从“两页试点”进入，不直接全量拆分。
</file>

<file path="plan/2026-02-16_前端九页独立化改造/evidence/3.3_两页试点验证.md">
# 两页试点验证证据（Dashboard / Model）

## 自动化
- `npm test`：通过（unit 51/51，regression 3/3，1 skip 为既有用例）

## Docker 运行态
- `docker compose up -d --build panel`：通过
- 面板容器状态：`openclaw-panel Started`

## 页面路由探针
- `/dashboard`：命中独立文件（包含 `data-panel="panel-dashboard"`，不含 `panel-model`）
- `/model`：命中独立文件（包含 `data-panel="panel-model"`，不含 `panel-dashboard`）
- `/skills`：仍走 `index.html` 兜底（包含 `panel-skills` + `panel-model`）

## 备注
- 浏览器 MCP 因已有 Chrome profile 占用，未完成 console 错误面板采集；本轮以自动化 + HTTP 探针替代。
- 本证据仅对应“两页试点”阶段；后续九页全量拆分结果见 `evidence/4.x_九页独立化验证.md`。
</file>

<file path="plan/2026-02-16_前端九页独立化改造/evidence/4.x_九页独立化验证.md">
# 九页独立化路由验证证据

## 自动化
- `npm test`：通过（unit 51/51，regression 3/3，1 skip 为既有用例）

## Docker
- `docker compose up -d --build panel`：通过

## 路由单页命中检查
- `/` -> `panel-model`（单面板）
- `/dashboard` -> `panel-dashboard`（单面板）
- `/skills` -> `panel-skills`（单面板）
- `/chat-console` -> `panel-chat-console`（单面板）
- `/model` -> `panel-model`（单面板）
- `/config-generator` -> `panel-config-generator`（单面板）
- `/channels` -> `panel-channel`（单面板）
- `/update` -> `panel-update`（单面板）
- `/service` -> `panel-service`（单面板）
- `/logs` -> `panel-logs`（单面板）

## 检查方式
- 对每条路由执行 HTTP 获取并统计：
  - 是否包含目标 `data-panel="panel-xxx"`
  - 页面中 `data-panel="panel-` 出现次数是否为 1

## 备注
- 当前 10 条入口（`/` + 9 条业务路由）均已命中独立页面文件。
</file>

<file path="plan/2026-02-16_ClawX源码调研/规格变更/OpenClaw面板.md">
# OpenClaw面板 - 变更

## 新增需求

### 需求：插件式控制边界强约束
控制台必须作为龙虾 Bot 的外部控制器运行，不得通过修改龙虾 Bot 源码实现面板能力。

#### 场景：能力扩展
- 当 新增 Dashboard/Skills/Chat 等能力
- 那么 系统必须通过配置文件、服务控制与 Gateway 接口实现，而不是改写 OpenClaw 内核

#### 场景：升级兼容
- 当 OpenClaw 升级
- 那么 控制台必须通过适配层处理兼容差异，保持最小耦合

---

### 需求：状态总览增强
仪表盘必须展示面板关键运行指标，并支持模型快速切换与风险提示。

#### 场景：状态卡片
- 当 用户打开仪表盘
- 那么 系统必须展示 Gateway 状态、当前模型与提供商、渠道状态分布、Skills 启用数、错误摘要、版本信息

#### 场景：模型切换风险提示
- 当 用户从大上下文模型切到小上下文模型
- 那么 系统必须提示“可能因上下文超限导致失败”的风险

#### 场景：快捷操作
- 当 用户在仪表盘执行常见操作（聊天、模型配置、渠道配置、Skills 管理、版本更新、服务控制）
- 那么 系统必须提供可直接跳转入口，减少跨页面查找成本

#### 场景：运行态明细
- 当 用户需要确认当前渠道与 Skills 的运行明细
- 那么 系统必须在仪表盘显示渠道运行态列表和 Skills 运行态列表

#### 场景：入口收敛与旧链接兼容
- 当 用户使用侧栏或历史收藏链接访问状态总览
- 那么 系统必须以仪表盘作为唯一状态入口，并兼容 `/status-overview` 旧路径跳转到仪表盘视图

---

### 需求：Chat 能力迁移（主聊天页）
控制台必须提供面向小白用户的主聊天页，支持多会话、流式消息与思考状态显示，不以调试输出作为默认视图。

#### 场景：多会话
- 当 用户切换或新建会话
- 那么 系统必须按 `sessionKey` 隔离历史，不得串话

#### 场景：流式消息
- 当 用户发送消息
- 那么 系统必须在消息区域原位展示 `delta`，并在 `final` 时完成消息落地

#### 场景：思考状态
- 当 用户开启/关闭思考显示
- 那么 系统必须仅影响前端展示，不改变后端推理请求参数

#### 场景：中止执行
- 当 用户点击中止
- 那么 系统必须调用中止接口并恢复输入态

#### 场景：小白默认视图
- 当 用户首次进入聊天页
- 那么 系统必须默认展示“会话 + 聊天消息 + 输入区”，高级调试信息默认折叠

#### 场景：附件上传与发送
- 当 用户上传、粘贴或拖拽附件后发送消息
- 那么 系统必须先将附件落盘到 OpenClaw 媒体目录，再将路径映射为网关可见路径后发送

#### 场景：消息富渲染
- 当 助手回复中包含 Markdown 或工具调用/工具结果
- 那么 系统必须进行可读化渲染，避免向小白用户展示原始结构化文本

#### 场景：局部错误提示
- 当 聊天页中的操作失败（发送、刷新、附件处理、中止、重置）
- 那么 系统必须在聊天页内联提示具体失败原因，不只依赖全局日志提示

---

### 需求：Skills 管理
控制台必须提供技能状态可视化与启停管理能力。

#### 场景：技能列表
- 当 用户进入 Skills 页面
- 那么 系统必须展示技能名称、启用状态、更新时间与简要说明

#### 场景：更新时间缺省兜底
- 当 上游技能数据没有返回更新时间
- 那么 系统必须显式展示“最近更新: 无”，避免用户误判为加载异常

#### 场景：高风险操作确认
- 当 用户执行可能影响运行稳定性的技能操作
- 那么 系统必须进行二次确认并记录审计信息

#### 场景：取消确认不应触发写入
- 当 用户在二次确认弹窗中取消
- 那么 系统不得发送 Skills 启停写入请求，并需给出“已取消操作”的可见反馈

#### 场景：Skill 配置可视化写回
- 当 用户在 Skills 页面提交 `enabled/apiKey/env` 的字段补丁
- 那么 系统必须只写入用户填写字段，未填写字段保持不变，并在页面内显示结果

#### 场景：写后校验与失败回滚
- 当 Skill 配置写盘后回读校验失败
- 那么 系统必须自动回滚到写入前备份，并返回明确根因

---

### 需求：渠道管理归属清晰
渠道管理页面必须明确为 OpenClaw 真实渠道配置入口，不引入面板私有渠道模型。

#### 场景：页面范围声明
- 当 用户进入渠道管理页
- 那么 系统必须显式声明“仅管理 OpenClaw 真实渠道”，并说明写回字段范围，避免把面板误当成独立渠道系统

#### 场景：渠道配置
- 当 用户配置 Telegram/飞书等渠道
- 那么 系统必须写回 OpenClaw 对应渠道字段并支持连通性测试

#### 场景：保存与连通性测试闭环
- 当 用户在 Telegram/飞书配置区点击“保存并测试”
- 那么 系统必须先保存配置再执行连通性测试，并在当前页面展示可复现的成功/失败结果（含时间与原因）

#### 场景：Discord/Slack 状态展示与降级
- 当 用户测试 Discord 或 Slack 连通性
- 那么 系统必须在各自通道卡片展示最近测试结果；若接口不可用或参数缺失，应页面内优雅提示而非中断整页功能

#### 场景：能力降级
- 当 某渠道接口不可用
- 那么 系统必须优雅降级并提示原因，不得阻塞其他渠道配置

---

### 需求：提供商与更新流程优化
控制台必须保留当前提供商与版本更新能力，并可按更优交互增强，但不得破坏现有流程。

#### 场景：提供商配置
- 当 用户使用模板或自定义模式配置提供商
- 那么 系统必须保证模型 ID、API 模式、URL 联动规则正确

#### 场景：模板与自定义模式可理解切换
- 当 用户进入“新增提供商”路径
- 那么 系统默认应进入“基础配置（推荐）”并只暴露最小必填字段，`models JSON` 等高级字段必须在用户主动切换到“自定义模式”后才展示

#### 场景：模型 ID 列表同源一致
- 当 用户在“配置生成器”“默认模型设置”“模板高级参数”之间切换
- 那么 系统必须使用同一份默认模型 ID 列表渲染，避免不同页面出现不一致模型选项

#### 场景：AICodeCat API 模式与 URL 联动
- 当 用户在新增提供商页面（模板或自定义）切换 GPT/Claude/Gemini 模型族或 API 模式
- 那么 系统必须自动联动 `providerId`、`api` 与 `baseUrl` 到对应 AICodeCat 路径，并允许用户在 custom 模式下覆写为自定义值

#### 场景：默认模型与新增提供商解耦
- 当 用户在“新增提供商”路径保存模板或自定义配置
- 那么 系统默认不得改动当前默认模型，只有用户显式勾选“保存后设为当前默认模型”时才允许切换 `agents.defaults.model.primary`

#### 场景：版本更新
- 当 用户检查更新、升级或回滚
- 那么 系统必须保持 Docker 运行态兼容与失败回滚能力

## 修改需求
### 需求：可视化配置中心
（保留主规格原文，实施时按本变更新增“Chat 控制台能力”与“Skills 管理能力”入口，不改变原有模型与渠道配置基线。）

## 移除需求
### 需求：首次安装向导迁移
移除原因：目标场景为预装交付服务器，用户拿到即用，不需要首启引导。
迁移方案：保留简洁提示文案与配置校验，不引入向导流程。

## 契约变更（草案）
| 字段/接口 | 类型 | 必需 | 约束 | 兼容性说明 | 备注 |
|------|------|------|------|-----------|------|
| `GET /api/dashboard/summary` | HTTP | 是 | 返回聚合状态 | 新增接口，不影响旧接口 | 仪表盘读取 |
| `GET /api/chat/sessions` | HTTP | 是 | 返回会话列表 | 新增接口 | 对话控制台 |
| `GET /api/chat/history` | HTTP | 是 | 必须带 `sessionKey` | 新增接口 | 对话控制台 |
| `POST /api/chat/send` | HTTP | 是 | 文本非空或附件非空 | 新增接口 | 对话控制台 |
| `POST /api/chat/abort` | HTTP | 是 | 需提供会话标识 | 新增接口 | 中止当前运行 |
| `GET /api/chat/stream` | SSE/WS | 是 | 支持断线重连 | 新增接口 | 流式消息 |
| `POST /api/chat/session/new` | HTTP | 是 | 自动生成新会话 key | 新增接口 | 智能对话页 |
| `GET /api/skills/status` | HTTP | 是 | 返回技能状态列表 | 新增接口 | Skills 列表 |
| `GET /api/skills/:skillKey/config` | HTTP | 是 | 返回指定 Skill 的脱敏配置 | 新增接口 | Skills 配置查看 |
| `PUT /api/skills/:skillKey/config` | HTTP | 是 | 仅允许 patch 写入，写后校验失败需回滚 | 新增接口 | Skills 配置写回 |
| `POST /api/skills/:skillKey/enabled` | HTTP | 是 | 高风险动作需确认 | 新增接口 | Skills 启停 |

### 示例：发送消息请求（草案）
```json
{
  "sessionKey": "agent:main:session-1739690000000",
  "message": "总结一下今天的错误日志",
  "attachments": []
}
```

### 示例：聊天流事件（草案）
```json
{
  "runId": "run_abc123",
  "sessionKey": "agent:main:session-1739690000000",
  "state": "delta",
  "message": {
    "role": "assistant",
    "content": [
      { "type": "text", "text": "正在分析..." }
    ]
  }
}
```
</file>

<file path="plan/2026-02-16_ClawX源码调研/技术设计.md">
# 技术设计

## 背景与约束
- 当前项目是 Web 控制台（Fastify + 静态前端），以 Docker 方式运行，核心职责是“外部控制器”。
- 被调度对象是 OpenClaw/龙虾 Bot 运行时，不允许通过修改 OpenClaw 源码来实现面板能力。
- `third_party/ClawX` 可提供功能逻辑参考，但其 Electron IPC、桌面集成、更新机制不能直接迁移。
- 现有模块已具备配置写入、服务控制、日志流、版本更新、基础页面路由，适合作为增量扩展基础。
- 当前开发环境是 Windows 主机中的 Docker，生产环境是 Linux 主机中的 Docker；所有新增能力必须通过 Linux 可用性门禁后才可视为完成。
- 生产部署为“母机单公网 IP + 分配端口”模式：外部访问依赖 `公网IP:端口`，容器内部通信走 Docker 内网与共享卷。

## 目标
- 在不破坏插件式控制架构的前提下，迁移 ClawX 的高价值能力：
  - 状态总览增强（Dashboard）。
  - Skills 管理（查询、启用/停用、必要配置入口）。
  - Chat 能力增强（多会话、流式消息、思考状态显示），并升级为面向小白的主聊天工作台体验。
  - 提供商与更新流程的交互优化（保留现有后端边界）。
- 将迁移工程拆成“深挖门禁 -> 接口契约 -> 分阶段实施 -> 回归验收”。

## 不做（Non-Goals）
- 不迁移首次安装向导、任务调度（Cron）、主题系统。
- 不引入 Electron 进程模型，不新增桌面端依赖。
- 不将控制台重构成龙虾 Bot 的内嵌前端。

## 架构原则（硬约束）
1. 插件式控制器：控制台只通过配置文件、服务控制命令、Gateway RPC 与 OpenClaw交互。
2. 边界清晰：后端负责协议转换与安全控制，前端只负责展示和交互。
3. 可回滚：每批能力独立开关，失败可单独回退，不影响已有配置/更新/日志模块。
4. 可观测：新增接口必须具备请求日志、错误码、超时标识。
5. 先深挖后实施：关键接口可用性未确认前，不进入不可逆实现。
6. 环境一致性：Windows 开发验证不等于生产验收，关键能力必须补 Linux 实机验证。
7. 端口不可硬编码：所有对外端口必须配置化（env/配置文件），前端展示地址与 webhook 回调统一输出 `公网IP:端口`。

## 目标架构分层
### 1) 控制层（现有）
- `src/server.js`：REST/SSE 入口与路由注册。

### 2) 领域适配层（新增）
- `src/gateway-client.js`：统一封装 Gateway RPC 调用、超时、重试、错误归一化。
- `src/chat-service.js`：会话列表、历史、发送、中止、会话新建、附件落盘与路径映射、流事件分发。
- `src/skills-service.js`：技能状态读取、启停、配置写回代理。
- `src/dashboard-service.js`：聚合模型/渠道/技能/运行状态指标。

### 3) 配置与持久层（现有增强）
- `src/openclaw-config.js`：继续负责配置抽取与写入（模型/渠道/提供商）。
- `src/panel-config.js`：面板运行参数与功能开关。
- `src/logs.js`：保留日志读取与错误摘要。

### 4) 前端展示层（现有增强）
- `public/app.js`：按页面模块拆分逻辑，新增 chat/skills/dashboard 交互模块，Chat 改为“主聊天页”交互模型。
- `public/index.html`：将“对话控制台”入口升级为“智能对话”，默认展示会话与聊天消息，不暴露调试术语。
- `public/styles.css`：补充聊天消息气泡、流式状态、会话列表和移动端输入区样式。

## 技术决策
| 决策点 | 选择 | 原因 | 放弃方案 |
|--------|------|------|----------|
| Chat 事件传输 | 优先 SSE，必要时升级 WS | 现有日志流已使用 SSE，接入成本低 | 直接抄 Electron 事件桥 |
| Gateway 调用 | 后端统一适配层 | 避免前端散落 RPC 细节与重试逻辑 | 前端直连 Gateway |
| 会话状态存储 | OpenClaw 为主、面板仅缓存展示态 | 防止双写冲突 | 面板侧自建会话主存储 |
| Skills 管理入口 | 面板聚合 + Gateway 代理 | 保持插件式边界 | 直接操作未知脚本/目录 |
| 渐进发布 | 分批路由开关 | 降低回归风险 | 一次性大改上线 |

## 深挖门禁与验证方法
### 门禁 A：Gateway RPC 可用性
- 验证方法：在 Docker 环境逐项调用 `sessions.list/chat.history/chat.send/chat.abort/skills.status/skills.update`。
- 通过标准：成功率 >= 99%，错误码可分类，超时可控。

### 门禁 B：流式事件可靠性
- 验证方法：模拟 50 次连续发送，观察 delta/final 顺序、断流重连、重复消息率。
- 通过标准：不出现“final 丢失导致卡死发送态”，重复消息可去重。

### 门禁 C：Skills 安全边界
- 验证方法：识别所有技能管理动作的执行权限与副作用，分类为“可直接暴露/需二次确认/禁止暴露”。
- 通过标准：高风险操作必须二次确认并可审计。

### 门禁 D：配置一致性
- 验证方法：模型/提供商/渠道改动后回读 `openclaw.json` 对比预期结构。
- 通过标准：字段映射与当前规格一致，不出现跨面板副作用写入。

### 门禁 E：Windows 与 Linux 一致性
- 验证方法：在 Linux 目标环境复跑 0.2~0.4 的关键探测与核心用户流程。
- 通过标准：关键接口成功率、主要返回结构、关键页面行为与 Windows 开发环境一致或差异可解释且有补偿方案。

## 风险与缓解
| 风险 | 缓解措施 |
|------|----------|
| Chat 流式状态机复杂，易出现重复/漏消息 | 引入 runId + sessionKey 幂等键，落地状态机测试用例 |
| Skills 接口在不同版本 OpenClaw 行为不一致 | 先做版本探测与能力降级，接口不可用时隐藏入口 |
| 新增接口影响现有设置页稳定性 | 严格隔离路由与 payload，禁止在 model 保存时顺带写 channel 字段 |
| 文档与实现偏离 | 每个里程碑更新任务清单与规格变更，验收后再合并主规格 |
| Windows Docker 与 Linux Docker 行为差异 | 将 Linux 回归设为发布前门禁，保留差异对照清单与修复优先级 |

## 迁移/回滚方案
- 迁移步骤：
  1. 完成深挖门禁并产出接口能力报告。
  2. 实现后端 Gateway 适配层与聚合服务。
  3. 实现前端 Dashboard/Skills/Chat 能力模块。
  4. 回归模型/渠道/更新/日志既有流程。
  5. 开启默认入口并发布。
- 回滚步骤：
  1. 关闭新增页面入口与相关 API 路由。
  2. 恢复到上一稳定 commit。
  3. 保留文档与问题记录，进入下一轮修复。
- 验证方式：
  - 自动化：`npm run test`、新增 chat/skills/dash 相关单测。
  - 手工：按“应用流程文档”逐条回放关键路径。
  - 运行态：Docker 重启后配置与会话行为保持一致。
</file>

<file path="plan/2026-02-16_ClawX源码调研/任务清单.md">
# 任务清单

## 0. 文档与门禁阶段（先做，不跳步）
- [x] 0.1 完成迁移提案、技术设计、任务清单、规格变更落盘 | 验收：`plan/2026-02-16_ClawX源码调研/` 文档齐全
- [x] 0.2 深挖 Gateway RPC 能力矩阵 | 验收：形成可用接口清单（含超时/错误行为）
- [x] 0.3 深挖 Chat 流式事件链路（delta/final/error/aborted） | 验收：形成状态机时序图与异常策略
- [x] 0.4 深挖 Skills 管理边界与权限模型 | 验收：形成“可暴露/需确认/禁止暴露”分类表
- [x] 0.5 深挖 Docker 运行态的稳定性基线（重启、断网、升级后） | 验收：形成稳定性检查报告
- [x] 0.6 建立 Win 开发环境到 Linux 生产环境的一致性门禁清单 | 验收：每个阶段均有 Linux 可用性验证项
- [x] 0.7 建立单公网 IP + 端口映射部署约束清单 | 验收：对外地址/端口配置化、容器内通信策略、Webhook 地址规则全部落盘
- [x] 0.8 完成 ClawX 用户视角功能差异矩阵 | 验收：形成“已对齐/缺失/优先级”清单并落盘

## 1. 后端基础改造阶段（先打地基）
- [x] 1.1 新增 Gateway 适配层模块（统一 RPC 调用、超时、错误归一化） | 验收：接口单测通过，支持统一日志
- [x] 1.2 新增 Dashboard 聚合服务层 | 验收：输出模型/渠道/技能/运行态汇总结构
- [x] 1.3 新增 Skills 服务层 | 验收：支持查询技能状态、启停技能、读取关键配置
- [x] 1.4 新增 Chat 服务层（会话、历史、发送、中止） | 验收：支持会话切换与消息收发
- [x] 1.4.1 前端接入“状态总览 / Skills 管理 / 对话控制台”页面与路由 | 验收：`/status-overview`、`/skills`、`/chat-console` 返回 200 且侧栏可见
- [x] 1.4.2 前端接入 Dashboard/Skills/Chat API 最小可用交互 | 验收：可刷新聚合状态、可启停 Skill、可按会话发送/中止/重置
- [x] 1.5 新增 Chat 流式输出通道（SSE 优先） | 验收：`/api/chat/stream` 连续发送可收到 `delta/final` 且终态可收敛
- [x] 1.6 新增“会话新建”后端接口与会话 key 生成策略 | 验收：前端可无命令行新建会话并立即发送消息

## 2. 仪表盘增强阶段
- [x] 2.1 补齐状态总览卡片（运行状态、模型、渠道、技能、错误摘要、版本） | 验收：字段与后端一致
- [x] 2.2 增加模型快速切换入口（保持上下文风险提示） | 验收：上下文降级时提示准确
- [x] 2.3 增加系统状态模块迁移（从侧栏迁移到仪表盘） | 验收：侧栏不再重复显示同类信息
- [x] 2.4 仪表盘 UI 组件化改造（Shoelace 试点） | 验收：仅改仪表盘、功能事件不变、Docker 重建后可见
- [x] 2.5 仪表盘模型切换下拉与配置文件对齐 | 验收：仅显示当前配置中已存在模型，选项格式为“模型ID（提供商）”

## 3. 模型与提供商页增强阶段
- [x] 3.1 保持“设置当前默认模型”和“新增提供商”双通道结构 | 验收：两条路径可独立完成配置
- [x] 3.2 强化基础模板与自定义模式切换 | 验收：模板下仅需填 provider/baseUrl/key 即可
- [x] 3.3 对齐默认模型列表与配置生成器模型 ID | 验收：下拉列表一致，保存后配置正确
- [x] 3.4 新增 API 模式下拉与模型联动（GPT/Claude/Gemini） | 验收：URL/API 模式自动切换且可覆写

## 4. 渠道管理阶段
- [x] 4.1 明确并落地“只管理 OpenClaw 真实渠道” | 验收：文档与页面一致，不出现私有虚拟渠道
- [x] 4.2 优化 Telegram/飞书的可视化配置和连通性测试 | 验收：配置保存+测试闭环可复现
- [x] 4.3 兼容 Discord/Slack 的状态展示（若接口可用） | 验收：不可用时优雅降级不报错

## 5. Skills 管理阶段
- [x] 5.1 新增 Skills 列表与状态展示 | 验收：可查看启用状态、基本说明、最后更新时间
- [x] 5.2 新增 Skills 启停与必要确认交互 | 验收：高风险动作有二次确认
- [x] 5.3 新增 Skills 配置入口与回写校验 | 验收：写入失败可回滚并提示根因

## 6. Chat 主页面迁移阶段（用户主入口）
- [x] 6.1 将侧栏入口升级为“智能对话”，替换调试术语 | 验收：小白用户可在 30 秒内理解该页面用途
- [x] 6.2 实现多会话管理（列表/切换/新建） | 验收：切换后历史正确，不串会话
- [x] 6.3 实现流式消息“原位渲染”（消息气泡内增量更新） | 验收：delta 与 final 顺序稳定，消息不重复
- [x] 6.4 实现思考状态展示开关（默认开启显示） | 验收：开关仅影响显示，不影响后端请求
- [x] 6.5 实现中止当前运行（Stop）与发送态收敛 | 验收：中止后输入区恢复可编辑，按钮状态正确
- [x] 6.6 保留高级调试信息为折叠区 | 验收：默认不干扰小白，排障时可展开
- [x] 6.7 实现附件上传（点击/粘贴/拖拽）与发送链路 | 验收：附件可落盘、可随消息发送、网关可读
- [x] 6.8 实现消息富渲染与局部错误提示 | 验收：Markdown/工具消息可读，错误定位不只依赖全局时间线

## 7. 回归验证阶段
- [x] 7.1 自动化测试（单元 + 回归）补齐 | 验收：`npm run test` 通过
- [x] 7.2 手工回放关键路径 | 验收：模型、渠道、技能、日志、更新、智能对话全链路通过
- [x] 7.3 Docker 场景稳定性验证 | 验收：重启容器后配置与功能保持一致
- [ ] 7.4 Linux 生产环境回归验证 | 验收：在 Linux 主机上完成同等流程回放并记录差异

## 8. 收尾阶段
- [ ] 8.1 合并规格变更到 `plan/规格/OpenClaw面板.md` | 验收：主规格与实现一致
- [ ] 8.2 归档任务目录到 `plan/归档/` | 验收：归档目录命名与文档完整
- [ ] 8.3 更新 README 的能力说明与运维指引 | 验收：新功能入口与限制写清楚

## 未深挖项任务池（必须在对应阶段前完成）
### A. Chat 深挖
- [ ] A.1 逐项验证 Gateway 聊天协议字段（`runId/sessionKey/state/message`） | 验收：字段字典文档
- [ ] A.2 梳理异常态（超时、断流、final 缺失、重复消息） | 验收：补救策略文档

### B. Skills 深挖
- [ ] B.1 梳理 Skills 数据来源与写回路径 | 验收：接口契约文档
- [ ] B.2 梳理高风险技能动作的防误触策略 | 验收：确认弹窗+审计日志方案

### C. 运维深挖
- [ ] C.1 梳理升级后接口兼容策略 | 验收：版本差异表
- [ ] C.2 梳理日志敏感信息脱敏策略 | 验收：脱敏规则清单
- [ ] C.3 梳理 Windows Docker 与 Linux Docker 的差异清单 | 验收：差异项对应缓解策略
- [x] C.4 梳理“母机公网IP + 分配端口”部署约束对功能实现的影响清单 | 验收：端口与地址相关功能均有防错规则
- [ ] C.5 模板小鸡首启自动初始化“地址与接入配置” | 验收：用户首次登录无需手工填写公网地址/Webhook 地址，系统按模板分配端口自动回填并可校验

## 经验记录
### 步骤 0 完成记录
- 实际情况：已完成迁移方向确认，明确“插件式控制器”边界，排除首次向导/任务调度/主题系统。
- 遇到问题：ClawX 依赖 Electron，不能直接平移 IPC 与桌面更新逻辑。
- 技术债：待补全 Gateway RPC 深挖报告后，才能安全进入 Chat/Skills 编码阶段。

### 步骤 0.2 完成记录
- 实际情况：已完成 Gateway RPC 方法实测，`sessions.list/chat.history/chat.send/chat.abort/skills.status/skills.update` 全部 3/3 成功。
- 遇到问题：手写 WS 握手容易踩鉴权细节坑，已切换到 OpenClaw 官方 `callGateway()` 客户端链路作为探测基线。
- 技术债：`skills.update` 对不存在 skillKey 也返回成功，后续 UI/服务层必须补“存在性校验 + 风险提示”。
- 兼容性备注：本轮在 Windows Docker 完成，必须在 Linux 生产环境追加一致性回归。

### 步骤 0.3 完成记录
- 实际情况：已在 Linux 容器内完成 Chat 流式实测，确认 `delta -> final` 和 `aborted` 两条主链路，并输出状态机与异常策略文档。
- 遇到问题：运行态 `chat.state=error` 未能在当前环境稳定复现；已补充 `invalidRequest`（RPC 级错误）分支作为异常兜底路径。
- 技术债：后续 `1.5` 流式通道联调阶段需要继续补抓真实 `chat.state=error` 证据，避免仅依赖源码推断。
- 兼容性备注：本轮探测脚本运行在 Linux 容器（非 Windows 宿主进程）中，协议行为与生产 Linux 更一致。

### 步骤 0.4 完成记录
- 实际情况：已完成 Skills 权限与边界实测，落盘“可暴露/需确认/禁止暴露”分类表。
- 遇到问题：`skills.update` 对不存在 `skillKey` 仍返回成功，且 `skills.bins` 在 operator 角色下不可调用（unauthorized role）。
- 技术债：后续实现阶段必须补“status 列表存在性校验 + 高风险动作二次确认 + 统一错误分级”三件套。
- 兼容性备注：本轮在 Linux 容器直接验证权限行为，结论可直接用于 Linux 生产部署策略。

### 步骤 0.7 / C.4 完成记录
- 实际情况：已将“单公网 IP + 端口映射”约束落盘并落地到代码：外部端口环境变量化、仪表盘新增公网地址/Webhook 基地址展示、内部通信网络显式化。
- 遇到问题：本地当前运行态出现容器跨 compose 网络漂移（`openclawpanel_default` 与 `sub2api_default` 分离），导致内部 DNS 互通不可假设成立。
- 技术债：需在后续 Docker 稳定性基线阶段补“旧网络清理 + 强制同网络重建”回放脚本，避免历史容器残留导致误判。
- 兼容性备注：修复方案按 Linux Docker 路径设计（env + compose + panel.config.json），Windows 开发环境仅作为执行载体。

### 步骤 0.5 完成记录
- 实际情况：已完成“重启/断网/升级后”稳定性回放，输出自动化证据脚本与报告（含恢复次数与耗时）。
- 遇到问题：网关容器 `restart/upgrade` 后，`service/status` 先恢复，但容器内 DNS 链路存在滞后窗口（本次重启约 3 秒，升级回放约 10 秒）。
- 技术债：后续 `1.1/1.4/1.5` 在网关调用链必须内建 10~15 秒重试窗口与“恢复中”状态，避免把短暂恢复窗口误判为故障。
- 兼容性备注：虽然宿主是 Windows，但关键连通性结论来自 Linux 容器内探测（`openclaw-panel -> openclaw-gateway`），可用于 Linux 生产约束设计。

### 步骤 0.6 完成记录
- 实际情况：已建立“阶段门禁 + 发布前最小门禁”清单，明确 1~7 阶段对应的 Linux 验收项。
- 遇到问题：历史上存在“Windows 本地可用但 Linux 生产不可用”的隐性风险点（脚本、网络、权限、地址展示），已纳入门禁。
- 技术债：后续每个阶段执行后都要回写 Linux 验证证据；若跳过会导致门禁失效。
- 兼容性备注：门禁清单与 0.5 稳定性数据联动，已把“网关恢复窗口 10~15 秒重试”固化为默认要求。

### 步骤 1.1 完成记录
- 实际情况：已完成 `src/gateway-client.js` 适配层落地，补齐 URL 解析、重试、错误归一化、`connect.challenge` 握手、device 签名鉴权；并补齐 `test/unit/gateway-client.test.js`。
- 遇到问题：容器实时联调先后触发 `missing scope: operator.read`、`device nonce required`、`unexpected property 'nonce'` 三类握手失败；根因分别是“无 device 时 scope 被网关清空”“未识别 challenge 的 `type=event`”“把 nonce 放进了 connect 顶层字段而非 device 字段”。
- 技术债：后续 `1.4/1.5` 仍需补“网关短时恢复窗口（10~15 秒）”的统一调用重试状态透出，避免 UI 报假故障。
- 兼容性备注：本轮验证覆盖 Linux 容器内真实调用（`openclaw-panel -> openclaw-gateway`），满足 Win 开发 / Linux 运行一致性门禁。

### 步骤 1.2 完成记录
- 实际情况：已新增 `src/dashboard-service.js`，将“模型摘要 + 渠道配置/运行态 + Skills 摘要 + 服务运行态”统一聚合，并在 `src/server.js` 暴露 `GET /api/dashboard/summary`。
- 遇到问题：容器重建后立即请求接口会出现短时 404（路由尚未完成热切换）；等待容器稳定后恢复 200。
- 技术债：前端当前仍主要走 `/api/settings + /api/service/status` 双路读取，后续可在仪表盘增强阶段逐步切到聚合接口，减少前端拼装复杂度。
- 兼容性备注：已完成宿主机与容器内双路径验证（`http://127.0.0.1:18080/api/dashboard/summary` + 容器内 `fetch`），满足 Linux 运行态可用性要求。

### 步骤 1.3 完成记录
- 实际情况：已新增 `src/skills-service.js`，落地 Skills 状态查询、单技能配置读取、启停能力，并在 `src/server.js` 暴露：
  - `GET /api/skills/status`
  - `GET /api/skills/:skillKey/config`
  - `POST /api/skills/:skillKey/enabled`
- 遇到问题：Gateway 原生 `skills.update` 对不存在 skillKey 也可能返回成功，存在误操作风险。
- 技术债：后续 `5.3` 需要追加“API Key/env 编辑回写 + 失败回滚 + 审计日志”完整链路；本轮先完成启停与关键配置读取。
- 兼容性备注：已做无副作用联调（未知 skillKey 启停返回明确错误），并落证据 `evidence/skills-service-live.json`。

### 步骤 1.4 完成记录
- 实际情况：已新增 `src/chat-service.js`，实现会话列表、历史读取、消息发送、中止运行、会话重置；并在 `src/server.js` 暴露：
  - `GET /api/chat/sessions`
  - `GET /api/chat/history`
  - `POST /api/chat/send`
  - `POST /api/chat/abort`
  - `POST /api/chat/session/reset`
- 遇到问题：容器重建后短窗口内会命中旧实例路由，导致新接口短时 404；增加“接口可用性轮询”后验证稳定。
- 技术债：当前 `chat.send` 仅返回 ack（`runId/status=started`），流式增量输出与状态广播留到 `1.5` 统一实现。
- 兼容性备注：已在 Docker 运行态完成真实联调（会话/历史/发送/中止/重置全链路），证据见 `evidence/chat-service-live.json`。

### 步骤 1.4.1 / 1.4.2 完成记录
- 实际情况：已在前端新增侧栏入口与页面面板：`状态总览`、`Skills 管理`、`对话控制台`；并完成 API 绑定：
  - 状态总览：`GET /api/dashboard/summary`
  - Skills：`GET /api/skills/status`、`GET /api/skills/:skillKey/config`、`POST /api/skills/:skillKey/enabled`
  - 对话控制台：`GET /api/chat/sessions`、`GET /api/chat/history`、`POST /api/chat/send`、`POST /api/chat/abort`、`POST /api/chat/session/reset`
- 遇到问题：本地存在历史同名容器（`openclaw-panel` / `openclaw-gateway`）导致 `docker compose up` 冲突，已先清理旧容器再重建。
- 技术债：当前对话控制台仍为“控制层最小实现”，流式增量展示与更细粒度思考态展示留在 `1.5`。
- 兼容性备注：已在 Docker 运行态验证路由与 API 可达（`/status-overview`、`/skills`、`/chat-console` 均返回 200）。

### 步骤 1.5 完成记录
- 实际情况：已新增 `GET /api/chat/stream`（SSE）并接入 Gateway 事件订阅桥；前端 `对话控制台` 已接入实时流展示（`ready/status/chat/agent/terminal/stream-error`）。
- 遇到问题：网关短时断链会导致流中断；已在服务端加入自动重连状态机（`reconnecting/connect-failed/gateway-closed`）并持续输出状态事件。
- 技术债：当前流展示以事件日志和增量文本为主，后续 `6.3/6.4` 可继续做 UI 级“消息气泡内原位增量渲染 + 思考状态分层”。
- 兼容性备注：已完成 Docker 运行态实测，证据见 `evidence/chat-stream-sse-live.json`（终态 `final`，包含 `delta` 事件）。

### 步骤 0.8 完成记录
- 实际情况：已完成 ClawX 用户视角能力盘点，形成“已对齐/缺失/优先级”矩阵报告，确认下一优先级为 Chat 主页面用户化。
- 遇到问题：当前面板 Chat 交互偏调试控制台风格，不符合小白用户操作路径。
- 技术债：仍需补“新建会话”接口与前端聊天消息气泡化渲染，避免继续暴露原始事件流。
- 兼容性备注：本轮仅文档与差异分析，无环境依赖差异风险。

### 步骤 1.6 完成记录
- 实际情况：已新增 `POST /api/chat/session/new`，后端自动按现有会话前缀生成新 `sessionKey` 并调用 `sessions.reset(reason=new)` 创建会话。
- 遇到问题：不同环境的会话 key 前缀可能不一致；已通过“优先复用现有 canonical 前缀，失败回退 `agent:main`”规避。
- 技术债：后续可增加“按用户输入前缀创建会话”能力，目前前端默认自动生成。
- 兼容性备注：已在 Docker 运行态实测通过，证据见 `evidence/chat-session-new-live.json`。

### 步骤 6.1~6.7 完成记录
- 实际情况：`/chat-console` 已从“对话控制台”升级为“智能对话”主聊天页，默认视图包含会话选择、消息区、输入区、停止回复与思考显示开关；高级原始事件信息迁移到折叠区。
- 遇到问题：历史实现依赖原始 SSE 文本输出，直接替换会导致定位问题困难；已保留原始历史/流事件面板作为折叠调试区。
- 技术债：该阶段遗留的“消息富渲染 + 局部错误提示”已在后续 `6.8` 闭环，本条仅保留历史上下文。
- 兼容性备注：已在 Docker 重建后完成“附件落盘 -> 路径映射 -> 真实发送回放”验证，证据见 `evidence/chat-user-workspace-live.md`、`evidence/chat-attachments-live.json`、`evidence/chat-attachments-pathmap-live.json`。

### 步骤 6.8 完成记录
- 实际情况：已完成消息富渲染（`**加粗**`、行内代码、代码块）和工具消息可读化（`[工具调用]` / `[工具结果]`）；并在聊天页新增内联提示区，覆盖发送、刷新、新建会话、停止、重置、附件处理等动作反馈。
- 遇到问题：历史数据中工具事件字段命名不统一（`toolCall/tool_call/toolResult/tool_result`），导致首版渲染漏识别；已在归一化阶段统一兼容。
- 技术债：当前富渲染为轻量 Markdown 子集，后续如需完整 Markdown 语法（表格/引用/任务列表）再评估引入专用渲染器。
- 兼容性备注：已完成 Docker 重建与运行态验证，证据见 `evidence/chat-rich-render-inlinehint-live.md`。

### 步骤 2.1 完成记录
- 实际情况：已在仪表盘补齐总览卡片（运行状态、当前模型、渠道、Skills、错误摘要、版本状态），并迁入“渠道运行态 / Skills 运行态”明细列表与快捷操作入口，用户可从一个页面直达核心操作。
- 遇到问题：版本与错误摘要数据来自不同接口（`/api/update/check`、`/api/logs/errors`），刷新链路容易出现“部分成功”；已在仪表盘刷新按钮中增加并发结果汇总和失败提示。
- 技术债：该阶段发现的“状态页重复入口”问题已在后续 `2.3` 完成收敛，本条仅保留历史上下文。
- 兼容性备注：已完成 Docker 重建和运行态验证，证据见 `evidence/dashboard-overview-enhanced-live.md`。

### 步骤 2.3 完成记录
- 实际情况：已移除侧栏“状态总览”入口与独立页面结构，状态信息统一收敛到“仪表盘”；`/status-overview` 旧路径保留兼容映射，访问后自动落到仪表盘视图。
- 遇到问题：直接删除路由会导致历史收藏链接不可用；已在 `panelByPath` 中增加路径别名映射，避免用户打开旧链接看到空页面。
- 技术债：该阶段遗留的“仪表盘模型快速切换”已在后续 `2.2` 完成，本条仅保留历史上下文。
- 兼容性备注：已在 Docker 运行态验证侧栏与旧路径行为，证据见 `evidence/dashboard-status-migration-live.md`。

### 步骤 2.2 完成记录
- 实际情况：已在仪表盘“模型仪表盘”中新增快速切换入口（上下文输入 + 模型下拉 + 一键切换），无需跳转到“模型与提供商配置”页面即可切换默认模型。
- 遇到问题：仪表盘和模型页都需要“当前会话上下文”输入，若独立维护会出现提示不一致；已改为共享同一 `localStorage` 键并双向同步两个输入框。
- 技术债：当前下拉只展示模型名称，后续可增加“提供商徽标/标签”帮助用户在重名模型场景下更快识别。
- 兼容性备注：已在 Docker 运行态验证“降级上下文提示”触发准确，证据见 `evidence/dashboard-quick-model-switch-live.md`。

### 步骤 3.1 完成记录
- 实际情况：已把模型页明确拆成“双通道”交互，新增提供商（模板/自定义）默认不再改动当前默认模型，仅在用户显式勾选“保存后设为当前默认模型”时才切换。
- 遇到问题：后端 `applySettings()` 会总是写入 `agents.defaults.model.primary`，若前端每次都传“新提供商默认模型 ref”，就会出现“加提供商顺手改默认模型”的隐性副作用；已改为前端根据勾选状态决定传“当前 primary”或“目标 primary”。
- 技术债：3.2/3.4 仍需继续增强“模板/自定义切换 + API 模式联动”的表单引导，降低小白用户填错概率。
- 兼容性备注：已完成 `node --check`、`npm run test:unit`、`npm run test:regression` 以及 `docker compose up -d --build panel` 验证，证据见 `evidence/model-provider-dual-path-3.1-live.md`。

### 步骤 3.2 完成记录
- 实际情况：已新增“路径 2 工作模式”切换入口，默认进入“基础配置（推荐）”；模板模式主区只保留 `provider/baseUrl/apiKey` 等高频字段，低频字段迁入“高级参数（通常不用改）”折叠区；自定义模式默认隐藏，按需切换展示。
- 遇到问题：模板与自定义表单字段共存时，用户容易误把“高级字段”当成必填；已改为模式显式切换 + 折叠高级项，降低认知负担。
- 技术债：`3.3/3.4` 仍需继续细化模型 ID 一致性和 API 模式联动，避免跨模式切换时出现“看起来像一致、实际不一致”的错觉。
- 兼容性备注：已完成 `node --check`、`npm run test:unit`、`npm run test:regression` 与 Docker 重建验证，证据见 `evidence/model-provider-mode-switch-3.2-live.md`。

### 步骤 3.3 完成记录
- 实际情况：已把配置生成器与模板高级参数的模型下拉统一为同源渲染（`DEFAULT_MODEL_OPTIONS`），并移除 `cfg_model_id` 的静态硬编码，避免后续模型更新时出现列表漂移。
- 遇到问题：原实现在 HTML 与 JS 双处维护模型 ID，后续一旦漏改会导致“某页面有模型，另一页面没有”的隐性不一致；已收敛为 `fillDefaultModelOptions()` 单点生成。
- 技术债：`3.4` 仍需补完“模型族 -> API 模式/URL”的联动细则，保证不同模型切换时提供商参数变化可解释。
- 兼容性备注：已完成 DevTools 运行态一致性校验（`cfg_model_id` 与 `template_default_model_id` 一致）及自动化/容器验证，证据见 `evidence/model-id-alignment-3.3-live.md`。

### 步骤 3.4 完成记录
- 实际情况：已在“自定义模式”补齐 API 模式下拉（含 custom）与默认模型下拉（含 custom），并落地 AICodeCat 场景下的联动：模型族切换会同步切换 API 模式、providerId 与 Base URL。
- 遇到问题：自定义模式原本依赖手输 API 模式与默认模型 ID，模型切换后 URL 不会跟随，容易配置错路径；已通过 `syncCustomByModelSelection/syncCustomByApiMode` 消除这类误填。
- 技术债：后续可进一步补“跨非 AICodeCat 提供商的联动策略提示”，避免用户误以为所有提供商都支持自动 URL 推导。
- 兼容性备注：已完成 DevTools 运行态联动验证（Claude/GPT/Gemini 三条链路）以及自动化/容器验证，证据见 `evidence/model-api-linkage-3.4-live.md`。

### 步骤 4.1 完成记录
- 实际情况：已将渠道页显式标注为“仅 OpenClaw 真实渠道”，并在页面文案中写明只会写入 `channels.telegram/feishu/discord/slack`（含飞书兼容 `accounts.main`），不会创建面板私有虚拟渠道。
- 遇到问题：原有文案容易让用户把“保存渠道与全局配置”误解为会改动更多全局行为；已把按钮与成功提示改成“渠道配置”语义并注明“模型保持当前值”。
- 技术债：`4.2` 仍需继续补 Telegram/飞书连通性测试的可回放闭环（成功/失败路径都可快速复现）。
- 兼容性备注：已完成页面关键文案命中检查 + 自动化测试 + Docker 重建验证，证据见 `evidence/channel-scope-4.1-live.md`。

### 步骤 4.2 完成记录
- 实际情况：已新增 Telegram/Feishu 的“保存并测试”一键动作，并新增最近测试结果区（时间 + 成功/失败 + 详情），实现页面内闭环。
- 遇到问题：原链路里“保存配置”会触发配置重载并脱敏清空凭证输入，导致后续测试拿到空值；已修复为“保存前缓存凭证 -> 保存后回填 -> 再测试”。
- 技术债：`4.3` 仍需补 Discord/Slack 的状态展示与降级提示统一化，避免“某渠道失败影响整页认知”。
- 兼容性备注：已通过 DevTools mock 验证两条闭环请求链路（PUT settings -> POST test），并完成自动化与 Docker 验证，证据见 `evidence/channel-save-test-loop-4.2-live.md`。

### 步骤 4.3 完成记录
- 实际情况：已为 Discord/Slack 增加独立“最近测试”状态区，并补齐输入前置校验（Discord Token、Slack 按模式的必填项），测试结果在通道卡片内直接可见。
- 遇到问题：接口异常时原实现只在全局时间线报错，用户难以定位到具体通道；已改为在当前通道结果区同步显示“接口不可用或测试失败”。
- 技术债：后续可考虑补“通道测试历史记录（最近 N 次）”以便跨时段追踪不稳定问题。
- 兼容性备注：已通过 DevTools 验证“缺参失败 + 接口异常降级”两条路径，并完成自动化与 Docker 验证，证据见 `evidence/channel-discord-slack-4.3-live.md`。

### 步骤 5.1 完成记录
- 实际情况：Skills 列表已新增“说明 + 最近更新时间”展示；服务层支持更新时间字段多格式归一化，前端缺失值回退为“无”。
- 遇到问题：网关返回的更新时间字段命名并不稳定；已兼容 `updatedAt/updated_at/lastUpdatedAt/last_updated_at/mtime` 多种命名。
- 技术债：`5.2` 仍需补高风险技能启停二次确认与明确风险文案，防止误触。
- 兼容性备注：已完成 `/skills` 运行态快照验证、单测断言补强、自动化与 Docker 验证，证据见 `evidence/skills-list-status-5.1-live.md`。

### 步骤 5.2 完成记录
- 实际情况：Skills 启停已加入高风险二次确认，禁用已启用技能必须确认；对“受限技能启用”也会提示后再继续。
- 遇到问题：原交互中取消动作没有显式反馈，用户会怀疑是否已提交；已补“已取消 Skill 操作”时间线提示。
- 技术债：`5.3` 仍需补 Skills 配置写回失败时的回滚与根因提示，形成完整闭环。
- 兼容性备注：已通过 DevTools 验证“确认弹窗出现 + 取消后不发请求”链路，并完成自动化与 Docker 验证，证据见 `evidence/skills-toggle-confirm-5.2-live.md`。

### 步骤 5.3 完成记录
- 实际情况：已在 Skills 页新增“配置写回”入口，支持写回 `enabled/apiKey/env`，并新增后端 `PUT /api/skills/:skillKey/config`。
- 遇到问题：仅写盘不做校验会有静默坏配置风险；已落地“写后回读校验 + 失败自动回滚（备份恢复）”闭环。
- 技术债：后续可补“字段级审计日志（谁在何时改了哪些键）”以提升运维可追溯性。
- 兼容性备注：已完成自动化测试、Docker 重建和容器运行态 API 回放；证据见 `evidence/skills-config-writeback-5.3-live.md`。

### 步骤 7.1 完成记录
- 实际情况：已完成语法检查 + 单测 + 回归测试 + 聚合测试命令收口，`npm run test` 全量通过。
- 遇到问题：回归集中有 1 条既有 skip 用例（镜像拉取失败路径），不影响本轮功能有效性结论。
- 技术债：仍需继续推进 `7.2/7.3/7.4` 手工与 Linux 场景回放，自动化通过不等于交付完成。
- 兼容性备注：本轮在 Windows Docker 环境执行，通过结果已落盘；后续 Linux 复验仍按门禁执行。

### 步骤 7.2 完成记录
- 实际情况：已完成模型/渠道/Skills/日志/更新/智能对话全链路接口回放，关键请求均返回成功结果。
- 遇到问题：`chat.abort` 在 run 已结束时会返回 `aborted=false`，属于网关状态时序特性，不是失败。
- 技术债：渠道连通性（Telegram/Feishu 真正发消息）仍需在具备生产凭据的 Linux 环境做补测。
- 兼容性备注：本轮在 Windows Docker 回放并落证据，后续 `7.4` 继续在 Linux 环境复验。

### 步骤 7.3 完成记录
- 实际情况：已完成 `panel` 容器重启回放，重启后健康恢复、配置字段一致、Dashboard/Chat/Logs smoke 全部通过。
- 遇到问题：无阻断问题；重启窗口内存在短暂不可达属于预期。
- 技术债：仍需在 Linux 生产宿主执行同流程复验，排除宿主级网络/权限差异。
- 兼容性备注：本轮验证运行在 Windows Docker，结果已落盘，下一步执行 `7.4` Linux 生产复验。

### 步骤 2.4 完成记录
- 实际情况：已完成仪表盘页面的 Shoelace 试点改造（KPI 卡片、状态标签、刷新按钮、运行态项卡片化），且保持原有 DOM ID 与事件绑定不变，现有切换模型/刷新总览/快捷跳转逻辑均可继续使用。
- 遇到问题：后端首次接入 Shoelace 静态资源时 `@fastify/static` 二次注册触发 `sendFile` 装饰器冲突；已通过第二个 static 注册增加 `decorateReply: false` 修复。
- 技术债：当前仅仪表盘做组件化试点，其它页面仍是原生样式体系；后续如继续推进需制定“组件化迁移边界清单”，避免跨页样式漂移。
- 兼容性备注：已执行 `npm test` 全量通过，并完成 `docker compose up -d --build panel` 重建；运行态校验 `GET /api/health` 与 `GET /shoelace/themes/light.css` 均为 200。

### 步骤 2.5 完成记录
- 实际情况：已将仪表盘“切换 AI 模型”下拉来源改为 `settings.model.catalog.modelRefs`，移除对配置生成器默认模型列表的依赖，避免展示未配置模型。
- 遇到问题：原逻辑通过 `readGeneratorDefaultModelRefs()` 引入模板默认项，导致用户可选到配置文件里不存在的模型并触发网关报错。
- 技术债：后续可补“切换前预检（当前 provider 是否具备对应模型）”的显式提示，进一步降低误操作成本。
- 兼容性备注：已完成 `npm test` 和 Docker 重建验证，变更仅影响前端下拉来源与显示文案，不涉及后端配置写入契约。

### 结构治理补充记录（2026-02-17）
- 实际情况：已新增并执行 `plan/2026-02-17_配置核心与前端主脚本拆分/`，完成 `src/openclaw-config.js` 与 `public/app.js` 的模块化拆分，并保留对外行为兼容。
- 遇到问题：前端拆分初版在 Dashboard 出现 `toNonNegativeInt` 缺失的运行时错误；已补导入并通过浏览器控制台复验。
- 技术债：`system-page.js` 仍可继续细拆为“渠道/更新/服务/日志”四个子模块，但本轮已达到稳定可维护边界。
- 兼容性备注：已完成自动化测试、Docker 重建、关键页面可达性探针、浏览器控制台校验和 Linux 容器内 API 回放。
</file>

<file path="plan/2026-02-16_ClawX源码调研/深挖报告_0.2_GatewayRPC能力矩阵.md">
# 深挖报告 0.2：Gateway RPC 能力矩阵

创建时间：2026-02-16 13:25:00（UTC）

## 目标
- 验证当前 Docker 运行态下，后续迁移必须依赖的 Gateway RPC 方法是否真实可用。
- 输出方法可用性、延迟、返回结构、风险点，作为后续 0.3/0.4 的输入。

## 测试环境
- 开发环境：Windows 主机 + Docker 容器
- 目标运行：Linux 服务器（预装交付）
- 被测容器：
  - `openclaw-gateway`（`ghcr.io/openclaw/openclaw:2026.2.14`）
  - `openclaw-panel`（本项目）
- 网关地址：`ws://127.0.0.1:18789/ws`
- 鉴权方式：复用 OpenClaw 内置 `callGateway()` 客户端（与官方 CLI 一致链路）

## 方法与数据
- 每个方法执行 3 次，共 18 次调用。
- 会话使用隔离键：`agent:main:panel-probe-<timestamp>`，避免污染常规会话。
- 调用方法：
  - `sessions.list`
  - `chat.history`
  - `chat.send`
  - `chat.abort`
  - `skills.status`
  - `skills.update`

## 实测结果（摘要）
| 方法 | 成功率 | P95 延迟(ms) | 支持结论 | 备注 |
|------|------|-------------|---------|------|
| sessions.list | 100% (3/3) | 84 | 支持 | 返回 defaults + sessions |
| chat.history | 100% (3/3) | 63 | 支持 | 空会话返回稳定 |
| chat.send | 100% (3/3) | 82 | 支持 | 返回 `runId` + `status=started` |
| chat.abort | 100% (3/3) | 170 | 支持 | 可中止 probe run |
| skills.status | 100% (3/3) | 172 | 支持 | 返回技能清单（49项） |
| skills.update | 100% (3/3) | 138 | 支持 | 对不存在 skillKey 仍返回 `ok=true` |

## 关键观察
1. `chat.*` 与 `sessions.*`链路稳定，满足“多会话 + 流式前置能力”的接口门槛。
2. `skills.status`稳定可用，可作为 Skills 面板数据源。
3. `skills.update` 对不存在 `skillKey` 也返回成功，说明该接口更像“配置写入”而非“严格存在性校验”。
4. 风险：若前端不做技能存在性校验，可能出现“用户以为启停成功但目标技能不存在”的假成功体验。

## 设计影响
- `skills.update` 在控制台侧必须先校验 `skillKey` 是否存在于 `skills.status` 结果，再允许提交。
- `chat.send` 后必须跟踪 `runId`，并将 `abort` 与当前会话运行态关联，防止误中止。
- 会话页实现时需保留 `sessionKey` 作为主键，不得用展示名称替代。

## 结论
- 任务 `0.2 深挖 Gateway RPC 能力矩阵` 通过。
- 后续 0.3（流式状态机）和 0.4（Skills 权限/边界）可以进入执行。

## 证据
- 原始证据文件：`plan/2026-02-16_ClawX源码调研/evidence/gateway-rpc-matrix-live.json`

## Linux 兼容性说明（本轮）
- 本轮调用链使用 OpenClaw 官方 `callGateway()` 客户端，运行逻辑与 Linux 生产一致（同一网关协议和鉴权栈）。
- 但当前证据采集发生在 Windows 上的 Docker 容器中，下一步（0.5）必须在 Linux 场景补做同类稳定性验证并形成对照记录。
</file>

<file path="plan/2026-02-16_ClawX源码调研/深挖报告_0.3_Chat流式事件链路.md">
# 深挖报告 0.3：Chat 流式事件链路（delta/final/error/aborted）

创建时间：2026-02-16 13:40:00（UTC）

## 目标
- 在真实运行态验证 Chat 流式状态链路，明确前端状态机应如何驱动。
- 覆盖正常完成、中止、请求异常，以及运行时错误尝试路径。
- 为后续 `1.4/1.5`（Chat 服务层 + SSE）提供可执行的状态策略。

## 测试环境
- 执行环境：`openclaw-gateway` 容器内（Linux）
- 网关地址：`ws://127.0.0.1:18789/ws`
- 客户端身份：`clientName=cli`、`mode=cli`（通过 Gateway 校验）
- 证据脚本：
  - `plan/2026-02-16_ClawX源码调研/evidence/chat-stream-event-probe-live.mjs`
- 原始证据：
  - `plan/2026-02-16_ClawX源码调研/evidence/chat-stream-event-probe-live.json`

## 实测场景与结果

| 场景 | 触发动作 | 终态 | 关键观察 |
|------|---------|------|---------|
| normal | `chat.send` 正常发送 | `final` | 出现稳定 `delta -> final` 链路（本次 15 个 delta） |
| abort | `chat.send` 后调用 `chat.abort` | `aborted` | 终态为 `aborted`，且 `stopReason=rpc` |
| invalidRequest | 故意缺失 `message` 字段调用 `chat.send` | RPC error | 请求直接失败，未产生 run 级流式事件 |
| forcedRuntimeErrorAttempt | `sessions.patch` 设置 `model=__panel_invalid_model__` 后 `chat.send` | `final` | 仍走 `delta -> final`，本次未复现 `chat.state=error` |

补充指标（来自证据 JSON）：
- RPC 调用总数：6
- RPC 失败数：1（`chat.send` 参数校验失败）
- normal run：`seq 2 -> 129`
- abort run：`seq 2`（单个 `aborted` 事件）

## 状态机结论（面板侧建议）

```mermaid
stateDiagram-v2
  [*] --> idle
  idle --> sending: chat.send(ack started)
  idle --> request_error: chat.send invalid params / rpc fail
  sending --> streaming: chat.state=delta
  streaming --> streaming: chat.state=delta
  sending --> completed: chat.state=final
  streaming --> completed: chat.state=final
  sending --> aborted: chat.state=aborted
  streaming --> aborted: chat.state=aborted
  sending --> failed: chat.state=error
  streaming --> failed: chat.state=error
  request_error --> idle
  completed --> idle
  aborted --> idle
  failed --> idle
```

## 关键实现证据（源码对照）
- `chat.send`：先返回 `started`，后异步广播 Chat 事件（`chat.ts`）。
- `chat.abort`：广播 `state=aborted` 且携带 `stopReason`（`chat-abort.ts`）。
- `chat.state=error`：存在代码路径（`broadcastChatError`），但本轮未在实测中触发。
  - 参考文件：
    - `third_party/openclaw/src/gateway/server-methods/chat.ts`
    - `third_party/openclaw/src/gateway/chat-abort.ts`
    - `third_party/openclaw/src/gateway/server-chat.ts`

## 异常策略（用于后续面板实现）
1. 请求级错误（`chat.send` RPC 失败）：
   - 不进入流式态，直接在当前输入回合显示错误提示；
   - 不生成运行中占位消息，避免“假运行”。
2. 运行级中止（`aborted`）：
   - 立即解除输入锁；
   - 对该 run 标记“已中止”，不等待 `final`。
3. 运行级错误（`chat.state=error`）：
   - 视为终态，和 `aborted` 一样释放发送锁；
   - 保留错误文案用于“重试”。
4. 终态收敛：
   - 任意 run 在 `final/error/aborted` 后都应从运行中集合移除，避免脏状态。

## Linux 兼容性结论（本轮）
- 本轮探测直接在 Linux 容器内完成，网关协议和握手路径与生产 Linux 一致。
- 结论可直接作为 Linux 生产部署的状态机输入，不依赖 Windows 宿主差异。
- 仍需在后续 `7.4 Linux 生产回归` 做整页 UI 联动回放（本轮是协议层验证）。

## 结论
- `0.3` 达成：已形成可执行状态机和异常策略。
- 当前可确定的终态链路：
  - 正常：`delta -> final`
  - 中止：`aborted`
  - 请求异常：RPC error（不进入 run 流）
- `chat.state=error` 已确认存在源码路径，但本轮运行态未复现；后续在 `1.5` 联调阶段继续观察并补证据。
</file>

<file path="plan/2026-02-16_ClawX源码调研/深挖报告_0.4_Skills管理边界与权限模型.md">
# 深挖报告 0.4：Skills 管理边界与权限模型

创建时间：2026-02-16 13:45:00（UTC）

## 目标
- 明确 Skills 相关 Gateway 方法的权限门槛与行为边界。
- 给出面板侧“可暴露 / 需确认 / 禁止暴露”分类表。
- 避免“假成功”“高风险安装误触”“越权调用”进入正式功能。

## 测试环境
- 执行环境：`openclaw-gateway` 容器内（Linux）
- 网关地址：`ws://127.0.0.1:18789/ws`
- 客户端身份：`clientName=cli`、`mode=cli`（operator 角色）
- 证据脚本：
  - `plan/2026-02-16_ClawX源码调研/evidence/skills-boundary-probe-live.mjs`
- 原始证据：
  - `plan/2026-02-16_ClawX源码调研/evidence/skills-boundary-live.json`

## 代码层结论（权限与行为）

1. 方法权限门槛（网关鉴权）
- `skills.status`：读权限方法（`operator.read / operator.write / operator.admin` 之一可用）。
- `skills.update`：管理员权限方法（无 admin 直接拒绝）。
- `skills.install`：管理员权限方法（无 admin 直接拒绝）。
- `skills.bins`：被归类为 **node-role-only**（operator 角色会收到 `unauthorized role`）。

参考：
- `third_party/openclaw/src/gateway/server-methods.ts`
- `third_party/openclaw/src/gateway/server-methods/skills.ts`

2. 关键行为边界
- `skills.update` 不校验 `skillKey` 是否存在于 `skills.status` 列表，允许写入任意 key 到配置。
- `skills.install` 会触发外部安装流程（`brew/npm/pnpm/yarn/bun/go/uv/download`），属于高风险动作。
- `skills.status` 返回的是“可识别技能清单”，配置中孤立 key（如 probe key）不会出现在列表中。

参考：
- `third_party/openclaw/src/gateway/server-methods/skills.ts`
- `third_party/openclaw/src/agents/skills-install.ts`
- `third_party/openclaw/src/agents/skills-status.ts`

## 实测结果摘要

| 检查项 | 结果 | 结论 |
|------|------|------|
| `skills.status` | 成功，返回 49 项技能 | 可作为面板主数据源 |
| `skills.status(agentId=unknown)` | 失败，报 unknown agent | 需要前端 agentId 白名单 |
| `skills.update("__panel_probe_nonexistent_skill__")` | 成功返回 `ok=true` | 存在“假成功”风险 |
| `skills.status`（更新后） | 仍不包含 probe skillKey | 证明“配置写入成功 ≠ 技能真实存在” |
| `skills.install`（缺失技能） | 失败，返回 Skill not found | 安装流程错误反馈正常 |
| `skills.bins`（operator） | 失败，`unauthorized role: operator` | operator 控制台不应依赖该方法 |

## 分类表（面板落地）

| 分类 | 能力 | 依据 | 面板策略 |
|------|------|------|---------|
| 可暴露 | Skills 列表、状态、缺失依赖展示（基于 `skills.status`） | 读方法 + 低风险 | 直接展示 |
| 可暴露 | 对“已存在 skillKey”做启停切换（`enabled`） | 功能核心需求，但需先做存在性校验 | 允许操作，操作前校验 key |
| 需确认 | 更新 `apiKey/env` | 涉及密钥、环境变量，影响运行安全 | 二次确认 + 密钥脱敏显示 + 审计日志 |
| 需确认 | `skills.install` 安装动作 | 执行外部命令/下载，成本与安全风险高 | 强制二次确认，默认关闭入口（按策略开） |
| 禁止暴露 | 直接调用 `skills.update` 写未知 key | 会造成“假成功”并污染配置 | UI 层禁止，必须先 `skills.status` 校验 |
| 禁止暴露 | operator 角色调用 `skills.bins` | 网关角色策略拒绝 | 不在控制台中暴露此调用 |

## 对后续实现的硬约束
1. `skills.update` 前置存在性校验：
- `skillKey` 必须来自最新 `skills.status` 返回值，否则前端直接拦截。

2. 更新动作拆级：
- `enabled` 可走轻量确认；
- `apiKey/env/install` 必须走高风险确认弹窗。

3. 错误处理统一：
- 区分 `invalid request / unauthorized / unavailable` 三类；
- 严禁把网关失败映射为“保存成功”。

4. 角色边界固定：
- 控制台使用 operator 角色，不引入 node 角色能力绕过鉴权。

## Linux 兼容性结论（本轮）
- 本轮验证在 Linux 容器中直接完成，权限行为与生产 Linux 一致。
- 可直接用于面板实现阶段的权限策略，不依赖 Windows 宿主特性。

## 结论
- `0.4` 达成：已形成 Skills 权限模型与操作边界分类表。
- 下一步可进入 `0.5`（Docker 稳定性基线）继续补齐生产可运维证据。
</file>

<file path="plan/2026-02-16_ClawX源码调研/深挖报告_0.5_Docker运行态稳定性基线.md">
# 深挖报告 0.5：Docker 运行态稳定性基线（重启/断网/升级后）

创建时间：2026-02-16 14:50:00（UTC+8）

## 目标
- 验证当前 Docker 运行态在以下三类扰动后的恢复能力：
  - 网关容器重启
  - 网关网络断开后恢复
  - 升级流程执行后恢复
- 给后续 Chat/Skills（依赖容器内网 DNS）的实现提供真实恢复窗口数据。

## 测试环境
- 宿主环境：Windows + Docker Desktop
- 容器环境（Linux）：
  - `openclaw-panel`（`openclaw-panel:local`）
  - `openclaw-gateway`（`ghcr.io/openclaw/openclaw:2026.2.14`）
- 内部网络：`openclaw-internal`
- 执行脚本：`plan/2026-02-16_ClawX源码调研/evidence/docker-stability-probe-live.mjs`
- 原始证据：`plan/2026-02-16_ClawX源码调研/evidence/docker-stability-live.json`

## 测试矩阵
1. 基线探测
- `/api/health`
- `/api/service/status`
- `/api/update/check`
- `http://127.0.0.1:18789/`（网关主页）
- `docker inspect` 网关运行态
- `openclaw-panel` 容器内访问 `http://openclaw-gateway:18789/`（内部 DNS）

2. 重启恢复
- `docker restart openclaw-gateway`
- 每秒探测一次，直到全部指标恢复

3. 网络隔离恢复
- `docker network disconnect -f openclaw-internal openclaw-gateway`
- 隔离期间采样一次
- `docker network connect openclaw-internal openclaw-gateway`
- 每秒探测一次，直到全部指标恢复

4. 升级流程回放
- 调用 `POST /api/update/upgrade`（目标版本使用当前 `2026.2.14`，做无版本变化的流程回放）
- 先采样一次，再每秒探测恢复

## 结果摘要
| 项目 | 结果 | 关键数据 |
|------|------|---------|
| 基线 | 通过 | panel/gateway/内部 DNS 全部可达 |
| 重启恢复 | 通过 | 恢复成功；`3` 次探测后恢复（约 3 秒） |
| 网络隔离恢复 | 通过 | 隔离时内部 DNS 失败；重连后 `1` 次探测即恢复 |
| 升级流程回放 | 通过 | 升级 API 成功；整体恢复成功，但内部 DNS 恢复用了 `10` 次探测（约 10 秒） |

补充版本信息（来自证据）：
- 当前版本：`2026.2.14`
- 最新版本：`2026.2.15`

## 关键观察
1. `service/status` 与 `update/check` 在网关重启后很快恢复为“active=true”，但**容器内 DNS 可达性会滞后数秒**。
2. 升级流程（即使目标版本不变）会触发网关容器重建，重建后内部 DNS 可达恢复比“单纯 restart”更慢（本次约 10 秒）。
3. 网络隔离期间，外部端口映射下的网关主页仍可访问，但容器内 DNS 访问失败，符合“外部映射与内部网络是两套链路”的预期。

## 对后续实现的硬约束
1. Chat/Skills 网关调用前置健康门：
- 容器重启/升级后，前端和后端都必须允许 10~15 秒重试窗口；
- 不要把“第一次内网调用失败”直接当成永久故障。

2. 统一重试策略：
- 内部 RPC 调用建议至少 `10` 次重试，间隔 `1s`，并带用户可见状态（例如“网关正在恢复连接...”）。

3. 升级后冷却期：
- 升级动作返回成功后，仍需做一次内部连通性探测再开放 Chat/Skills 操作入口。

## 结论
- 任务 `0.5 深挖 Docker 运行态稳定性基线` 达成。
- 当前架构在“重启/断网/升级”后能恢复，但存在明确的“内部 DNS 恢复滞后窗口”。
- 可进入下一步 `0.6 Win 开发环境到 Linux 生产环境一致性门禁清单`。
</file>

<file path="plan/2026-02-16_ClawX源码调研/深挖报告_0.6_Win开发与Linux生产一致性门禁清单.md">
# 深挖报告 0.6：Win 开发与 Linux 生产一致性门禁清单

创建时间：2026-02-16 15:00:00（UTC+8）

## 目标
- 建立“Windows 开发 + Docker”到“Linux 生产 + Docker”的一致性门禁。
- 让后续每个开发阶段都有明确 Linux 可用性验证项，避免只在 Windows 上通过。

## 已知差异与风险
| 类别 | Windows 开发侧 | Linux 生产侧 | 风险 |
|------|---------------|-------------|------|
| Shell 与脚本 | 常在 PowerShell 触发，脚本主体是 bash | 直接 bash | 换行符/转义差异导致脚本失败 |
| 文件权限 | bind mount 下 `chmod 600` 语义弱 | 权限真实生效 | 配置文件权限在生产不符合最小权限 |
| Docker 网络 | 可能遗留跨 compose 网络漂移 | 通常更干净 | 容器间 DNS 偶发失败、同名容器冲突 |
| 升级恢复窗口 | 开发常忽略冷却时间 | 生产更敏感 | 网关重建后短时不可用导致业务误报 |
| 地址展示 | 容易默认 `127.0.0.1` | 需要公网 `IP:端口` | Webhook/外部访问配置错误 |

## 阶段门禁（强制）
> 规则：每完成一个阶段，必须至少执行该阶段对应的一条 Linux 验证。

### 阶段 1：后端基础改造（1.1~1.5）
- 必测项：
  1. 在 Linux 容器内执行关键接口调用（不是只在 Windows 宿主调用）
  2. Gateway 内网 DNS 可达：`openclaw-panel -> openclaw-gateway`
- 验收命令（示例）：
  - `docker exec openclaw-panel node -e "fetch('http://openclaw-gateway:18789/').then(r=>console.log(r.status))"`
  - `curl -sS -X POST http://127.0.0.1:18080/api/service/status`

### 阶段 2：仪表盘增强（2.1~2.3）
- 必测项：
  1. 仪表盘显示公网地址字段（不是固定 localhost）
  2. 公网地址未配置时显示明确提示
- 验收方式：
  - 浏览器打开 `/dashboard`，核对“面板公网访问地址 / Webhook 回调基地址”文案

### 阶段 3：模型与提供商页增强（3.1~3.4）
- 必测项：
  1. 模型切换与提供商保存后，Linux 容器内 `openclaw.json` 持久化正确
  2. 容器重启后配置不丢失
- 验收命令（示例）：
  - `docker exec openclaw-gateway sh -lc "cat /home/node/.openclaw/openclaw.json | head -n 80"`
  - `docker restart openclaw-gateway && curl -sS -X POST http://127.0.0.1:18080/api/service/status`

### 阶段 4：渠道管理（4.1~4.3）
- 必测项：
  1. 渠道配置写回后字段结构与 OpenClaw 官方字段对齐
  2. 渠道测试失败时错误可读、无崩溃
- 验收方式：
  - 页面保存 + 测试按钮回放
  - 检查 `/api/settings` 返回结构

### 阶段 5：Skills 管理（5.1~5.3）
- 必测项：
  1. `skills.status` 读取成功
  2. 不存在 skillKey 的更新被前端/服务层拦截
  3. 高风险动作有二次确认
- 验收方式：
  - Linux 容器内回放 skills RPC
  - 页面交互验证“拦截 + 提示”

### 阶段 6：Chat 能力迁移（6.1~6.5）
- 必测项：
  1. `delta/final/aborted` 状态流可稳定回放
  2. 网关重启后 10~15 秒内自动重试恢复，不误判永久故障
- 验收方式：
  - 结合 `0.5` 的恢复窗口做故障注入回放（restart/upgrade 后立刻发消息）

### 阶段 7：回归与发布（7.1~7.4）
- 必测项：
  1. Linux 主机实机回放“模型/渠道/更新/日志/Chat/Skills”全链路
  2. 升级后回滚路径可用
- 验收命令（示例）：
  - `npm run test`
  - `bash deploy/docker-update.sh v<target>`
  - `bash deploy/docker-rollback.sh v<target>`

## 统一发布前门禁（最小集）
1. `docker compose config` 无异常且端口全来自 env/配置。
2. `openclaw-panel` 与 `openclaw-gateway` 在同一内部网络。
3. `/api/panel-config` 返回 `deployment.panelPublicUrl / webhookBaseUrl`（可为空但提示正确）。
4. 至少一次 Linux 容器内探测通过（内部 DNS + 关键 API）。
5. `npm run test` 与 `npm run check` 全通过。

## 结论
- 任务 `0.6 建立 Win 开发环境到 Linux 生产环境的一致性门禁清单` 达成。
- 后续进入编码阶段时，必须按本门禁执行阶段验收，不得只提交“Windows 本地可用”的结果。
</file>

<file path="plan/2026-02-16_ClawX源码调研/深挖报告_1.1_Gateway适配层联调闭环.md">
# 深挖报告 1.1：Gateway 适配层联调闭环

创建时间：2026-02-16 15:08:00（UTC+8）

## 目标
- 完成面板侧 Gateway 适配层（统一 RPC 调用、超时、重试、错误归一化）。
- 打通 Linux 容器真实链路：`openclaw-panel -> openclaw-gateway`。
- 关闭上一轮阻塞：`missing scope: operator.read`。

## 实施范围
- 代码文件：
  - `src/gateway-client.js`
  - `test/unit/gateway-client.test.js`
- 证据文件：
  - `plan/2026-02-16_ClawX源码调研/evidence/gateway-adapter-live.json`

## 根因链路（按出现顺序）
1. `missing scope: operator.read`
- 现象：`sessions.list` 实时调用失败。
- 根因：未携带 device 身份时，网关会把客户端声明 scope 清空，导致后续方法鉴权失败。
- 修复：在 `connect` 中补充 device 身份签名字段（deviceId/publicKey/signature/signedAt/nonce）。

2. `device nonce required`
- 现象：补 device 后首次握手仍失败。
- 根因：网关 challenge 事件帧类型为 `type: "event"`，适配层只识别了 `evt`，导致未取到 nonce。
- 修复：兼容 `event/evt` 两种事件帧类型，并在握手前短延迟等待 challenge（按 timeout 自适应）。

3. `invalid connect params: unexpected property 'nonce'`
- 现象：取到 nonce 后仍被拒绝。
- 根因：nonce 被放进 connect 顶层字段，协议仅允许放在 `device.nonce`。
- 修复：移除 connect 顶层 `nonce`，仅保留 `device.nonce`。

## 最终实现
- 新增/完善能力：
  - Gateway WS URL 解析（runtime + env 优先级）。
  - RPC 超时与重试机制。
  - 错误归一化（auth/network/timeout/protocol/remote）。
  - device 身份加载与签名握手：
    - 身份路径支持环境变量覆盖：`OPENCLAW_DEVICE_IDENTITY_PATH`
    - 默认按 OpenClaw 状态目录推导 `identity/device.json`
    - token 支持从 `identity/device-auth.json` 回退
  - `connect.challenge` 握手兼容。

## 验证结果
1. 自动化验证
- `npm run test`：通过（unit + regression）。
- `npm run check`：通过。

2. Linux 容器联调
- 重建：`docker compose up -d --build panel`
- 实测调用：容器内执行 `callGatewayRpc(method='sessions.list')`
- 结果：成功返回
  - 证据：`plan/2026-02-16_ClawX源码调研/evidence/gateway-adapter-live.json`
  - 摘要：`{"ok":true,"count":14,"sessionCount":14}`

## 结论
- `1.1 Gateway 适配层` 已闭环，可进入 `1.2 Dashboard 聚合服务层` 开发。
- 已满足“Windows 开发环境 + Linux 容器真实运行链路”的一致性门禁要求。
</file>

<file path="plan/2026-02-16_ClawX源码调研/深挖报告_1.2_Dashboard聚合服务层.md">
# 深挖报告 1.2：Dashboard 聚合服务层

创建时间：2026-02-16 15:13:00（UTC+8）

## 目标
- 新增统一聚合服务，后端一次性输出仪表盘所需核心数据结构。
- 避免前端继续分散拼接“模型 / 渠道 / Skills / 运行态”多来源数据。
- 保持插件式控制架构：只通过控制层读写，不改 OpenClaw 核心源码。

## 实施范围
- 新增：
  - `src/dashboard-service.js`
  - `test/unit/dashboard-service.test.js`
- 修改：
  - `src/server.js`（新增 `GET /api/dashboard/summary`）
- 验证证据：
  - `plan/2026-02-16_ClawX源码调研/evidence/dashboard-summary-live.json`

## 设计说明
1. 聚合来源
- 模型与渠道配置：复用 `extractSettings(openclawConfig)`。
- 渠道运行态：Gateway RPC `channels.status`。
- Skills 状态：Gateway RPC `skills.status`。
- 网关服务运行态：`runServiceAction("status")`。

2. 可靠性策略
- Gateway 调用统一使用重试窗口（约 10~15 秒）：
  - `timeoutMs=1000`
  - `retries=6`
  - `retryDelayMs=1000`
- 单路失败不拖垮整体：`channels.status` / `skills.status` 使用 `Promise.allSettled`，失败时降级输出 `ok=false + message`。

3. 输出结构（核心）
- `summary.model`：当前模型、提供商统计、模型清单。
- `summary.channels.configured`：配置态（是否启用等）。
- `summary.channels.runtime`：运行态（configured/running/lastError）。
- `summary.skills`：总数、启用数、可用数、阻断数、列表。
- `summary.runtime`：服务运行态（ok/active/mode/message）。

## 验证结果
1. 自动化测试
- `npm run test`：通过（新增 `dashboard-service` 单测）。
- `npm run check`：通过。

2. Docker 运行态验证
- 重建 `panel`：`docker compose up -d --build panel`
- 接口验证：
  - 宿主机：`http://127.0.0.1:18080/api/dashboard/summary` 返回 200
  - 容器内：`openclaw-panel` 内 `fetch('/api/dashboard/summary')` 返回 200
- 证据摘要：
  - `modelProviders=4`
  - `modelTotal=7`
  - `skillsTotal=53`
  - `runtimeActive=true`

## 结论
- `1.2 Dashboard 聚合服务层` 已完成并可在 Linux 容器运行。
- 可以进入 `1.3 Skills 服务层`，把 Skills 查询/启停/配置回写拆成独立服务边界。
</file>

<file path="plan/2026-02-16_ClawX源码调研/深挖报告_1.3_Skills服务层.md">
# 深挖报告 1.3：Skills 服务层

创建时间：2026-02-16 15:16:30（UTC+8）

## 目标
- 建立独立 Skills 服务层，支持：
  - 查询技能状态列表
  - 启用/禁用技能
  - 读取单技能关键配置
- 规避已知风险：`skills.update` 对不存在 skillKey 的“假成功”。

## 实施范围
- 新增：
  - `src/skills-service.js`
  - `test/unit/skills-service.test.js`
- 修改：
  - `src/server.js`（新增 Skills API）
- 证据：
  - `plan/2026-02-16_ClawX源码调研/evidence/skills-service-live.json`

## 设计要点
1. 服务边界
- `listSkillsStatus`：统一调用 `skills.status`，输出标准化结构（key/name/enabled/eligible/blocked/source/requirements）。
- `getSkillConfig`：读取 `openclaw.json` 的 `skills.entries[skillKey]`，返回掩码后的关键配置（`enabled`、`apiKeyMasked`、`env`）。
- `setSkillEnabled`：先读 `skills.status` 建立技能索引，再调用 `skills.update`；不存在的 skillKey 直接拒绝。

2. 风险兜底
- 针对“未知 skillKey 假成功”问题，服务层增加前置存在性校验，拒绝直接透传 `skills.update`。

3. 可靠性策略
- 复用 Gateway 调用重试窗口（约 10~15 秒）：
  - `timeoutMs=1000`
  - `retries=6`
  - `retryDelayMs=1000`

## API 输出
- `GET /api/skills/status`
  - 返回技能总数、启停统计、技能列表。
- `GET /api/skills/:skillKey/config`
  - 返回目标技能的关键配置（掩码）。
- `POST /api/skills/:skillKey/enabled`
  - 入参：`{ "enabled": true|false }`
  - 先校验 skillKey 是否存在，再执行更新。

## 验证结果
1. 自动化
- `npm run test`：通过（新增 Skills 服务层单测）。
- `npm run check`：通过。

2. Docker 联调（无副作用）
- `GET /api/skills/status`：`ok=true`，`skillsTotal=53`
- `GET /api/skills/skill-creator/config`：`ok=true`
- `POST /api/skills/__unknown_skill__/enabled`：`ok=false`，返回“未知技能”
- 证据：`plan/2026-02-16_ClawX源码调研/evidence/skills-service-live.json`

## 结论
- `1.3 Skills 服务层` 已完成，且已修复“未知技能误更新”风险入口。
- 下一步可进入 `1.4 Chat 服务层`（会话、历史、发送、中止）。
</file>

<file path="plan/2026-02-16_ClawX源码调研/深挖报告_1.4_Chat服务层.md">
# 深挖报告 1.4：Chat 服务层（会话/历史/发送/中止）

创建时间：2026-02-16 15:20:30（UTC+8）

## 目标
- 在不改 OpenClaw 核心的前提下，提供控制台后端 Chat 服务边界：
  - 会话列表
  - 历史读取
  - 消息发送
  - 运行中止
  - 会话重置
- 为后续 `1.5` 流式通道打基础。

## 实施范围
- 新增：
  - `src/chat-service.js`
  - `test/unit/chat-service.test.js`
- 修改：
  - `src/server.js`（新增 Chat API）
- 证据：
  - `plan/2026-02-16_ClawX源码调研/evidence/chat-service-live.json`

## 设计要点
1. 服务封装
- `listChatSessions` → `sessions.list`
- `getChatHistory` → `chat.history`
- `sendChatMessage` → `chat.send`（包含 idempotencyKey）
- `abortChatRun` → `chat.abort`
- `resetChatSession` → `sessions.reset`

2. 参数与容错
- 所有入口参数统一做校验（`sessionKey`、`message` 等）。
- Gateway 调用统一沿用重试窗口（`timeoutMs=1000, retries=6, retryDelayMs=1000`）。

3. API 设计
- `GET /api/chat/sessions`
- `GET /api/chat/history?sessionKey=...&limit=...`
- `POST /api/chat/send`
- `POST /api/chat/abort`
- `POST /api/chat/session/reset`

## 验证结果
1. 自动化
- `npm run test`：通过（新增 chat-service 单测）。
- `npm run check`：通过。

2. Docker 联调
- 路径：`sessions -> history -> send -> abort -> reset`
- 结果：全部成功，关键字段返回正常（`runId`、`aborted`、`resetKey`）。
- 证据：`plan/2026-02-16_ClawX源码调研/evidence/chat-service-live.json`

## 结论
- `1.4 Chat 服务层` 已完成，具备会话切换与消息收发基础能力。
- 下一步进入 `1.5 Chat 流式输出通道`，补齐 delta/final/error/aborted 的实时推送链路。
</file>

<file path="plan/2026-02-16_ClawX源码调研/深挖报告_1.5_Chat流式SSE通道.md">
# 深挖报告 1.5：Chat 流式 SSE 通道

创建时间：2026-02-16 16:02:00（UTC+8）

## 目标
- 为面板提供稳定的 Chat 流式输出链路，补齐 `1.4` ACK-only 的缺口。
- 使用 SSE（服务端事件流）向前端持续推送 `delta/final/aborted/error`。
- 在 Gateway 短时断链场景下，保证自动重连，不让前端“卡发送态”。

## 本轮改动

### 后端
- `src/gateway-client.js`
  - 新增 `subscribeGatewayEvents(...)`：长连接订阅 Gateway 事件，支持 `connect.challenge` 握手。
  - 保留并复用设备身份签名与 token 回退逻辑。
- `src/chat-service.js`
  - 新增 `createChatEventSubscription(...)`：
    - 过滤指定 `sessionKey` 的事件；
    - 归一化 `chat`/`agent` 事件；
    - 在 `final/error/aborted` 时额外发出 `terminal` 事件。
- `src/server.js`
  - 新增 `GET /api/chat/stream`（SSE）：
    - 输出 `ready/status/chat/agent/terminal/stream-error/heartbeat`；
    - 内置 Gateway 断链自动重连（指数退避到 10s）。

### 前端
- `public/index.html`
  - 对话控制台新增：
    - `流式通道状态`
    - `重连流式通道` 按钮
    - `流式输出（SSE）` 面板
- `public/app.js`
  - 新增流式连接管理：
    - 切换会话自动重连 SSE；
    - 发送前确保流通道已连接；
    - 实时渲染 `chat/agent` 事件；
    - 终态后自动刷新历史。

## 验证证据
- 自动化测试
  - `npm run test`：通过
  - `npm run check`：通过
- Docker 联调
  - `docker compose up -d --build panel`：成功
- 运行态证据
  - `plan/2026-02-16_ClawX源码调研/evidence/chat-stream-sse-live.json`
  - 关键结果：
    - 事件计数包含 `chat`、`agent`、`terminal`
    - `sampleStates` 含 `delta -> final`
    - `terminalState = final`

## 风险与回滚
- 风险
  - 高并发多会话下，当前面板仍以“单会话流观察”为主（符合当前控制台定位）。
- 回滚
  - 回滚文件：
    - `src/gateway-client.js`
    - `src/chat-service.js`
    - `src/server.js`
    - `public/index.html`
    - `public/app.js`
  - 不涉及 OpenClaw 核心源码修改。

## Linux 可用性结论
- 方案基于 Docker 运行态联调完成，核心依赖是 Gateway WS + SSE；
- 不依赖 Windows 特有能力，Linux 生产环境可直接使用；
- 满足“外部端口可配置、容器内走内部网络”的既有约束。
</file>

<file path="plan/2026-02-16_ClawX源码调研/深挖报告_1.6_ClawX用户视角功能差异矩阵.md">
# 深挖报告 1.6：ClawX 用户视角功能差异矩阵

创建时间：2026-02-16

## 目标

在“插件式控制器”边界不变的前提下，对比 `third_party/ClawX` 与当前控制台的**用户可见功能**，明确：

1. 哪些能力已对齐；
2. 哪些能力是“有但难用”；
3. 哪些能力仍需迁移；
4. 小白用户优先的落地顺序。

## 对比范围

- 参考项目：`third_party/ClawX`
- 当前项目：本仓库 `public/*` + `src/*`
- 页面范围：Dashboard、Chat、Channels、Skills、Providers/Updates

## 差异矩阵（用户视角）

| 模块 | ClawX（用户看到的能力） | 当前面板状态 | 差异等级 | 结论 |
|------|-------------------------|-------------|---------|------|
| Dashboard | 状态卡片 + 快捷入口 + 渠道/技能摘要 | 已有状态卡片与摘要，但信息分散在“仪表盘/状态总览”两个页面 | 中 | 合并信息密度与快捷操作，减少页面跳转 |
| Chat | 主聊天页（多会话、流式、thinking、发送/停止、更自然消息区） | 已有 API 能力，但前端是“对话控制台”调试风格（原始事件流、术语偏技术） | 高 | 升级为“主聊天工作台”是当前最高优先级 |
| Channels | 配置+连通性测试+状态反馈 | 已有配置与测试，但交互提示偏技术，错误回显聚合在全局日志 | 中 | 保持后端逻辑，补字段级提示与步骤化引导 |
| Skills | 列表、启停、详情、市场（ClawX） | 已有列表/启停/只读配置；无配置编辑、无市场 | 中 | 先补“可编辑关键配置”，市场能力按需延后 |
| Providers | 提供商增删改查、默认切换、校验 | 已有默认模型/模板/自定义，功能主干存在 | 低 | 继续打磨小白体验（模板优先、少填字段） |
| Updates | 检查/下载/安装进度与提示 | 已有检查/升级/回滚，具备闭环 | 低 | 以稳定优先，UI细节后置 |

## 当前确认可直接迁移的高价值能力

1. Chat 主页面交互范式：
   - 会话列表+新建会话；
   - 聊天气泡式历史展示；
   - 流式输出原位渲染（而不是原始事件日志）；
   - thinking 显示开关；
   - 中止（Stop）按钮与发送态收敛。
2. Dashboard 入口联动：
   - 在仪表盘提供到 Chat/Channels/Skills 的快捷跳转；
   - 按“用户要做的事”组织信息，而不是按系统模块分散。
3. Skills 管理可操作化：
   - 在“查看配置”基础上增加“编辑关键项并保存”能力。

## 暂不迁移项（明确边界）

1. 首次安装向导（不符合预装交付场景）。
2. 任务调度与主题系统（非当前交付主线）。
3. Electron 专属能力（托盘、桌面更新机制、IPC UI 细节）。

## 迁移优先级（小白优先）

1. P0：Chat 页面从“调试控制台”升级为“主聊天工作台”。
2. P1：Dashboard 与状态总览整合成“更少页面、更直观动作”。
3. P1：Skills 增加可编辑配置入口。
4. P2：Channels 的字段级错误提示与分步指引。
5. P2：Providers/Updates 的细节交互优化。

## 风险与控制

1. 风险：Chat 前端改造容易破坏现有 SSE 收敛逻辑。  
   控制：先保持后端协议不变，仅替换展示层；新增单测覆盖会话新建与终态收敛。
2. 风险：为了“简单”误删高级能力。  
   控制：保留高级入口，但默认折叠为“高级选项”。
3. 风险：Windows 开发通过但 Linux 运行异常。  
   控制：每阶段在 Docker（Linux 容器）做回放，结果落 `evidence/`。

## 本报告结论

当前最该抄的不是“再加一个调试页”，而是把现有 `/chat-console` 直接升级成小白可用的主聊天页。  
后端能力已具备基础条件，下一步应优先改前端交互模型，再补“新建会话”后端接口来完成闭环。
</file>

<file path="plan/2026-02-16_ClawX源码调研/深挖报告_1.7_Chat主页面用户化改造.md">
# 深挖报告 1.7：Chat 主页面用户化改造

创建时间：2026-02-16

## 本轮目标

将现有 `/chat-console` 从“工程调试页”升级为“用户主聊天页”，在用户视角尽量对齐 ClawX 的核心体验：

1. 多会话；
2. 流式回复；
3. 思考状态开关；
4. 停止回复；
5. 默认简洁、高级信息折叠。

## 实施范围

- 后端：
  - `src/chat-service.js`
  - `src/server.js`
  - `test/unit/chat-service.test.js`
- 前端：
  - `public/index.html`
  - `public/app.js`
  - `public/styles.css`

## 已完成能力

1. 新增会话创建接口：
   - `POST /api/chat/session/new`
   - 逻辑：复用 canonical 前缀生成新 key，调用 `sessions.reset(reason=new)` 创建会话。
2. 聊天页用户化：
   - 侧栏入口改名“智能对话”。
   - 页面默认展示会话、聊天消息、输入区。
   - “高级调试信息”折叠保存原始历史与 SSE 事件。
3. 消息渲染升级：
   - 历史消息与流式 `delta` 采用消息气泡展示。
   - `final/error/aborted` 会收敛发送态并刷新历史。
4. 交互增强：
   - 新建会话按钮；
   - Enter 发送、Shift+Enter 换行；
   - 发送中按钮态和 Stop 按钮联动；
   - thinking 展示开关（仅影响显示层）。

## 与 ClawX 的差异（仍未完全一致）

1. 附件交互：ClawX 支持拖拽/粘贴/附件预览，本项目当前仅文本发送。
2. 富文本渲染：ClawX 聊天消息支持更完整的 Markdown/工具结果展现；本项目当前为纯文本消息体。
3. 会话工具栏：ClawX 的会话项包含更细状态与交互细节（如更完整的会话标签行为），本项目当前是简化版下拉切换。
4. 错误提示：本项目仍使用全局操作时间线提示，尚未做到字段级/局部提示。

## 验证证据

1. 自动化：
   - `npm run test:unit` 通过（含新增 `createChatSession` 用例）。
   - `npm run test:regression` 通过。
2. Docker：
   - `docker compose up -d --build panel` 重建成功。
3. 运行态：
   - `evidence/chat-session-new-live.json`
   - `evidence/chat-user-workspace-live.md`

## 结论

本轮已完成“从控制台到主聊天页”的第一阶段迁移，核心用户路径可用。  
若要进一步逼近 ClawX 体验，下一优先级应是：附件能力 + 消息富渲染 + 局部错误提示。
</file>

<file path="plan/2026-02-16_ClawX源码调研/深挖报告_1.8_Chat附件上传与路径映射.md">
# 深挖报告 1.8：Chat 附件上传与路径映射

创建时间：2026-02-16

## 本轮目标

补齐 ClawX 聊天体验中“附件能力”的关键链路，确保 Web 面板场景下可用：

1. 用户可上传/粘贴/拖拽文件；
2. 文件可被安全落盘到 OpenClaw 媒体目录；
3. 聊天发送时可正确映射为网关可访问路径；
4. 在 Docker 双容器路径不同的情况下仍能读到附件。

## 核心实现

### 1) 新增附件落盘接口

- 接口：`POST /api/chat/attachments/stage`
- 文件：`src/server.js`、`src/chat-service.js`
- 行为：
  - 接收 `fileName/mimeType/base64`
  - 落盘到 `<openclawRoot>/media/outbound/`
  - 返回 `stagedPath/fileSize/preview`

### 2) 聊天发送链路增强

- 文件：`src/chat-service.js`
- 行为：
  - 支持 `attachments[]` 入参
  - 对图片附件（png/jpeg/webp/gif/bmp）生成 base64 `attachments` 传给 `chat.send`
  - 对所有附件写入 `[media attached: ...]` 文件引用
  - 增加路径白名单校验：仅允许 `media/outbound` 下的文件参与发送

### 3) 容器路径映射修复（关键）

问题根因：
- 面板容器路径：`/data/openclaw/...`
- 网关容器路径：`/home/node/.openclaw/...`
- 若直接传面板路径，网关会 `ENOENT`。

修复：
- 发送前将本地绝对路径映射为网关根路径（默认 Docker 用 `/home/node/.openclaw`）。
- 新增配置字段：`openclaw.gateway_media_root`（`src/panel-config.js` + `deploy/panel.config.docker.json`）。

### 4) 附件文件权限修复（关键）

问题根因：
- 早期落盘权限过严导致网关读取 `EACCES`。

修复：
- 附件写入权限调整为 `0644`，确保网关容器用户可读。

## 前端交互增强

- 文件：`public/index.html`、`public/app.js`、`public/styles.css`
- 增加：
  - “添加附件”按钮 + 隐藏文件输入
  - 粘贴/拖拽上传
  - 附件列表与移除按钮
  - 图片预览（可用时）
  - 发送时自动携带附件元数据

## 验证结果

1. 自动化：
   - `npm run test:unit` 通过（新增附件相关单测）
   - `npm run test:regression` 通过
2. Docker：
   - `docker compose up -d --build panel` 多次重建通过
3. 运行态：
   - 附件 staging 成功
   - 聊天发送成功
   - 历史消息显示网关路径映射为 `/home/node/.openclaw/...`
   - 网关工具成功读取附件内容并返回 `ok`

证据：
- `evidence/chat-attachments-live.json`
- `evidence/chat-attachments-pathmap-live.json`
- `evidence/chat-attachments-ui-live.md`

## 结论

附件链路已从“无能力”升级为“可用且可验证”的完整闭环。  
下一步应聚焦 `6.8`：消息富渲染（Markdown/工具消息）和局部错误提示，进一步降低小白用户理解成本。
</file>

<file path="plan/2026-02-16_ClawX源码调研/深挖报告_1.9_Chat富渲染与局部错误提示.md">
# 深挖报告 1.9：Chat 富渲染与局部错误提示

创建时间：2026-02-16

## 本轮目标

完成 `6.8`：在不改变现有后端协议的前提下，提升消息可读性与错误可定位性，进一步对齐 ClawX 的用户视角体验。

目标拆解：
1. 消息富渲染（基础 Markdown + 代码块）；
2. 工具调用/工具结果文本可读化；
3. 聊天区域内联动作提示（成功/失败）。

## 实施范围

- 前端：
  - `public/app.js`
  - `public/index.html`
  - `public/styles.css`
- 文档与证据：
  - `plan/2026-02-16_ClawX源码调研/evidence/chat-rich-render-inlinehint-live.md`
  - `plan/2026-02-16_ClawX源码调研/任务清单.md`
  - `plan/2026-02-16_ClawX源码调研/规格变更/OpenClaw面板.md`
  - `plan/规格/OpenClaw面板.md`

## 关键改动

### 1) 消息富渲染

- 新增 `renderRichMessageBody` 渲染链路：
  - 识别 `**bold**`
  - 识别行内代码 `` `code` ``
  - 识别 fenced code block（```）
- assistant/system/tool 消息改用富渲染输出，user 消息保持纯文本。

### 2) 工具消息可读化

- 在消息归一化阶段兼容：
  - `toolCall` / `tool_call`
  - `toolResult` / `tool_result`
- 统一渲染为：
  - `[工具调用] <name>`
  - `[工具结果] <content>`

### 3) 局部动作提示

- 在聊天操作区新增 `#chat_inline_hint`。
- 新增 `setChatInlineHint`、`reportChatActionError`：
  - 覆盖发送、刷新会话、刷新历史、新建会话、附件处理、中止、重置等动作。
- 结果：用户无需只看全局时间线，也能在当前操作区域快速定位问题。

## 与 ClawX 用户视角的一致性进展

已明显对齐：
1. 聊天内容可读性（非原始结构文本）；
2. 操作反馈更贴近消息上下文；
3. 工具事件更容易被小白用户理解。

仍有差异：
1. 富渲染目前是“轻量子集”，未覆盖完整 Markdown 语法；
2. 未引入 ClawX 级别的富组件（引用块、复杂表格等）。

## 验证结果

1. 自动化：
   - `npm run test:unit` 通过（48/48）。
   - `npm run test:regression` 通过（3 pass, 1 skip）。
2. Docker：
   - `docker compose up -d --build panel` 重建成功。
3. 运行态：
   - 页面含 `chat_inline_hint`。
   - 运行 JS/CSS 均包含关键渲染/提示逻辑。
   - 证据：`evidence/chat-rich-render-inlinehint-live.md`。

## 结论

`6.8` 已闭环，聊天页在“小白可读性”上已达到下一阶段推进条件。  
下一优先级建议回到仪表盘增强（`2.1`），把状态总览信息进一步按“用户动作”组织并补快捷入口。
</file>

<file path="plan/2026-02-16_ClawX源码调研/深挖报告_2.1_仪表盘状态总览增强.md">
# 深挖报告 2.1：仪表盘状态总览增强

创建时间：2026-02-16

## 本轮目标

完成任务 `2.1`：把仪表盘补齐为“一页式巡检入口”，覆盖以下六类信息：

1. 运行状态
2. 当前模型
3. 渠道状态
4. Skills 状态
5. 错误摘要
6. 版本状态

并补充快捷操作与运行态明细，降低小白用户跨页面跳转成本。

## 实施范围

- 前端：
  - `public/index.html`
  - `public/app.js`
  - `public/styles.css`
- 文档：
  - `plan/2026-02-16_ClawX源码调研/任务清单.md`
  - `plan/2026-02-16_ClawX源码调研/evidence/dashboard-overview-enhanced-live.md`

## 关键改动

### 1) 仪表盘新增总览卡片

- 新增 6 个 KPI 卡片：
  - 运行状态
  - 当前模型
  - 渠道状态
  - Skills 状态
  - 错误摘要
  - 版本状态
- 新增“刷新总览”按钮：并发刷新
  - `/api/dashboard/summary`
  - `/api/logs/errors`
  - `/api/update/check`

### 2) 仪表盘新增快捷操作

- 新增“快捷操作”入口，直达：
  - 智能对话
  - 模型与提供商配置
  - 渠道接入
  - Skills 管理
  - 版本更新
  - 服务控制

### 3) 运行态明细迁移到仪表盘

- 在仪表盘新增：
  - 渠道运行态列表
  - Skills 运行态列表
- 与原状态总览页并行展示，保证本轮先迁移不破坏原路径。

### 4) 数据同步策略

- `loadStatusOverview` 现在同时更新：
  - 原状态总览页字段
  - 仪表盘总览卡片 + 仪表盘运行态列表
- `loadErrorSummary` 增加仪表盘错误摘要同步。
- `checkUpdate` 增加仪表盘版本状态同步，支持 `silent` 模式避免启动刷屏。

## 与 ClawX 用户视角对齐情况

已对齐：
1. 仪表盘具备“状态卡片 + 快捷动作 + 运行态明细”结构；
2. 首页可一眼看出当前系统关键状态；
3. 入口按“用户要做的事”组织，而不是只按技术模块拆分。

未完全对齐：
1. 侧栏仍保留独立“状态总览”入口，存在重复信息；
2. 尚未完成模型快速切换入口（任务 `2.2`）。

## 验证结果

1. 自动化：
   - `npm run test:unit` 通过
   - `npm run test:regression` 通过
2. Docker：
   - `docker compose up -d --build panel` 成功
3. 运行态证据：
   - `evidence/dashboard-overview-enhanced-live.md`

## 结论

`2.1` 已完成。下一步建议按任务清单继续执行：

1. `2.2` 模型快速切换入口（带上下文风险提示）；
2. `2.3` 收敛侧栏“状态总览”入口，消除重复信息。
</file>

<file path="plan/2026-02-16_ClawX源码调研/深挖报告_2.2_仪表盘模型快速切换.md">
# 深挖报告 2.2：仪表盘模型快速切换

创建时间：2026-02-16

## 本轮目标

完成任务 `2.2`：在仪表盘提供模型快速切换能力，并保持上下文降级风险提示准确可用。

## 实施范围

- 前端：
  - `public/index.html`
  - `public/app.js`
- 文档与证据：
  - `plan/2026-02-16_ClawX源码调研/任务清单.md`
  - `plan/2026-02-16_ClawX源码调研/evidence/dashboard-quick-model-switch-live.md`

## 关键改动

### 1) 仪表盘新增快速切换控件

- 新增控件：
  - `dashboard_quick_context_tokens`（当前会话上下文）
  - `dashboard_quick_model_ref`（目标模型下拉）
  - `dashboard_quick_switch`（一键切换）
- 支持直接在仪表盘切换默认模型，减少用户跳页操作。

### 2) 切换逻辑复用与收敛

- 新增模型辅助函数：
  - `collectCatalogModelEntries`
  - `findModelEntryByRef`
  - `confirmModelSwitchRisk`
  - `switchDefaultModelByEntry`
- 模型页卡片切换与仪表盘切换统一复用同一风险判断和保存逻辑，避免双实现分叉。

### 3) 上下文输入状态统一

- 仪表盘与模型页的上下文输入通过 `data-dashboard-context-input` 统一管理；
- 两处输入共享 `DASHBOARD_CONTEXT_KEY`（`localStorage`），并双向同步，保证风险提示一致。

## 验证结果

1. 自动化：
   - `npm run test:unit` 通过
   - `npm run test:regression` 通过
2. Docker：
   - `docker compose up -d --build panel` 成功
3. 运行态：
   - 仪表盘控件可见且可选择目标模型；
   - 上下文降级场景触发确认提示；
   - 取消确认不会误切换当前模型；
   - 证据：`evidence/dashboard-quick-model-switch-live.md`。

## 与用户视角一致性

改造前：
- 只能去“模型与提供商配置”页面切换模型；
- 仪表盘只能看状态，不能直接操作。

改造后：
- 仪表盘可“看 + 切换”一体化；
- 高风险切换（大上下文 -> 小上下文）会给出明确提示。

## 结论

`2.2` 已完成。仪表盘阶段（`2.1/2.2/2.3`）已全部闭环。  
下一主线可转入 `3.x`（模型与提供商页体验增强）或 `5.x`（Skills 配置写回能力）。
</file>

<file path="plan/2026-02-16_ClawX源码调研/深挖报告_2.3_状态总览侧栏迁移.md">
# 深挖报告 2.3：状态总览侧栏迁移

创建时间：2026-02-16

## 本轮目标

完成任务 `2.3`：把重复的“状态总览”从侧栏迁移并收敛到“仪表盘”，降低用户页面选择成本，同时保证历史路径可兼容访问。

## 实施范围

- 前端结构：
  - `public/index.html`
  - `public/app.js`
  - `public/app-routes.js`
- 测试：
  - `test/unit/app-routes.test.js`
- 文档与证据：
  - `plan/2026-02-16_ClawX源码调研/任务清单.md`
  - `plan/2026-02-16_ClawX源码调研/evidence/dashboard-status-migration-live.md`

## 关键改动

### 1) 侧栏入口收敛

- 移除侧栏 `状态总览` tab。
- 删除独立 `panel-status-overview` 页面结构，避免与仪表盘重复展示。

### 2) 旧路径兼容

- `public/app-routes.js` 新增别名逻辑：
  - `/status-overview` -> `panel-dashboard`
- `isKnownPanelPath` 保留 `/status-overview` 为合法路径，避免旧链接进入 fallback。

### 3) 清理冗余逻辑

- 删除仅服务于旧页面的绑定逻辑（状态总览按钮监听）。
- 保留仪表盘聚合刷新主链路，避免能力回退。

## 验证结果

1. 自动化：
   - `npm run test:unit` 通过（新增路由别名断言）
   - `npm run test:regression` 通过
2. Docker：
   - `docker compose up -d --build panel` 成功
3. 运行态：
   - 侧栏不再显示“状态总览”
   - 访问 `/status-overview` 显示仪表盘内容
   - 证据：`evidence/dashboard-status-migration-live.md`

## 用户视角变化

1. 入口更少：不用在“仪表盘”和“状态总览”之间来回切。
2. 行为更稳：历史收藏链接仍可用，不会打开空白页。
3. 认知更清晰：状态巡检唯一入口就是“仪表盘”。

## 结论

`2.3` 已完成，信息架构从“双入口重复”收敛到“单入口聚合”。  
下一步建议执行 `2.2`：在仪表盘增加模型快速切换入口，并复用已实现的上下文风险提示逻辑。
</file>

<file path="plan/2026-02-16_ClawX源码调研/深挖报告_2.4_仪表盘Shoelace试点改造.md">
# 深挖报告 2.4：仪表盘 Shoelace 试点改造

## 1. 背景
- 当前仪表盘在小白用户视角下“层次不清、密度偏高”，尤其是运行态明细（渠道/Skills）阅读负担偏大。
- 本轮目标是在不改业务逻辑的前提下，先做单页组件化试点，验证“更清晰的视觉层次 + 低改造风险”是否可行。

## 2. 本轮目标
- 仅改造 `/dashboard` 页面，不动其它页面交互与结构。
- 引入本地托管 Shoelace 组件能力（不依赖外网 CDN）。
- 保持现有事件与 API 链路不变：刷新总览、模型快速切换、快捷跳转、运行态渲染。

## 3. 改动范围
- `package.json`：新增 `@shoelace-style/shoelace` 依赖。
- `src/server.js`：新增 `/shoelace/` 静态资源映射。
- `public/index.html`：仅重排仪表盘区块，接入 Shoelace 主题与自动加载器。
- `public/styles.css`：新增仪表盘组件化样式层（KPI 卡片、运行态卡片、标签样式）。
- `public/app.js`：仪表盘运行态列表改为 Shoelace 卡片/标签渲染；主题切换同步 Shoelace dark/light class。

## 4. 关键实现
### 4.1 本地资源接入
- 后端增加第二个 static root 指向 `node_modules/@shoelace-style/shoelace/cdn`。
- 解决 Fastify 双 static 注册冲突：第二次注册显式配置 `decorateReply: false`。

### 4.2 仪表盘结构改造
- 保留所有既有业务 ID（如 `dashboard_summary_*`、`dashboard_quick_*`、`dashboard_*_list`），避免改动事件绑定代码。
- 状态总览改为 Shoelace KPI 卡片，运行态条目改为 Shoelace `sl-card + sl-tag`。
- 运行态容器继续采用“左渠道、右技能”的双列，但改成固定滚动区域，防止页面无限拉长。

### 4.3 主题一致性
- 原有主题切换逻辑继续使用 `body[data-theme]`。
- 新增 `document.documentElement` 上 `sl-theme-light/sl-theme-dark` 切换，确保 Shoelace 组件与全站主题同步。

## 5. 验证结果
- 自动化：`npm test` 全量通过。
- Docker：`docker compose up -d --build panel` 成功。
- 运行态：
  - `GET http://127.0.0.1:18080/api/health` 返回 200。
  - `GET http://127.0.0.1:18080/shoelace/themes/light.css` 返回 200。
- 浏览器检查：`/dashboard` 页面组件渲染正常，控制台无新增阻断级报错（既有 `service/status` 400 为历史行为，与本次改造无关）。

## 6. 风险与回滚
- 风险：Shoelace 接入后增加少量前端资源请求。
- 回滚：
  1. 删除 `public/index.html` 中 Shoelace 资源引用与仪表盘组件标签。
  2. 回退 `public/app.js` 仪表盘渲染函数到原生节点实现。
  3. 移除 `src/server.js` 的 `/shoelace/` 静态映射与 `package.json` 依赖。
- 影响边界：仅控制台前端与面板服务静态资源层，不涉及 OpenClaw 核心逻辑与配置写入链路。
</file>

<file path="plan/2026-02-16_ClawX源码调研/深挖报告_3.1_模型与提供商双通道解耦.md">
# 深挖报告 3.1：模型与提供商双通道解耦

创建时间：2026-02-16

## 本轮目标

完成任务 `3.1`：保持“设置当前默认模型”和“新增提供商”双通道结构，确保两条路径可以独立完成配置，避免隐式副作用。

## 实施范围

- 前端：
  - `public/index.html`
  - `public/app.js`
- 文档与证据：
  - `plan/2026-02-16_ClawX源码调研/任务清单.md`
  - `plan/2026-02-16_ClawX源码调研/evidence/model-provider-dual-path-3.1-live.md`

## 关键改动

### 1) 模型页文案与交互入口明确“双通道”

- 新增“模型配置导航”说明，明确：
  - 路径 1：只改当前默认模型；
  - 路径 2：只新增/写入提供商。
- 新增路径跳转按钮，降低小白用户迷路概率。

### 2) 新增提供商流程增加显式开关

- 在“基础配置（模板）”和“自定义模式”各自新增开关：
  - `template_set_as_primary`
  - `custom_set_as_primary`
- 默认关闭：保存提供商时不切换默认模型。
- 用户显式勾选后：保存提供商的同时切换默认模型。

### 3) 修复根因：避免前端固定写入新 primary

- 新增 `resolveProviderSavePrimaryRef()`，按开关状态决定 `primary`：
  - 未勾选：使用当前 `modelSettings.primary`；
  - 已勾选：使用目标 `provider/model`。
- 直接规避后端 `applySettings()` 必写 `agents.defaults.model.primary` 带来的隐式覆盖问题。

## 验证结果

1. 自动化：
- `node --check public/app.js` 通过
- `node --check public/config-generator.js` 通过
- `npm run test:unit` 通过（48/48）
- `npm run test:regression` 通过（3 pass / 1 skip）

2. Docker：
- `docker compose up -d --build panel` 成功

3. 运行态结构：
- `/model` 页面可命中 `template_set_as_primary` 与 `custom_set_as_primary` 两个关键开关
- 证据：`evidence/model-provider-dual-path-3.1-live.md`

## 与用户视角一致性

改造前：
- 用户在“新增提供商”时，容易不知情地把默认模型改掉。

改造后：
- 默认行为是“只新增提供商，不动默认模型”；
- 想切默认模型必须显式勾选，行为可预期、可解释。

## 结论

`3.1` 已完成并验证通过。下一步按清单进入 `3.2`：继续强化“基础模板 vs 自定义模式”的引导与切换体验。
</file>

<file path="plan/2026-02-16_ClawX源码调研/深挖报告_3.2_基础模板与自定义模式切换强化.md">
# 深挖报告 3.2：基础模板与自定义模式切换强化

创建时间：2026-02-16

## 本轮目标

完成任务 `3.2`：强化模型页“基础模板”与“自定义模式”切换，确保模板模式下用户只需填写最少必要字段即可完成提供商配置。

## 实施范围

- 前端：
  - `public/index.html`
  - `public/styles.css`
  - `public/app.js`
- 文档与证据：
  - `plan/2026-02-16_ClawX源码调研/任务清单.md`
  - `plan/2026-02-16_ClawX源码调研/规格变更/OpenClaw面板.md`
  - `plan/2026-02-16_ClawX源码调研/evidence/model-provider-mode-switch-3.2-live.md`

## 关键改动

### 1) 路径 2 增加“工作模式”总入口

- 新增 `model_provider_mode_section`，支持两种模式显式切换：
  - 基础配置（推荐）
  - 自定义模式
- 新增模式提示文案，明确当前模式目的和适用场景。

### 2) 基础模板模式默认最小输入

- 模板模式主区域仅保留高频字段：
  - 模板类型
  - 提供商名称
  - API 地址
  - API Key
- 低频字段移入折叠区“高级参数（通常不用改）”：
  - API 模式
  - 默认模型
  - 保存后设为当前默认模型

### 3) 自定义模式默认隐藏，按需打开

- `model_provider_custom_section` 默认隐藏，避免小白用户首次进入就看到复杂 JSON 字段。
- 用户主动切换后才展示完整自定义配置。

### 4) JS 模式状态管理

- 新增 `setModelProviderMode()`：
  - 统一控制模式按钮激活态、提示文案、面板显隐；
  - 将模式状态收敛到 `modelEditorState.providerMode`。
- 在模型页初始化与回填时默认回到 `template` 模式，保持“新手优先”体验。

## 验证结果

1. 自动化：
- `node --check public/app.js` 通过
- `npm run test:unit` 通过（48/48）
- `npm run test:regression` 通过（3 pass / 1 skip）

2. Docker：
- `docker compose up -d --build panel` 成功

3. 页面结构：
- `/model` 页面已包含模式切换节点与折叠高级参数
- 证据：`evidence/model-provider-mode-switch-3.2-live.md`

## 与用户视角一致性

改造前：
- 新增提供商页面一次性展示大量字段，小白难以判断“哪些必填、哪些可忽略”。

改造后：
- 默认只给“能跑通所需”的最小输入；
- 高级项可按需展开；
- 自定义 JSON 不再默认打断主流程。

## 结论

`3.2` 已完成并通过验证。下一步进入 `3.3`：继续对齐“默认模型下拉列表”和“配置生成器模型 ID”的一致性细节。
</file>

<file path="plan/2026-02-16_ClawX源码调研/深挖报告_3.3_默认模型列表与配置生成器模型ID对齐.md">
# 深挖报告 3.3：默认模型列表与配置生成器模型 ID 对齐

创建时间：2026-02-16

## 本轮目标

完成任务 `3.3`：对齐“设置当前默认模型”与“配置生成器”使用的默认模型 ID 列表，确保保存时模型引用稳定且可预期。

## 实施范围

- 前端：
  - `public/index.html`
  - `public/app.js`
- 文档与证据：
  - `plan/2026-02-16_ClawX源码调研/任务清单.md`
  - `plan/2026-02-16_ClawX源码调研/规格变更/OpenClaw面板.md`
  - `plan/2026-02-16_ClawX源码调研/evidence/model-id-alignment-3.3-live.md`

## 关键改动

### 1) 去除配置生成器模型下拉的静态硬编码

- `public/index.html` 中 `#cfg_model_id` 改为运行时动态渲染，避免“模板新增模型后 HTML 未同步”导致的漂移。

### 2) 新增统一模型选项渲染函数

- 在 `public/app.js` 新增 `fillDefaultModelOptions()`，统一负责：
  - 渲染 `DEFAULT_MODEL_OPTIONS`；
  - 按需附加 `custom` 选项；
  - 保留/回退当前选择值。

### 3) 配置生成器与模板高级参数复用同一模型列表来源

- `setupConfigGenerator()` 使用 `fillDefaultModelOptions(..., { includeCustom: true })`；
- `renderTemplatePreset()` 使用同一函数填充 `template_default_model_id`；
- 从而保证两个入口的预置模型 ID 顺序和内容完全一致。

## 验证结果

1. 自动化：
- `node --check public/app.js` 通过
- `npm run test:unit` 通过（48/48）
- `npm run test:regression` 通过（3 pass / 1 skip）

2. Docker：
- `docker compose up -d --build panel` 成功

3. 运行态一致性：
- DevTools 实测 `cfg_model_id`（去掉 `custom`）与 `template_default_model_id` 列表完全一致；
- `model_default_ref` 下拉包含所有预置模型 ID；
- 证据：`evidence/model-id-alignment-3.3-live.md`。

## 与用户视角一致性

改造前：
- 模型 ID 列表在不同区域由不同实现维护，后续很容易出现“这边有、那边没有”。

改造后：
- 模型 ID 列表单点维护，所有页面同源渲染；
- 小白用户在不同页面看到的模型集合保持一致，减少困惑。

## 结论

`3.3` 已完成并通过验证。下一步进入 `3.4`：完善 API 模式下拉与 GPT/Claude/Gemini 联动（URL 与模式可自动切换且可覆写）。
</file>

<file path="plan/2026-02-16_ClawX源码调研/深挖报告_3.4_API模式下拉与模型联动.md">
# 深挖报告 3.4：API 模式下拉与 GPT/Claude/Gemini 联动

创建时间：2026-02-16

## 本轮目标

完成任务 `3.4`：在“新增提供商”流程中完善 API 模式下拉与模型族联动，确保 GPT/Claude/Gemini 切换时 URL/API 模式自动切换，同时保留可覆写能力。

## 实施范围

- 前端：
  - `public/index.html`
  - `public/app.js`
- 文档与证据：
  - `plan/2026-02-16_ClawX源码调研/任务清单.md`
  - `plan/2026-02-16_ClawX源码调研/规格变更/OpenClaw面板.md`
  - `plan/2026-02-16_ClawX源码调研/evidence/model-api-linkage-3.4-live.md`

## 关键改动

### 1) 自定义模式补齐 API 模式下拉

- `custom_api` 从文本输入升级为下拉 + 自定义输入（`custom_api_custom`）。
- 支持四种预置 API 模式：
  - `openai-responses`
  - `openai-completions`
  - `anthropic-messages`
  - `google-generative-ai`

### 2) 自定义模式补齐默认模型下拉

- `custom_default_model_id` 从文本输入升级为下拉 + 自定义输入（`custom_default_model_id_custom`）。
- 下拉选项与全局默认模型 ID 同源一致。

### 3) 新增联动逻辑（AICodeCat）

- 新增 `syncCustomByModelSelection()`：
  - 根据模型族（GPT/Claude/Gemini）自动切换 API 模式；
  - 自动切换 `providerId` 到 `aicodecat-gpt/claude/gemini`；
  - 自动切换对应 Base URL。
- 新增 `syncCustomByApiMode()`：
  - 直接切换 API 模式时，同步更新 `providerId + Base URL`。

### 4) 保存链路兼容自定义值

- 自定义提供商保存逻辑改为 `getSelectValueWithCustom()` 读取：
  - `custom_api`
  - `custom_default_model_id`
- 既支持预置联动，也支持自定义覆盖。

## 验证结果

1. 自动化：
- `node --check public/app.js` 通过
- `npm run test:unit` 通过（48/48）
- `npm run test:regression` 通过（3 pass / 1 skip）

2. Docker：
- `docker compose up -d --build panel` 成功

3. 运行态联动验证（DevTools）：
- 在 `custom_provider_id=aicodecat` 时切换模型：
  - Claude -> `anthropic-messages` + `https://aicode.cat`
  - GPT -> `openai-responses` + `https://aicode.cat/v1`
  - Gemini -> `google-generative-ai` + `https://aicode.cat/v1beta`
- 证据：`evidence/model-api-linkage-3.4-live.md`

## 与用户视角一致性

改造前：
- 自定义模式 API 模式需要手输，切换模型时 URL 不会自动跟，容易填错。

改造后：
- 模型一选，API 模式和 URL 自动联动；
- 仍保留自定义入口，不锁死高级用户。

## 结论

`3.4` 已完成并验证通过。模型与提供商页增强阶段（`3.1 ~ 3.4`）已全部闭环。
</file>

<file path="plan/2026-02-16_ClawX源码调研/深挖报告_4.1_渠道管理归属清晰.md">
# 深挖报告 4.1：渠道管理归属清晰（仅 OpenClaw 真实渠道）

创建时间：2026-02-16

## 本轮目标

完成任务 `4.1`：明确并落地“渠道页只管理 OpenClaw 真实渠道”，避免出现面板私有虚拟渠道的理解偏差。

## 实施范围

- 前端：
  - `public/index.html`
  - `public/app.js`
- 文档与证据：
  - `plan/2026-02-16_ClawX源码调研/任务清单.md`
  - `plan/2026-02-16_ClawX源码调研/规格变更/OpenClaw面板.md`
  - `plan/2026-02-16_ClawX源码调研/evidence/channel-scope-4.1-live.md`

## 关键改动

### 1) 渠道页入口文案显式声明范围

- 将渠道保存卡片标题改为：
  - `渠道配置保存（仅 OpenClaw 真实渠道）`
- 新增范围说明文案：
  - 仅写入 `channels.telegram/feishu/discord/slack`（含飞书兼容 `accounts.main`）；
  - 不创建任何面板私有“虚拟渠道”。

### 2) 保存动作命名去歧义

- 保存按钮改为 `保存渠道配置`。
- 保存成功提示调整为：
  - `渠道配置写入成功（模型保持当前值）`，避免用户误解“会改模型配置”。

## 验证结果

1. 自动化：
- `node --check public/app.js` 通过
- `npm run test:unit` 通过（48/48）
- `npm run test:regression` 通过（3 pass / 1 skip）

2. Docker：
- `docker compose up -d --build panel` 成功

3. 页面校验：
- `/channels` 页面关键范围文案全部命中；
- 证据：`evidence/channel-scope-4.1-live.md`。

## 与用户视角一致性

改造前：
- 用户能用，但不容易一眼确定“这页到底是改 OpenClaw 真渠道，还是面板私有概念”。

改造后：
- 页面开头直接说清数据归属和写回边界，减少误解和误操作预期。

## 结论

`4.1` 已完成并通过验证。下一步进入 `4.2`：优化 Telegram/飞书可视化配置与连通性测试闭环。
</file>

<file path="plan/2026-02-16_ClawX源码调研/深挖报告_4.2_渠道配置与连通性测试闭环.md">
# 深挖报告 4.2：Telegram/Feishu 可视化配置与连通性测试闭环

创建时间：2026-02-16

## 本轮目标

完成任务 `4.2`：优化 Telegram/飞书的可视化配置与连通性测试流程，确保“保存配置 + 测试连通性”能在页面内一键闭环、结果可复现。

## 实施范围

- 前端：
  - `public/index.html`
  - `public/styles.css`
  - `public/app.js`
- 文档与证据：
  - `plan/2026-02-16_ClawX源码调研/任务清单.md`
  - `plan/2026-02-16_ClawX源码调研/规格变更/OpenClaw面板.md`
  - `plan/2026-02-16_ClawX源码调研/evidence/channel-save-test-loop-4.2-live.md`

## 关键改动

### 1) 新增“保存并测试”一键动作

- Telegram：`save_and_test_telegram`
- Feishu：`save_and_test_feishu`
- 执行顺序统一为：
  1. 保存渠道配置
  2. 回填本轮输入凭证
  3. 立即执行连通性测试

### 2) 修复根因：保存后凭证被脱敏清空导致测试失败

- 问题根因：
  - `saveSettings()` 内部会 `loadInitialData()`；
  - 配置回读时密钥字段脱敏，输入框被清空；
  - 后续测试拿到空凭证，形成“保存并测试必失败”的假故障。
- 修复方式：
  - `saveAndTestTelegram/saveAndTestFeishu` 在保存前缓存本轮输入凭证；
  - 保存完成后先回填凭证，再执行测试。

### 3) 新增最近测试结果可视化

- Telegram：`tg_test_result`
- Feishu：`fs_test_result`
- 显示内容：时间 + 成功/失败 + 具体消息。

### 4) 前置输入校验

- Telegram 测试前校验 `botToken` 非空。
- Feishu 测试前校验 `appId/appSecret` 非空。

## 验证结果

1. 自动化：
- `node --check public/app.js` 通过
- `npm run test:unit` 通过（48/48）
- `npm run test:regression` 通过（3 pass / 1 skip）

2. Docker：
- `docker compose up -d --build panel` 成功

3. 运行态闭环（DevTools mock）：
- Telegram：`PUT /api/settings` 后触发 `POST /api/test/telegram`
- Feishu：`PUT /api/settings` 后触发 `POST /api/test/feishu`
- 页面结果区显示“最近测试（时间）：成功 - ...”
- 证据：`evidence/channel-save-test-loop-4.2-live.md`

## 与用户视角一致性

改造前：
- 用户要手动“保存 -> 再点测试”，且容易因为密钥回填问题出现假失败。

改造后：
- 用户点一次“保存并测试”就能得到明确结果；
- 成功/失败信息直接留在当前卡片，不用翻操作时间线。

## 结论

`4.2` 已完成并通过验证。下一步进入 `4.3`：补齐 Discord/Slack 状态展示与不可用场景优雅降级。
</file>

<file path="plan/2026-02-16_ClawX源码调研/深挖报告_4.3_Discord与Slack状态展示降级兼容.md">
# 深挖报告 4.3：Discord/Slack 状态展示与降级兼容

创建时间：2026-02-16

## 本轮目标

完成任务 `4.3`：补齐 Discord/Slack 状态展示能力，并在接口不可用或输入不完整时优雅降级，不影响页面其他能力。

## 实施范围

- 前端：
  - `public/index.html`
  - `public/app.js`
- 文档与证据：
  - `plan/2026-02-16_ClawX源码调研/任务清单.md`
  - `plan/2026-02-16_ClawX源码调研/规格变更/OpenClaw面板.md`
  - `plan/2026-02-16_ClawX源码调研/evidence/channel-discord-slack-4.3-live.md`

## 关键改动

### 1) 新增 Discord/Slack 最近测试状态区

- Discord：`dc_test_result`
- Slack：`sl_test_result`
- 页面可直接看到最近一次测试结果，不再只依赖全局时间线。

### 2) 增加输入前置校验

- Discord：Token 为空时直接页面内提示失败原因。
- Slack：
  - Bot Token 必填；
  - `socket` 模式要求 `appToken`；
  - `http` 模式要求 `signingSecret`。

### 3) 接口异常优雅降级

- `test_discord/test_slack` 的事件层 catch 统一写入结果区：
  - `接口不可用或测试失败：...`
- 即便后端测试接口异常，页面也能保持可用，不中断其他操作。

## 验证结果

1. 自动化：
- `node --check public/app.js` 通过
- `npm run test:unit` 通过（48/48）
- `npm run test:regression` 通过（3 pass / 1 skip）

2. Docker：
- `docker compose up -d --build panel` 成功

3. 运行态校验（DevTools）：
- Discord 缺 Token 时，结果区显示失败原因；
- Slack 模拟接口不可用时，结果区显示降级提示；
- 证据：`evidence/channel-discord-slack-4.3-live.md`。

## 与用户视角一致性

改造前：
- Discord/Slack 测试结果主要在全局时间线，不够直观；
- 接口异常时用户难以判断是“配置错”还是“接口不可用”。

改造后：
- 每个通道卡片都有自己的结果区；
- 失败原因在当前区域可读，用户不需要来回跳转排查。

## 结论

`4.3` 已完成并验证通过。渠道管理阶段（`4.1 ~ 4.3`）全部闭环。
</file>

<file path="plan/2026-02-16_ClawX源码调研/深挖报告_5.1_Skills列表与状态展示增强.md">
# 深挖报告 5.1：Skills 列表与状态展示增强

创建时间：2026-02-16

## 本轮目标

完成任务 `5.1`：完善 Skills 列表展示维度，确保用户可直接看到技能状态、说明与更新时间，满足“可管理 + 可理解”双目标。

## 实施范围

- 前后端：
  - `src/skills-service.js`
  - `public/app.js`
  - `public/index.html`
  - `test/unit/skills-service.test.js`
- 文档与证据：
  - `plan/2026-02-16_ClawX源码调研/任务清单.md`
  - `plan/2026-02-16_ClawX源码调研/规格变更/OpenClaw面板.md`
  - `plan/2026-02-16_ClawX源码调研/evidence/skills-list-status-5.1-live.md`

## 关键改动

### 1) Skills 服务层新增更新时间归一化

- `normalizeSkillItem()` 新增 `updatedAt` 字段归一化，兼容：
  - `updatedAt / updated_at / lastUpdatedAt / last_updated_at / mtime`
- 无可用值时为空字符串，由前端统一显示为 `无`。

### 2) Skills 列表展示新增“说明 + 最近更新”

- 每条 Skill 卡片新增：
  - `最近更新: ...`
  - `说明：...`
- 对缺失描述或更新时间的项，显式显示 `无`，避免用户误判为加载失败。

### 3) 单测补强

- `test/unit/skills-service.test.js` 增加 `updatedAt` 归一化断言，防止后续回归。

## 验证结果

1. 自动化：
- `node --check public/app.js` 通过
- `npm run test:unit` 通过（48/48）
- `npm run test:regression` 通过（3 pass / 1 skip）

2. Docker：
- `docker compose up -d --build panel` 成功

3. 运行态验证：
- `/skills` 页面可见“最近更新: 无”与“说明：...”字段；
- 证据：`evidence/skills-list-status-5.1-live.md`。

## 与用户视角一致性

改造前：
- Skills 可启停，但信息维度偏工程化，用户不易快速理解“这个技能是干啥的”。

改造后：
- 列表同时给状态 + 说明 + 更新时间，小白用户可以先理解再操作。

## 结论

`5.1` 已完成并通过验证。下一步进入 `5.2`：补齐高风险技能动作的二次确认交互。
</file>

<file path="plan/2026-02-16_ClawX源码调研/深挖报告_5.2_Skills启停二次确认交互.md">
# 深挖报告 5.2：Skills 启停二次确认交互

创建时间：2026-02-16

## 本轮目标

完成任务 `5.2`：为 Skills 启停动作增加必要确认交互，确保高风险操作不会被误触直接生效。

## 实施范围

- 前端：
  - `public/app.js`
- 文档与证据：
  - `plan/2026-02-16_ClawX源码调研/任务清单.md`
  - `plan/2026-02-16_ClawX源码调研/规格变更/OpenClaw面板.md`
  - `plan/2026-02-16_ClawX源码调研/evidence/skills-toggle-confirm-5.2-live.md`

## 关键改动

### 1) 新增启停确认逻辑

- 新增 `confirmSkillToggle(skill, nextEnabled)`：
  - 禁用已启用 Skill：强制弹窗确认；
  - 启用但存在限制（白名单阻塞/环境不满足）：弹窗提示后确认。

### 2) 取消操作短路处理

- 用户点击“取消”时：
  - 直接中止请求；
  - 记录 `已取消 Skill 操作` 的时间线提示；
  - 不触发 `/api/skills/:skillKey/enabled` 请求。

## 验证结果

1. 自动化：
- `node --check public/app.js` 通过
- `npm run test:unit` 通过（48/48）
- `npm run test:regression` 通过（3 pass / 1 skip）

2. Docker：
- `docker compose up -d --build panel` 成功

3. 运行态确认：
- DevTools 验证“禁用 Skill -> 弹确认 -> 取消后不发请求”链路成立；
- 证据：`evidence/skills-toggle-confirm-5.2-live.md`。

## 与用户视角一致性

改造前：
- 点击“禁用”会直接执行，误触风险高。

改造后：
- 高风险动作必须二次确认，用户可及时撤销。

## 结论

`5.2` 已完成并通过验证。下一步进入 `5.3`：补 Skills 配置写回校验与失败回滚提示。
</file>

<file path="plan/2026-02-16_ClawX源码调研/深挖报告_5.3_Skills配置写回与校验回滚.md">
# 深挖报告 5.3：Skills 配置写回与校验回滚

创建时间：2026-02-16

## 本轮目标

完成任务 `5.3`：为 Skills 页面补齐“配置写回”入口，并在后端实现“写入后校验 + 失败自动回滚”的闭环。

## 实施范围

- 后端：
  - `src/skills-service.js`
  - `src/server.js`
- 前端：
  - `public/index.html`
  - `public/app.js`
- 测试：
  - `test/unit/skills-service.test.js`
- 文档与证据：
  - `plan/2026-02-16_ClawX源码调研/任务清单.md`
  - `plan/2026-02-16_ClawX源码调研/规格变更/OpenClaw面板.md`
  - `plan/2026-02-16_ClawX源码调研/evidence/skills-config-writeback-5.3-live.md`

## 根因与改造点

### 1) 根因：Skills 页只有“查看/启停”，缺“可控写回”

- 现状只能读配置和启停 Skill；
- 用户无法在控制台内直接维护 `skills.entries.<skillKey>` 的 `enabled/apiKey/env`；
- 一旦需要写回，只能手工改 JSON，风险高、门槛高。

### 2) 后端新增写回链路（含校验回滚）

- 在 `skills-service` 新增 `prepareSkillConfigUpdate(...)`：
  - 先做 `skills.status` 存在性校验，拦截未知 `skillKey`；
  - 只按 patch 改动字段，未填写字段保持不变；
  - 支持 `clearApiKey` 与 `env` 的增删（`KEY=` 删除）。
- 在 `server` 新增 `PUT /api/skills/:skillKey/config`：
  - payload 校验：至少一个可写字段，禁止 `clearApiKey + apiKey` 同时提交；
  - 调用 `saveOpenClawConfig` 写盘后，立即读取并做字段级回读校验；
  - 校验失败时自动用备份文件回滚，并返回明确错误原因。

### 3) 前端新增写回入口（面向小白）

- 在 Skills 页新增“Skill 配置写回”卡片：
  - 启用状态下拉（保持不变/启用/禁用）
  - API Key 输入（留空不改）
  - 清除 API Key 勾选
  - 环境变量补丁（每行 `KEY=VALUE`，`KEY=` 删除）
- 写回结果就地显示（成功/失败），并自动刷新列表与配置预览。

## 验证结果

1. 自动化：
- `node --check public/app.js` 通过
- `node --check src/server.js` 通过
- `npm run test:unit` 通过（51/51）
- `npm run test:regression` 通过（3 pass / 1 skip）

2. Docker：
- `docker compose up -d --build panel` 成功

3. 运行态：
- `PUT /api/skills/:skillKey/config` 真实写回成功；
- `KEY=` 删除 env 键生效；
- 页面可见“Skill 配置写回”完整表单；
- 证据见 `evidence/skills-config-writeback-5.3-live.md`。

## 与用户视角一致性

改造前：
- 小白用户只能看 Skill 配置，改配置得离开控制台手工改文件。

改造后：
- 用户在 Skills 页就能按表单改最常见字段；
- 错误会直接告诉用户“哪一步错了”，不会静默失败；
- 后端写后校验失败会自动回滚，避免把配置文件写坏。

## 结论

`5.3` 已完成并通过验证。Skills 管理从“可视化查看 + 启停”升级为“可视化查看 + 启停 + 安全写回闭环”。下一步可进入 `7.x` 回归验证阶段。
</file>

<file path="plan/2026-02-16_ClawX源码调研/深挖报告_7.1_自动化测试补齐.md">
# 深挖报告 7.1：自动化测试补齐

创建时间：2026-02-16

## 本轮目标

完成任务 `7.1`：在当前主线改造基础上，跑通自动化测试并形成可追溯证据。

## 实施范围

- 执行动作：
  - `node --check public/app.js`
  - `node --check src/server.js`
  - `npm run test:unit`
  - `npm run test:regression`
  - `npm run test`
- 文档与证据：
  - `plan/2026-02-16_ClawX源码调研/任务清单.md`
  - `plan/2026-02-16_ClawX源码调研/evidence/test-automation-7.1-live.md`

## 验证结果

1. 语法检查：通过
2. 单元测试：`51/51` 通过
3. 回归测试：`3 pass / 1 skip`（跳过项为已知 docker pull 失败场景）
4. 聚合命令：`npm run test` 通过

## 风险说明

- 回归集中存在 1 条跳过用例（外部镜像拉取失败路径），属于既有测试策略，不是本轮新增风险。
- 当前结果仅证明自动化层稳定；仍需执行 `7.2` 手工关键路径回放与 `7.3/7.4` Docker/Linux 场景验证。

## 结论

`7.1` 已完成，可进入下一步 `7.2` 手工回放关键路径。
</file>

<file path="plan/2026-02-16_ClawX源码调研/深挖报告_7.2_关键路径手工回放.md">
# 深挖报告 7.2：关键路径手工回放

创建时间：2026-02-16

## 本轮目标

完成任务 `7.2`：对“模型、渠道、Skills、日志、更新、智能对话”进行一轮端到端手工回放，确认自动化之外的真实链路可用性。

## 实施范围

- 接口回放：
  - 模型/渠道：`GET/PUT /api/settings`
  - Skills：`GET /api/skills/status`、`GET /api/skills/:skillKey/config`、`POST /api/skills/:skillKey/enabled`
  - 运行态：`POST /api/service/status`、`GET /api/logs/tail`、`GET /api/logs/errors`
  - 更新：`GET /api/update/check`
  - 智能对话：`GET /api/chat/sessions`、`GET /api/chat/history`、`POST /api/chat/send`、`POST /api/chat/abort`
- 文档与证据：
  - `plan/2026-02-16_ClawX源码调研/任务清单.md`
  - `plan/2026-02-16_ClawX源码调研/evidence/manual-replay-7.2-live.md`

## 验证结果

1. 模型/渠道写回：成功（`/api/settings` 返回 `ok=true`）
2. Skills 读写链路：成功（状态读取、配置读取、启停写回均正常）
3. 服务与日志：成功（服务状态可读，tail/errors 可拉取）
4. 更新检查：成功（可读当前与最新 tag）
5. 智能对话：成功（会话读取、历史读取、发送、中止接口均可调用）

## 风险与观察

- 智能对话 `abort` 在运行已结束时可能返回 `aborted=false`，这是当前网关行为，不是接口异常。
- 当前回放样例中渠道开关均为 `false`，后续如需验证 Telegram/Feishu 真正连通性，需在生产凭据环境补测。

## 结论

`7.2` 已完成，当前主线关键路径可用。下一步进入 `7.3` Docker 场景稳定性验证。
</file>

<file path="plan/2026-02-16_ClawX源码调研/深挖报告_7.3_Docker场景稳定性验证.md">
# 深挖报告 7.3：Docker 场景稳定性验证

创建时间：2026-02-16

## 本轮目标

完成任务 `7.3`：验证面板在 Docker 场景下重启后，配置与核心功能是否保持一致。

## 实施范围

- 运行态动作：
  - `docker compose restart panel`
  - 重启前后比对：`/api/settings`、`/api/skills/status`
  - 恢复后 smoke：`/api/dashboard/summary`、`/api/chat/sessions`、`/api/logs/tail`
- 文档与证据：
  - `plan/2026-02-16_ClawX源码调研/任务清单.md`
  - `plan/2026-02-16_ClawX源码调研/evidence/docker-stability-7.3-live.md`

## 验证结果

1. 健康恢复：通过（`/api/health` 重启后恢复）
2. 配置一致性：通过（模型主引用/提供商/模型 ID/渠道开关/skills 总数一致）
3. 功能 smoke：通过（Dashboard/Chat/Logs 均可达）

## 风险与说明

- 本轮覆盖“容器重启恢复”场景，未覆盖“跨版本升级回滚”场景（该能力已由回归测试 `docker-update-flow` 覆盖一部分）。
- Linux 生产环境仍需做同等流程复验（任务 `7.4`）。

## 结论

`7.3` 已完成，当前 Docker 运行态满足“重启后配置与功能保持一致”的验收要求。下一步进入 `7.4` Linux 生产环境回归验证。
</file>

<file path="plan/2026-02-16_ClawX源码调研/提案.md">
# ClawX 能力迁移（插件式控制台）

创建时间：2026-02-16 21:10:00

## 为什么做
- 当前控制台已经覆盖模型、渠道、更新、日志，但在“状态总览、技能管理、聊天交互能力”上仍有体验和能力缺口。
- `third_party/ClawX` 已验证一套成熟的 OpenClaw 可视化交互逻辑，可作为能力来源；但其实现依赖 Electron，不适合直接照搬到当前 Web + Docker 架构。
- 本次目标不是“克隆一个 ClawX 桌面端”，而是将高价值能力按插件式控制器架构迁移到现有面板，确保长期可维护。

## 改什么
- 建立完整迁移文档体系（提案、任务清单、技术设计、规格变更、六份规格最小集）。
- 明确迁移边界并分批实施：
  - 迁移：状态总览补齐、Skills 管理、Chat 的多会话/流式/思考状态能力（按主聊天页体验落地）、提供商与更新能力增强。
  - 保留并增强：模型与提供商配置页、仪表盘、渠道配置页。
  - 不迁移：首次安装向导、任务调度（Cron）、主题系统。
- 先完成“深挖门禁项”再编码，避免盲目复制导致接口与结构失配。

## 影响范围
- 涉及模块（规划中）：`src/server.js`、`src/openclaw-config.js`、`src/logs.js`、新增 `src/gateway-*` 适配层、`public/app.js`、`public/index.html`、`public/styles.css`。
- 涉及页面：`/dashboard`、`/model`、`/channels`、`/chat-console`（由调试控制台升级为“智能对话”主聊天页体验）。
- 涉及配置：`openclaw.json`、`panel.config.json`，以及可能新增的聊天会话缓存字段（仅面板侧）。
- 部署约束：生产为“母机单公网 IP + 分配端口”模式，所有对外端口与外部地址必须配置化，容器内通信走内部网络。
- 风险等级：L2（跨模块、涉及实时流和配置写入链路）。

## 不做什么（边界）
- 不改龙虾 Bot/OpenClaw 源码本体，不将控制台做成 OpenClaw 分叉版本。
- 不迁移 Electron 专属能力：托盘、桌面窗口、系统菜单、auto-updater。
- 不把“聊天能力增强”强耦合到现有配置页；必须通过独立后端适配层和独立前端模块接入。
- 不把聊天页继续做成“只给工程师看的调试窗口”；默认交互必须面向小白用户。
- 不为追求速度跳过结构设计、接口契约、回归验证。

## 待深挖清单（编码前门禁）
- Gateway RPC 支持矩阵：`sessions.list`、`chat.history`、`chat.send`、`chat.abort`、`skills.status`、`skills.update` 在当前 Docker 运行态的可用性与超时行为。
- 流式事件链路：SSE/WS 二选一的稳定性、断线重连策略、前端幂等去重策略。
- Skills 管理边界：哪些能力可由当前面板进程安全执行，哪些必须通过 gateway 代理执行。
- 渠道管理归属确认：渠道页面继续只管理 OpenClaw 实际渠道配置，不引入面板私有“虚拟渠道”概念。
- 安全边界：API Key 与敏感日志展示策略、外网访问约束、Docker socket 暴露风险缓解。

## 验证（存在风险时必填）
- 文档验收：任务顺序、契约、边界、回滚策略必须可追溯并经用户确认。
- 技术验收：完成深挖门禁后，先提交接口可行性报告，再进入编码。
- 实施验收：每阶段必须提供至少一类证据（自动化测试、脚本输出、手工回放）。

## 回滚（存在风险时必填）
- 回滚触发条件：关键接口不可用、配置写入破坏现有功能、流式通道不稳定导致面板不可用。
- 回滚步骤：
  1. 关闭新增功能入口（功能开关或路由回退）。
  2. 还原接口调用路径到现有稳定实现。
  3. 恢复上一版本文档定义并重新评审方案。
</file>

<file path="plan/2026-02-16_ClawX源码调研/evidence/channel-discord-slack-4.3-live.md">
# 4.3 运行态证据：Discord/Slack 状态展示与优雅降级

时间：2026-02-16

## 1) 页面能力校验

`/channels` 页面新增：

- `dc_test_result`（Discord 最近测试状态）
- `sl_test_result`（Slack 最近测试状态）

## 2) 交互校验（Chrome DevTools MCP）

执行脚本返回：

```json
{
  "ok": true,
  "discordValidationText": "最近测试（18:09:17）：失败 - 接口不可用或测试失败：Discord 测试失败：Bot Token 不能为空",
  "slackDegradeText": "最近测试（18:09:18）：失败 - 接口不可用或测试失败：mock slack endpoint unavailable",
  "discordValidationWorks": true,
  "slackDegradeWorks": true
}
```

结论：
- Discord 在缺少 Token 时会给出页面内失败状态，不会静默失败；
- Slack 接口不可用时会优雅降级到页面状态提示，不会导致页面异常崩溃。

## 3) 自动化验证

命令：

```powershell
node --check public/app.js
npm run test:unit
npm run test:regression
```

结果：
- `node --check` 通过
- `test:unit`：48/48 通过
- `test:regression`：3 通过，1 跳过

## 4) Docker 验证

命令：

```powershell
docker compose up -d --build panel
```

结果：
- `openclaw-panel:local` 构建成功
- `openclaw-panel` 重建并启动成功
</file>

<file path="plan/2026-02-16_ClawX源码调研/evidence/channel-save-test-loop-4.2-live.md">
# 4.2 运行态证据：Telegram/Feishu 保存+测试闭环

时间：2026-02-16

## 1) 页面能力校验

`/channels` 页面新增：

- `save_and_test_telegram`（保存并测试 Telegram）
- `save_and_test_feishu`（保存并测试 Feishu）
- `tg_test_result` / `fs_test_result`（最近测试结果）

## 2) 交互闭环校验（Chrome DevTools MCP，mock 网络）

### 2.1 Telegram 保存并测试

脚本返回：

```json
{
  "ok": true,
  "called": [
    "PUT /api/settings",
    "GET /api/panel-config",
    "GET /api/settings",
    "POST /api/test/telegram"
  ],
  "resultText": "最近测试（18:06:16）：成功 - mock telegram ok",
  "hasSaveAndTestChain": true
}
```

### 2.2 Feishu 保存并测试

脚本返回：

```json
{
  "ok": true,
  "called": [
    "PUT /api/settings",
    "GET /api/panel-config",
    "GET /api/settings",
    "POST /api/test/feishu"
  ],
  "resultText": "最近测试（18:06:29）：成功 - mock feishu ok",
  "hasSaveAndTestChain": true
}
```

结论：
- 两个通道都已形成“保存配置 -> 回填凭证 -> 连通性测试 -> 可见结果”的可复现闭环。

## 3) 自动化验证

命令：

```powershell
node --check public/app.js
npm run test:unit
npm run test:regression
```

结果：
- `node --check` 通过
- `test:unit`：48/48 通过
- `test:regression`：3 通过，1 跳过

## 4) Docker 验证

命令：

```powershell
docker compose up -d --build panel
```

结果：
- `openclaw-panel:local` 构建成功
- `openclaw-panel` 重建并启动成功
</file>

<file path="plan/2026-02-16_ClawX源码调研/evidence/channel-scope-4.1-live.md">
# 4.1 运行态证据：仅管理 OpenClaw 真实渠道

时间：2026-02-16

## 1) 页面文案与范围校验

命令：

```powershell
Invoke-WebRequest -UseBasicParsing -Uri http://127.0.0.1:18080/channels
```

关键文案命中：

- `渠道配置保存（仅 OpenClaw 真实渠道）`
- `不会创建任何面板私有“虚拟渠道”`
- `保存渠道配置`

结论：
- 页面已明确声明仅管理 OpenClaw 真实渠道（telegram/feishu/discord/slack）。

## 2) 自动化验证

命令：

```powershell
node --check public/app.js
npm run test:unit
npm run test:regression
```

结果：
- `node --check` 通过
- `test:unit`：48/48 通过
- `test:regression`：3 通过，1 跳过

## 3) Docker 验证

命令：

```powershell
docker compose up -d --build panel
```

结果：
- `openclaw-panel:local` 构建成功
- `openclaw-panel` 重建并启动成功
</file>

<file path="plan/2026-02-16_ClawX源码调研/evidence/chat-attachments-live.json">
{
  "health": {
    "ok": true,
    "service": "openclaw-panel",
    "timestamp": "2026-02-16T08:42:32.337Z"
  },
  "session": {
    "ok": true,
    "result": {
      "key": "agent:main:session-1771231352502-5f93297c",
      "entry": {
        "sessionId": "a6537a5f-e7b0-4c06-803a-780e055a18a8",
        "updatedAt": 1771231352643,
        "systemSent": false,
        "abortedLastRun": false,
        "inputTokens": 0,
        "outputTokens": 0,
        "totalTokens": 0,
        "totalTokensFresh": true
      }
    }
  },
  "staged": {
    "ok": true,
    "result": {
      "id": "8b563052-3fae-4589-aaa0-ba377b7a55f1",
      "fileName": "note.txt",
      "mimeType": "text/plain",
      "fileSize": 15,
      "stagedPath": "/data/openclaw/media/outbound/8b563052-3fae-4589-aaa0-ba377b7a55f1.txt",
      "preview": null
    }
  },
  "sent": {
    "ok": true,
    "result": {
      "sessionKey": "agent:main:session-1771231352502-5f93297c",
      "runId": "b65a4983-a8ce-48c0-9c13-b9db0ed1dff5",
      "status": "started",
      "idempotencyKey": "b65a4983-a8ce-48c0-9c13-b9db0ed1dff5"
    }
  }
}
</file>

<file path="plan/2026-02-16_ClawX源码调研/evidence/chat-attachments-pathmap-live.json">
{
  "session": {
    "ok": true,
    "result": {
      "key": "agent:main:session-1771231535668-5a3c1e4b",
      "entry": {
        "sessionId": "16752fc1-6014-4f39-9b04-8cb6ab31676b",
        "updatedAt": 1771231535816,
        "systemSent": false,
        "abortedLastRun": false,
        "inputTokens": 0,
        "outputTokens": 0,
        "totalTokens": 0,
        "totalTokensFresh": true
      }
    }
  },
  "staged": {
    "ok": true,
    "result": {
      "id": "e6b71e16-3385-4d7a-9da4-62c3b36df10e",
      "fileName": "map-test-2.txt",
      "mimeType": "text/plain",
      "fileSize": 26,
      "stagedPath": "/data/openclaw/media/outbound/e6b71e16-3385-4d7a-9da4-62c3b36df10e.txt",
      "preview": null
    }
  },
  "sent": {
    "ok": true,
    "result": {
      "sessionKey": "agent:main:session-1771231535668-5a3c1e4b",
      "runId": "437f1bf8-a806-4094-8ab9-387d9f0fa2a9",
      "status": "started",
      "idempotencyKey": "437f1bf8-a806-4094-8ab9-387d9f0fa2a9"
    }
  },
  "history": {
    "ok": true,
    "result": {
      "sessionKey": "agent:main:session-1771231535668-5a3c1e4b",
      "sessionId": "16752fc1-6014-4f39-9b04-8cb6ab31676b",
      "thinkingLevel": "off",
      "verboseLevel": "",
      "messages": [
        {
          "role": "user",
          "content": [
            {
              "type": "text",
              "text": "Conversation info (untrusted metadata):\n```json\n{\n  \"conversation_label\": \"openclaw-panel\"\n}\n```\n\n[Mon 2026-02-16 08:45 UTC] 读取附件并只回复ok [media attached: /home/node/.openclaw/media/outbound/e6b71e16-3385-4d7a-9da4-62c3b36df10e.txt (text/plain) | /home/node/.openclaw/media/outbound/e6b71e16-3385-4d7a-9da4-62c3b36df10e.txt]"
            }
          ],
          "timestamp": 1771231536742
        },
        {
          "role": "assistant",
          "content": [
            {
              "type": "toolCall",
              "id": "call_cZKP9r8ICVTnNOvnWtU1s8Hu|fc_02d30d43fcfb303f016992d9320df481958fdd92c127be9e85",
              "name": "read",
              "arguments": {
                "file_path": "/home/node/.openclaw/media/outbound/e6b71e16-3385-4d7a-9da4-62c3b36df10e.txt"
              },
              "partialJson": "{\"file_path\":\"/home/node/.openclaw/media/outbound/e6b71e16-3385-4d7a-9da4-62c3b36df10e.txt\"}"
            }
          ],
          "api": "openai-responses",
          "provider": "aicodecat-gpt",
          "model": "gpt-5.2",
          "usage": {
            "input": 205,
            "output": 55,
            "cacheRead": 11520,
            "cacheWrite": 0,
            "totalTokens": 11780,
            "cost": {
              "input": 0.00035875,
              "output": 0.00077,
              "cacheRead": 0.002016,
              "cacheWrite": 0,
              "total": 0.00314475
            }
          },
          "stopReason": "toolUse",
          "timestamp": 1771231536762
        },
        {
          "role": "toolResult",
          "toolCallId": "call_cZKP9r8ICVTnNOvnWtU1s8Hu|fc_02d30d43fcfb303f016992d9320df481958fdd92c127be9e85",
          "toolName": "read",
          "content": [
            {
              "type": "text",
              "text": "attachment-path-map-test-2"
            }
          ],
          "isError": false,
          "timestamp": 1771231539286
        },
        {
          "role": "assistant",
          "content": [
            {
              "type": "text",
              "text": "ok",
              "textSignature": "msg_02d30d43fcfb303f016992d934c7348195aed17900ac9f41f9"
            }
          ],
          "api": "openai-responses",
          "provider": "aicodecat-gpt",
          "model": "gpt-5.2",
          "usage": {
            "input": 273,
            "output": 5,
            "cacheRead": 11520,
            "cacheWrite": 0,
            "totalTokens": 11798,
            "cost": {
              "input": 0.00047775,
              "output": 7E-05,
              "cacheRead": 0.002016,
              "cacheWrite": 0,
              "total": 0.00256375
            }
          },
          "stopReason": "stop",
          "timestamp": 1771231539316
        }
      ]
    }
  }
}
</file>

<file path="plan/2026-02-16_ClawX源码调研/evidence/chat-attachments-ui-live.md">
# Chat 附件链路联调证据

时间：2026-02-16

## 验证目标
验证“点击上传/粘贴/拖拽 -> 附件落盘 -> 发送 -> 网关读取”闭环。

## 关键结果
1. `POST /api/chat/attachments/stage` 成功，返回 `stagedPath=/data/openclaw/media/outbound/*.txt`。
2. `POST /api/chat/send` 请求体包含附件数组（`fileName/mimeType/fileSize/stagedPath`）。
3. 发送前会把面板本地路径映射为网关可见路径：
   - 本地：`/data/openclaw/media/outbound/...`
   - 网关：`/home/node/.openclaw/media/outbound/...`
4. 网关工具成功读取附件内容并回复 `ok`（无 `ENOENT/EACCES`）。

## 浏览器页面验证
- 页面：`/chat-console`
- 操作：点击“添加附件”上传 `attachment-ui-test.txt`
- 结果：页面出现附件卡片（文件名、类型、大小、移除按钮），发送后历史消息可见附件引用。

## 证据文件
- `chat-attachments-live.json`
- `chat-attachments-pathmap-live.json`
- DevTools network req `POST /api/chat/send`（请求体含附件字段）
</file>

<file path="plan/2026-02-16_ClawX源码调研/evidence/chat-rich-render-inlinehint-live.md">
# Chat 富渲染与内联提示运行态证据

时间：2026-02-16 16:54:14

## 验证目标

1. 智能对话页面包含聊天内联提示区域；
2. 前端脚本包含消息富渲染和动作错误提示逻辑；
3. 样式包含代码块与内联提示状态样式；
4. 变更在 Docker 重建后可用。

## 执行记录

1. 自动化验证
```bash
npm run test:unit
npm run test:regression
```
结果：通过（`test:unit` 48/48；`test:regression` 3 passed, 1 skipped）。

2. Docker 重建
```bash
docker compose up -d --build panel
```
结果：`openclaw-panel` 重建并启动成功。

3. 页面结构验证
```powershell
$html=(Invoke-WebRequest -UseBasicParsing http://127.0.0.1:18080/chat-console).Content
$html -match 'chat_inline_hint'
```
结果：`chat_inline_hint:OK`

4. 前端脚本关键逻辑验证
```powershell
$js=(Invoke-WebRequest -UseBasicParsing http://127.0.0.1:18080/app.js).Content
```
检查项结果：
- `renderRichMessageBody` -> OK
- `reportChatActionError` -> OK
- `[工具调用]` -> OK
- `[工具结果]` -> OK

5. 样式规则验证
```powershell
$css=(Invoke-WebRequest -UseBasicParsing http://127.0.0.1:18080/styles.css).Content
```
检查项结果：
- `.chat-inline-hint.error` -> OK
- `.chat-message-body .chat-code` -> OK

## 结论

`6.8` 的“消息富渲染 + 局部错误提示”已在 Docker 运行态生效，且不影响现有测试基线。
</file>

<file path="plan/2026-02-16_ClawX源码调研/evidence/chat-service-live.json">
{
  "sessionsOk": true,
  "historyOk": true,
  "sessionsTotal": 16,
  "abortAborted": true,
  "sendOk": true,
  "historyCount": 0,
  "resetOk": true,
  "abortOk": true,
  "endpoints": {
    "abort": "/api/chat/abort",
    "sessions": "/api/chat/sessions",
    "send": "/api/chat/send",
    "reset": "/api/chat/session/reset",
    "history": "/api/chat/history"
  },
  "sendRunId": "1703d082-1d08-47a8-91ec-0b0cf062962a",
  "testedAt": "2026-02-16 15:19:29 +08:00",
  "resetKey": "agent:main:panel-chat-service-api-probe"
}
</file>

<file path="plan/2026-02-16_ClawX源码调研/evidence/chat-session-new-live.json">
{"ok":true,"result":{"key":"agent:main:session-1771230512831-b8c5cf35","entry":{"sessionId":"560fa7db-55a7-4528-8e0a-8f8461681625","updatedAt":1771230512972,"systemSent":false,"abortedLastRun":false,"inputTokens":0,"outputTokens":0,"totalTokens":0,"totalTokensFresh":true}}}
</file>

<file path="plan/2026-02-16_ClawX源码调研/evidence/chat-stream-event-probe-live.json">
{
  "startedAt": "2026-02-16T05:36:47.181Z",
  "finishedAt": "2026-02-16T05:36:55.184Z",
  "wsUrl": "ws://127.0.0.1:18789/ws",
  "probeId": "panel-stream-probe-1771220207181",
  "sessionKey": "agent:main:panel-stream-probe-1771220207181",
  "clientDistFile": "client-B5KEYk4h.js",
  "hello": {
    "type": "hello-ok",
    "protocol": 3,
    "server": {
      "version": "dev",
      "host": "3fdf9e7221c0",
      "connId": "81a6a324-4428-4e09-afcc-c9d02cece6b4"
    },
    "features": {
      "methods": [
        "health",
        "logs.tail",
        "channels.status",
        "channels.logout",
        "status",
        "usage.status",
        "usage.cost",
        "tts.status",
        "tts.providers",
        "tts.enable",
        "tts.disable",
        "tts.convert",
        "tts.setProvider",
        "config.get",
        "config.set",
        "config.apply",
        "config.patch",
        "config.schema",
        "exec.approvals.get",
        "exec.approvals.set",
        "exec.approvals.node.get",
        "exec.approvals.node.set",
        "exec.approval.request",
        "exec.approval.waitDecision",
        "exec.approval.resolve",
        "wizard.start",
        "wizard.next",
        "wizard.cancel",
        "wizard.status",
        "talk.config",
        "talk.mode",
        "models.list",
        "agents.list",
        "agents.create",
        "agents.update",
        "agents.delete",
        "agents.files.list",
        "agents.files.get",
        "agents.files.set",
        "skills.status",
        "skills.bins",
        "skills.install",
        "skills.update",
        "update.run",
        "voicewake.get",
        "voicewake.set",
        "sessions.list",
        "sessions.preview",
        "sessions.patch",
        "sessions.reset",
        "sessions.delete",
        "sessions.compact",
        "last-heartbeat",
        "set-heartbeats",
        "wake",
        "node.pair.request",
        "node.pair.list",
        "node.pair.approve",
        "node.pair.reject",
        "node.pair.verify",
        "device.pair.list",
        "device.pair.approve",
        "device.pair.reject",
        "device.token.rotate",
        "device.token.revoke",
        "node.rename",
        "node.list",
        "node.describe",
        "node.invoke",
        "node.invoke.result",
        "node.event",
        "cron.list",
        "cron.status",
        "cron.add",
        "cron.update",
        "cron.remove",
        "cron.run",
        "cron.runs",
        "system-presence",
        "system-event",
        "send",
        "agent",
        "agent.identity.get",
        "agent.wait",
        "browser.request",
        "chat.history",
        "chat.abort",
        "chat.send"
      ],
      "events": [
        "connect.challenge",
        "agent",
        "chat",
        "presence",
        "tick",
        "talk.mode",
        "shutdown",
        "health",
        "heartbeat",
        "cron",
        "node.pair.requested",
        "node.pair.resolved",
        "node.invoke.request",
        "device.pair.requested",
        "device.pair.resolved",
        "voicewake.changed",
        "exec.approval.requested",
        "exec.approval.resolved"
      ]
    },
    "snapshot": {
      "presence": [
        {
          "host": "3fdf9e7221c0",
          "ip": "172.21.0.2",
          "version": "unknown",
          "platform": "linux 5.15.167.4-microsoft-standard-WSL2",
          "deviceFamily": "Linux",
          "modelIdentifier": "x64",
          "mode": "gateway",
          "reason": "self",
          "text": "Gateway: 3fdf9e7221c0 (172.21.0.2) · app unknown · mode gateway · reason self",
          "ts": 1771220207477
        }
      ],
      "health": {
        "ok": true,
        "ts": 1771220154130,
        "durationMs": 0,
        "channels": {},
        "channelOrder": [],
        "channelLabels": {},
        "heartbeatSeconds": 1800,
        "defaultAgentId": "main",
        "agents": [
          {
            "agentId": "main",
            "isDefault": true,
            "heartbeat": {
              "enabled": true,
              "every": "30m",
              "everyMs": 1800000,
              "prompt": "Read HEARTBEAT.md if it exists (workspace context). Follow it strictly. Do not infer or repeat old tasks from prior chats. If nothing needs attention, reply HEARTBEAT_OK.",
              "target": "last",
              "ackMaxChars": 300
            },
            "sessions": {
              "path": "/home/node/.openclaw/agents/main/sessions/sessions.json",
              "count": 11,
              "recent": [
                {
                  "key": "agent:main:panel-stream-abort-1771220040840",
                  "updatedAt": 1771220041435,
                  "age": 112695
                },
                {
                  "key": "agent:main:panel-stream-probe-config-error-1771220021125",
                  "updatedAt": 1771220024782,
                  "age": 129348
                },
                {
                  "key": "agent:main:panel-stream-probe-force-error-1771219989545",
                  "updatedAt": 1771219993304,
                  "age": 160826
                },
                {
                  "key": "agent:main:panel-stream-probe-timeout-1771219935181",
                  "updatedAt": 1771219943170,
                  "age": 210960
                },
                {
                  "key": "agent:main:panel-stream-probe-error-1771219915722",
                  "updatedAt": 1771219919467,
                  "age": 234663
                }
              ]
            }
          }
        ],
        "sessions": {
          "path": "/home/node/.openclaw/agents/main/sessions/sessions.json",
          "count": 11,
          "recent": [
            {
              "key": "agent:main:panel-stream-abort-1771220040840",
              "updatedAt": 1771220041435,
              "age": 112695
            },
            {
              "key": "agent:main:panel-stream-probe-config-error-1771220021125",
              "updatedAt": 1771220024782,
              "age": 129348
            },
            {
              "key": "agent:main:panel-stream-probe-force-error-1771219989545",
              "updatedAt": 1771219993304,
              "age": 160826
            },
            {
              "key": "agent:main:panel-stream-probe-timeout-1771219935181",
              "updatedAt": 1771219943170,
              "age": 210960
            },
            {
              "key": "agent:main:panel-stream-probe-error-1771219915722",
              "updatedAt": 1771219919467,
              "age": 234663
            }
          ]
        }
      },
      "stateVersion": {
        "presence": 1,
        "health": 828
      },
      "uptimeMs": 45675507,
      "configPath": "/home/node/.openclaw/openclaw.json",
      "stateDir": "/home/node/.openclaw",
      "sessionDefaults": {
        "defaultAgentId": "main",
        "mainKey": "main",
        "mainSessionKey": "agent:main:main",
        "scope": "per-sender"
      },
      "authMode": "token"
    },
    "canvasHostUrl": "http://127.0.0.1:18789",
    "auth": {
      "deviceToken": "uVkW2idRtbd2z2lBYyAF9QuM_Er9W79ib7TwWbqv0mA",
      "role": "operator",
      "scopes": [
        "operator.admin",
        "operator.approvals",
        "operator.pairing"
      ],
      "issuedAtMs": 1771219284921
    },
    "policy": {
      "maxPayload": 8388608,
      "maxBufferedBytes": 16777216,
      "tickIntervalMs": 30000
    }
  },
  "connected": true,
  "lastClose": null,
  "scenarios": {
    "normal": {
      "runId": "panel-stream-probe-1771220207181-normal",
      "ack": {
        "runId": "panel-stream-probe-1771220207181-normal",
        "status": "started"
      },
      "states": [
        "delta",
        "delta",
        "delta",
        "delta",
        "delta",
        "delta",
        "delta",
        "delta",
        "delta",
        "delta",
        "delta",
        "delta",
        "delta",
        "delta",
        "delta",
        "final"
      ],
      "terminal": {
        "timeout": false,
        "terminalState": "final",
        "terminalAtMs": 1771220212480
      },
      "events": [
        {
          "atMs": 1771220209996,
          "runId": "panel-stream-probe-1771220207181-normal",
          "sessionKey": "agent:main:panel-stream-probe-1771220207181",
          "state": "delta",
          "seq": 2,
          "stopReason": null,
          "text": "我"
        },
        {
          "atMs": 1771220210150,
          "runId": "panel-stream-probe-1771220207181-normal",
          "sessionKey": "agent:main:panel-stream-probe-1771220207181",
          "state": "delta",
          "seq": 9,
          "stopReason": null,
          "text": "我是在 OpenClaw 里运行的"
        },
        {
          "atMs": 1771220210312,
          "runId": "panel-stream-probe-1771220207181-normal",
          "sessionKey": "agent:main:panel-stream-probe-1771220207181",
          "state": "delta",
          "seq": 18,
          "stopReason": null,
          "text": "我是在 OpenClaw 里运行的个人助理型 AI，也可以当作"
        },
        {
          "atMs": 1771220210481,
          "runId": "panel-stream-probe-1771220207181-normal",
          "sessionKey": "agent:main:panel-stream-probe-1771220207181",
          "state": "delta",
          "seq": 27,
          "stopReason": null,
          "text": "我是在 OpenClaw 里运行的个人助理型 AI，也可以当作很强的“编码搭子”：能"
        },
        {
          "atMs": 1771220210634,
          "runId": "panel-stream-probe-1771220207181-normal",
          "sessionKey": "agent:main:panel-stream-probe-1771220207181",
          "state": "delta",
          "seq": 36,
          "stopReason": null,
          "text": "我是在 OpenClaw 里运行的个人助理型 AI，也可以当作很强的“编码搭子”：能读写项目文件、跑命令、"
        },
        {
          "atMs": 1771220210791,
          "runId": "panel-stream-probe-1771220207181-normal",
          "sessionKey": "agent:main:panel-stream-probe-1771220207181",
          "state": "delta",
          "seq": 45,
          "stopReason": null,
          "text": "我是在 OpenClaw 里运行的个人助理型 AI，也可以当作很强的“编码搭子”：能读写项目文件、跑命令、排查报错、改代码、写"
        },
        {
          "atMs": 1771220210949,
          "runId": "panel-stream-probe-1771220207181-normal",
          "sessionKey": "agent:main:panel-stream-probe-1771220207181",
          "state": "delta",
          "seq": 54,
          "stopReason": null,
          "text": "我是在 OpenClaw 里运行的个人助理型 AI，也可以当作很强的“编码搭子”：能读写项目文件、跑命令、排查报错、改代码、写脚本、查资料，并把结果整理"
        },
        {
          "atMs": 1771220211106,
          "runId": "panel-stream-probe-1771220207181-normal",
          "sessionKey": "agent:main:panel-stream-probe-1771220207181",
          "state": "delta",
          "seq": 63,
          "stopReason": null,
          "text": "我是在 OpenClaw 里运行的个人助理型 AI，也可以当作很强的“编码搭子”：能读写项目文件、跑命令、排查报错、改代码、写脚本、查资料，并把结果整理成你能直接用的步骤或改"
        },
        {
          "atMs": 1771220211271,
          "runId": "panel-stream-probe-1771220207181-normal",
          "sessionKey": "agent:main:panel-stream-probe-1771220207181",
          "state": "delta",
          "seq": 71,
          "stopReason": null,
          "text": "我是在 OpenClaw 里运行的个人助理型 AI，也可以当作很强的“编码搭子”：能读写项目文件、跑命令、排查报错、改代码、写脚本、查资料，并把结果整理成你能直接用的步骤或改动说明。\n\n我偏向少废"
        },
        {
          "atMs": 1771220211424,
          "runId": "panel-stream-probe-1771220207181-normal",
          "sessionKey": "agent:main:panel-stream-probe-1771220207181",
          "state": "delta",
          "seq": 80,
          "stopReason": null,
          "text": "我是在 OpenClaw 里运行的个人助理型 AI，也可以当作很强的“编码搭子”：能读写项目文件、跑命令、排查报错、改代码、写脚本、查资料，并把结果整理成你能直接用的步骤或改动说明。\n\n我偏向少废话、先动手再汇报；"
        },
        {
          "atMs": 1771220211601,
          "runId": "panel-stream-probe-1771220207181-normal",
          "sessionKey": "agent:main:panel-stream-probe-1771220207181",
          "state": "delta",
          "seq": 89,
          "stopReason": null,
          "text": "我是在 OpenClaw 里运行的个人助理型 AI，也可以当作很强的“编码搭子”：能读写项目文件、跑命令、排查报错、改代码、写脚本、查资料，并把结果整理成你能直接用的步骤或改动说明。\n\n我偏向少废话、先动手再汇报；遇到会影响方向/安全的关键"
        },
        {
          "atMs": 1771220211757,
          "runId": "panel-stream-probe-1771220207181-normal",
          "sessionKey": "agent:main:panel-stream-probe-1771220207181",
          "state": "delta",
          "seq": 98,
          "stopReason": null,
          "text": "我是在 OpenClaw 里运行的个人助理型 AI，也可以当作很强的“编码搭子”：能读写项目文件、跑命令、排查报错、改代码、写脚本、查资料，并把结果整理成你能直接用的步骤或改动说明。\n\n我偏向少废话、先动手再汇报；遇到会影响方向/安全的关键歧义才会追问。你可以"
        },
        {
          "atMs": 1771220211923,
          "runId": "panel-stream-probe-1771220207181-normal",
          "sessionKey": "agent:main:panel-stream-probe-1771220207181",
          "state": "delta",
          "seq": 106,
          "stopReason": null,
          "text": "我是在 OpenClaw 里运行的个人助理型 AI，也可以当作很强的“编码搭子”：能读写项目文件、跑命令、排查报错、改代码、写脚本、查资料，并把结果整理成你能直接用的步骤或改动说明。\n\n我偏向少废话、先动手再汇报；遇到会影响方向/安全的关键歧义才会追问。你可以直接丢需求、报错日志、"
        },
        {
          "atMs": 1771220212073,
          "runId": "panel-stream-probe-1771220207181-normal",
          "sessionKey": "agent:main:panel-stream-probe-1771220207181",
          "state": "delta",
          "seq": 115,
          "stopReason": null,
          "text": "我是在 OpenClaw 里运行的个人助理型 AI，也可以当作很强的“编码搭子”：能读写项目文件、跑命令、排查报错、改代码、写脚本、查资料，并把结果整理成你能直接用的步骤或改动说明。\n\n我偏向少废话、先动手再汇报；遇到会影响方向/安全的关键歧义才会追问。你可以直接丢需求、报错日志、仓库路径或截图，我会尽量"
        },
        {
          "atMs": 1771220212230,
          "runId": "panel-stream-probe-1771220207181-normal",
          "sessionKey": "agent:main:panel-stream-probe-1771220207181",
          "state": "delta",
          "seq": 123,
          "stopReason": null,
          "text": "我是在 OpenClaw 里运行的个人助理型 AI，也可以当作很强的“编码搭子”：能读写项目文件、跑命令、排查报错、改代码、写脚本、查资料，并把结果整理成你能直接用的步骤或改动说明。\n\n我偏向少废话、先动手再汇报；遇到会影响方向/安全的关键歧义才会追问。你可以直接丢需求、报错日志、仓库路径或截图，我会尽量用最短路径把事情推进到"
        },
        {
          "atMs": 1771220212480,
          "runId": "panel-stream-probe-1771220207181-normal",
          "sessionKey": "agent:main:panel-stream-probe-1771220207181",
          "state": "final",
          "seq": 129,
          "stopReason": null,
          "text": "我是在 OpenClaw 里运行的个人助理型 AI，也可以当作很强的“编码搭子”：能读写项目文件、跑命令、排查报错、改代码、写脚本、查资料，并把结果整理成你能直接用的步骤或改动说明。\n\n我偏向少废话、先动手再汇报；遇到会影响方向/安全的关键歧义才会追问。你可以直接丢需求、报错日志、仓库路径或截图，我会尽量用最短路径把事情推进到可验证的结果。"
        }
      ]
    },
    "abort": {
      "runId": "panel-stream-probe-1771220207181-abort",
      "ack": {
        "runId": "panel-stream-probe-1771220207181-abort",
        "status": "started"
      },
      "abortRes": {
        "ok": true,
        "aborted": true,
        "runIds": [
          "panel-stream-probe-1771220207181-abort"
        ]
      },
      "states": [
        "aborted"
      ],
      "terminal": {
        "timeout": false,
        "terminalState": "aborted",
        "terminalAtMs": 1771220212999
      },
      "events": [
        {
          "atMs": 1771220212999,
          "runId": "panel-stream-probe-1771220207181-abort",
          "sessionKey": "agent:main:panel-stream-probe-1771220207181",
          "state": "aborted",
          "seq": 2,
          "stopReason": "rpc"
        }
      ]
    },
    "invalidRequest": {
      "runId": "panel-stream-probe-1771220207181-invalid",
      "ok": true,
      "error": "invalid chat.send params: must have required property 'message'"
    },
    "forcedRuntimeErrorAttempt": {
      "runId": "panel-stream-probe-1771220207181-forced-error",
      "patch": {
        "ok": true,
        "path": "/home/node/.openclaw/agents/main/sessions/sessions.json",
        "key": "agent:main:panel-stream-probe-1771220207181",
        "entry": {
          "sessionId": "2727320e-1716-40f1-a1a5-288c9771465c",
          "updatedAt": 1771220213083,
          "systemSent": true,
          "abortedLastRun": false,
          "chatType": "direct",
          "deliveryContext": {
            "channel": "webchat"
          },
          "lastChannel": "webchat",
          "origin": {
            "label": "panel-stream-probe",
            "provider": "webchat",
            "surface": "webchat",
            "chatType": "direct"
          },
          "sessionFile": "/home/node/.openclaw/agents/main/sessions/2727320e-1716-40f1-a1a5-288c9771465c.jsonl",
          "compactionCount": 0,
          "skillsSnapshot": {
            "prompt": "\n\nThe following skills provide specialized instructions for specific tasks.\nUse the read tool to load a skill's file when the task matches its description.\nWhen a skill file references a relative path, resolve it against the skill directory (parent of SKILL.md / dirname of the path) and use that absolute path in tool commands.\n\n<available_skills>\n  <skill>\n    <name>healthcheck</name>\n    <description>Host security hardening and risk-tolerance configuration for OpenClaw deployments. Use when a user asks for security audits, firewall/SSH/update hardening, risk posture, exposure review, OpenClaw cron scheduling for periodic checks, or version status checks on a machine running OpenClaw (laptop, workstation, Pi, VPS).</description>\n    <location>/app/skills/healthcheck/SKILL.md</location>\n  </skill>\n  <skill>\n    <name>skill-creator</name>\n    <description>Create or update AgentSkills. Use when designing, structuring, or packaging skills with scripts, references, and assets.</description>\n    <location>/app/skills/skill-creator/SKILL.md</location>\n  </skill>\n  <skill>\n    <name>slack</name>\n    <description>Use when you need to control Slack from OpenClaw via the slack tool, including reacting to messages or pinning/unpinning items in Slack channels or DMs.</description>\n    <location>/app/skills/slack/SKILL.md</location>\n  </skill>\n  <skill>\n    <name>weather</name>\n    <description>Get current weather and forecasts (no API key required).</description>\n    <location>/app/skills/weather/SKILL.md</location>\n  </skill>\n</available_skills>",
            "skills": [
              {
                "name": "healthcheck"
              },
              {
                "name": "skill-creator"
              },
              {
                "name": "slack"
              },
              {
                "name": "weather"
              }
            ],
            "resolvedSkills": [
              {
                "name": "healthcheck",
                "description": "Host security hardening and risk-tolerance configuration for OpenClaw deployments. Use when a user asks for security audits, firewall/SSH/update hardening, risk posture, exposure review, OpenClaw cron scheduling for periodic checks, or version status checks on a machine running OpenClaw (laptop, workstation, Pi, VPS).",
                "filePath": "/app/skills/healthcheck/SKILL.md",
                "baseDir": "/app/skills/healthcheck",
                "source": "openclaw-bundled",
                "disableModelInvocation": false
              },
              {
                "name": "skill-creator",
                "description": "Create or update AgentSkills. Use when designing, structuring, or packaging skills with scripts, references, and assets.",
                "filePath": "/app/skills/skill-creator/SKILL.md",
                "baseDir": "/app/skills/skill-creator",
                "source": "openclaw-bundled",
                "disableModelInvocation": false
              },
              {
                "name": "slack",
                "description": "Use when you need to control Slack from OpenClaw via the slack tool, including reacting to messages or pinning/unpinning items in Slack channels or DMs.",
                "filePath": "/app/skills/slack/SKILL.md",
                "baseDir": "/app/skills/slack",
                "source": "openclaw-bundled",
                "disableModelInvocation": false
              },
              {
                "name": "weather",
                "description": "Get current weather and forecasts (no API key required).",
                "filePath": "/app/skills/weather/SKILL.md",
                "baseDir": "/app/skills/weather",
                "source": "openclaw-bundled",
                "disableModelInvocation": false
              }
            ],
            "version": 0
          },
          "inputTokens": 236,
          "outputTokens": 134,
          "totalTokens": 11372,
          "totalTokensFresh": true,
          "modelProvider": "aicodecat-gpt",
          "model": "gpt-5.2",
          "contextTokens": 400000,
          "systemPromptReport": {
            "source": "run",
            "generatedAt": 1771220207804,
            "sessionId": "2727320e-1716-40f1-a1a5-288c9771465c",
            "sessionKey": "agent:main:panel-stream-probe-1771220207181",
            "provider": "aicodecat-gpt",
            "model": "gpt-5.2",
            "workspaceDir": "/home/node/.openclaw/workspace",
            "bootstrapMaxChars": 20000,
            "sandbox": {
              "mode": "off",
              "sandboxed": false
            },
            "systemPrompt": {
              "chars": 24101,
              "projectContextChars": 13582,
              "nonProjectContextChars": 10519
            },
            "injectedWorkspaceFiles": [
              {
                "name": "AGENTS.md",
                "path": "/home/node/.openclaw/workspace/AGENTS.md",
                "missing": false,
                "rawChars": 7804,
                "injectedChars": 7804,
                "truncated": false
              },
              {
                "name": "SOUL.md",
                "path": "/home/node/.openclaw/workspace/SOUL.md",
                "missing": false,
                "rawChars": 1664,
                "injectedChars": 1664,
                "truncated": false
              },
              {
                "name": "TOOLS.md",
                "path": "/home/node/.openclaw/workspace/TOOLS.md",
                "missing": false,
                "rawChars": 850,
                "injectedChars": 850,
                "truncated": false
              },
              {
                "name": "IDENTITY.md",
                "path": "/home/node/.openclaw/workspace/IDENTITY.md",
                "missing": false,
                "rawChars": 633,
                "injectedChars": 633,
                "truncated": false
              },
              {
                "name": "USER.md",
                "path": "/home/node/.openclaw/workspace/USER.md",
                "missing": false,
                "rawChars": 474,
                "injectedChars": 474,
                "truncated": false
              },
              {
                "name": "HEARTBEAT.md",
                "path": "/home/node/.openclaw/workspace/HEARTBEAT.md",
                "missing": false,
                "rawChars": 167,
                "injectedChars": 167,
                "truncated": false
              },
              {
                "name": "BOOTSTRAP.md",
                "path": "/home/node/.openclaw/workspace/BOOTSTRAP.md",
                "missing": false,
                "rawChars": 1449,
                "injectedChars": 1449,
                "truncated": false
              }
            ],
            "skills": {
              "promptChars": 1557,
              "entries": [
                {
                  "name": "healthcheck",
                  "blockChars": 456
                },
                {
                  "name": "skill-creator",
                  "blockChars": 261
                },
                {
                  "name": "slack",
                  "blockChars": 277
                },
                {
                  "name": "weather",
                  "blockChars": 185
                }
              ]
            },
            "tools": {
              "listChars": 1926,
              "schemaChars": 14669,
              "entries": [
                {
                  "name": "read",
                  "summaryChars": 298,
                  "schemaChars": 392,
                  "propertiesCount": 4
                },
                {
                  "name": "edit",
                  "summaryChars": 129,
                  "schemaChars": 591,
                  "propertiesCount": 6
                },
                {
                  "name": "write",
                  "summaryChars": 127,
                  "schemaChars": 313,
                  "propertiesCount": 3
                },
                {
                  "name": "exec",
                  "summaryChars": 181,
                  "schemaChars": 1037,
                  "propertiesCount": 12
                },
                {
                  "name": "process",
                  "summaryChars": 85,
                  "schemaChars": 844,
                  "propertiesCount": 11
                },
                {
                  "name": "browser",
                  "summaryChars": 1251,
                  "schemaChars": 1869,
                  "propertiesCount": 28
                },
                {
                  "name": "canvas",
                  "summaryChars": 106,
                  "schemaChars": 661,
                  "propertiesCount": 18
                },
                {
                  "name": "nodes",
                  "summaryChars": 101,
                  "schemaChars": 1479,
                  "propertiesCount": 33
                },
                {
                  "name": "cron",
                  "summaryChars": 2444,
                  "schemaChars": 581,
                  "propertiesCount": 13
                },
                {
                  "name": "message",
                  "summaryChars": 89,
                  "schemaChars": 3897,
                  "propertiesCount": 84
                },
                {
                  "name": "tts",
                  "summaryChars": 129,
                  "schemaChars": 223,
                  "propertiesCount": 2
                },
                {
                  "name": "gateway",
                  "summaryChars": 354,
                  "schemaChars": 465,
                  "propertiesCount": 11
                },
                {
                  "name": "agents_list",
                  "summaryChars": 72,
                  "schemaChars": 33,
                  "propertiesCount": 0
                },
                {
                  "name": "sessions_list",
                  "summaryChars": 54,
                  "schemaChars": 176,
                  "propertiesCount": 4
                },
                {
                  "name": "sessions_history",
                  "summaryChars": 36,
                  "schemaChars": 149,
                  "propertiesCount": 3
                },
                {
                  "name": "sessions_send",
                  "summaryChars": 84,
                  "schemaChars": 203,
                  "propertiesCount": 5
                },
                {
                  "name": "sessions_spawn",
                  "summaryChars": 107,
                  "schemaChars": 312,
                  "propertiesCount": 8
                },
                {
                  "name": "session_status",
                  "summaryChars": 207,
                  "schemaChars": 89,
                  "propertiesCount": 2
                },
                {
                  "name": "web_search",
                  "summaryChars": 175,
                  "schemaChars": 728,
                  "propertiesCount": 6
                },
                {
                  "name": "web_fetch",
                  "summaryChars": 129,
                  "schemaChars": 360,
                  "propertiesCount": 3
                },
                {
                  "name": "memory_search",
                  "summaryChars": 235,
                  "schemaChars": 139,
                  "propertiesCount": 3
                },
                {
                  "name": "memory_get",
                  "summaryChars": 151,
                  "schemaChars": 128,
                  "propertiesCount": 3
                }
              ]
            }
          },
          "providerOverride": "aicodecat-gpt",
          "modelOverride": "__panel_invalid_model__"
        },
        "resolved": {
          "modelProvider": "aicodecat-gpt",
          "model": "__panel_invalid_model__"
        }
      },
      "ack": {
        "runId": "panel-stream-probe-1771220207181-forced-error",
        "status": "started"
      },
      "states": [
        "delta",
        "final"
      ],
      "terminal": {
        "timeout": false,
        "terminalState": "final",
        "terminalAtMs": 1771220215146
      },
      "events": [
        {
          "atMs": 1771220214999,
          "runId": "panel-stream-probe-1771220207181-forced-error",
          "sessionKey": "agent:main:panel-stream-probe-1771220207181",
          "state": "delta",
          "seq": 2,
          "stopReason": null,
          "text": "hello"
        },
        {
          "atMs": 1771220215146,
          "runId": "panel-stream-probe-1771220207181-forced-error",
          "sessionKey": "agent:main:panel-stream-probe-1771220207181",
          "state": "final",
          "seq": 3,
          "stopReason": null,
          "text": "hello"
        }
      ]
    }
  },
  "rpcTrace": [
    {
      "at": "2026-02-16T05:36:47.499Z",
      "method": "chat.send",
      "ok": true,
      "latencyMs": 10,
      "params": {
        "sessionKey": "agent:main:panel-stream-probe-1771220207181",
        "message": "请简短介绍你自己，并用两段输出。",
        "idempotencyKey": "panel-stream-probe-1771220207181-normal"
      },
      "payload": {
        "runId": "panel-stream-probe-1771220207181-normal",
        "status": "started"
      }
    },
    {
      "at": "2026-02-16T05:36:52.545Z",
      "method": "chat.send",
      "ok": true,
      "latencyMs": 21,
      "params": {
        "sessionKey": "agent:main:panel-stream-probe-1771220207181",
        "message": "请连续输出一份很长的技术报告，至少分成100个小节，不要提前结束。",
        "idempotencyKey": "panel-stream-probe-1771220207181-abort",
        "timeoutMs": 60000
      },
      "payload": {
        "runId": "panel-stream-probe-1771220207181-abort",
        "status": "started"
      }
    },
    {
      "at": "2026-02-16T05:36:52.999Z",
      "method": "chat.abort",
      "ok": true,
      "latencyMs": 3,
      "params": {
        "sessionKey": "agent:main:panel-stream-probe-1771220207181",
        "runId": "panel-stream-probe-1771220207181-abort"
      },
      "payload": {
        "ok": true,
        "aborted": true,
        "runIds": [
          "panel-stream-probe-1771220207181-abort"
        ]
      }
    },
    {
      "at": "2026-02-16T05:36:53.031Z",
      "method": "chat.send",
      "ok": false,
      "latencyMs": 32,
      "params": {
        "sessionKey": "agent:main:panel-stream-probe-1771220207181",
        "idempotencyKey": "panel-stream-probe-1771220207181-invalid"
      },
      "error": "invalid chat.send params: must have required property 'message'"
    },
    {
      "at": "2026-02-16T05:36:53.119Z",
      "method": "sessions.patch",
      "ok": true,
      "latencyMs": 88,
      "params": {
        "key": "agent:main:panel-stream-probe-1771220207181",
        "model": "__panel_invalid_model__"
      },
      "payload": {
        "ok": true,
        "path": "/home/node/.openclaw/agents/main/sessions/sessions.json",
        "key": "agent:main:panel-stream-probe-1771220207181",
        "entry": {
          "sessionId": "2727320e-1716-40f1-a1a5-288c9771465c",
          "updatedAt": 1771220213083,
          "systemSent": true,
          "abortedLastRun": false,
          "chatType": "direct",
          "deliveryContext": {
            "channel": "webchat"
          },
          "lastChannel": "webchat",
          "origin": {
            "label": "panel-stream-probe",
            "provider": "webchat",
            "surface": "webchat",
            "chatType": "direct"
          },
          "sessionFile": "/home/node/.openclaw/agents/main/sessions/2727320e-1716-40f1-a1a5-288c9771465c.jsonl",
          "compactionCount": 0,
          "skillsSnapshot": {
            "prompt": "\n\nThe following skills provide specialized instructions for specific tasks.\nUse the read tool to load a skill's file when the task matches its description.\nWhen a skill file references a relative path, resolve it against the skill directory (parent of SKILL.md / dirname of the path) and use that absolute path in tool commands.\n\n<available_skills>\n  <skill>\n    <name>healthcheck</name>\n    <description>Host security hardening and risk-tolerance configuration for OpenClaw deployments. Use when a user asks for security audits, firewall/SSH/update hardening, risk posture, exposure review, OpenClaw cron scheduling for periodic checks, or version status checks on a machine running OpenClaw (laptop, workstation, Pi, VPS).</description>\n    <location>/app/skills/healthcheck/SKILL.md</location>\n  </skill>\n  <skill>\n    <name>skill-creator</name>\n    <description>Create or update AgentSkills. Use when designing, structuring, or packaging skills with scripts, references, and assets.</description>\n    <location>/app/skills/skill-creator/SKILL.md</location>\n  </skill>\n  <skill>\n    <name>slack</name>\n    <description>Use when you need to control Slack from OpenClaw via the slack tool, including reacting to messages or pinning/unpinning items in Slack channels or DMs.</description>\n    <location>/app/skills/slack/SKILL.md</location>\n  </skill>\n  <skill>\n    <name>weather</name>\n    <description>Get current weather and forecasts (no API key required).</description>\n    <location>/app/skills/weather/SKILL.md</location>\n  </skill>\n</available_skills>",
            "skills": [
              {
                "name": "healthcheck"
              },
              {
                "name": "skill-creator"
              },
              {
                "name": "slack"
              },
              {
                "name": "weather"
              }
            ],
            "resolvedSkills": [
              {
                "name": "healthcheck",
                "description": "Host security hardening and risk-tolerance configuration for OpenClaw deployments. Use when a user asks for security audits, firewall/SSH/update hardening, risk posture, exposure review, OpenClaw cron scheduling for periodic checks, or version status checks on a machine running OpenClaw (laptop, workstation, Pi, VPS).",
                "filePath": "/app/skills/healthcheck/SKILL.md",
                "baseDir": "/app/skills/healthcheck",
                "source": "openclaw-bundled",
                "disableModelInvocation": false
              },
              {
                "name": "skill-creator",
                "description": "Create or update AgentSkills. Use when designing, structuring, or packaging skills with scripts, references, and assets.",
                "filePath": "/app/skills/skill-creator/SKILL.md",
                "baseDir": "/app/skills/skill-creator",
                "source": "openclaw-bundled",
                "disableModelInvocation": false
              },
              {
                "name": "slack",
                "description": "Use when you need to control Slack from OpenClaw via the slack tool, including reacting to messages or pinning/unpinning items in Slack channels or DMs.",
                "filePath": "/app/skills/slack/SKILL.md",
                "baseDir": "/app/skills/slack",
                "source": "openclaw-bundled",
                "disableModelInvocation": false
              },
              {
                "name": "weather",
                "description": "Get current weather and forecasts (no API key required).",
                "filePath": "/app/skills/weather/SKILL.md",
                "baseDir": "/app/skills/weather",
                "source": "openclaw-bundled",
                "disableModelInvocation": false
              }
            ],
            "version": 0
          },
          "inputTokens": 236,
          "outputTokens": 134,
          "totalTokens": 11372,
          "totalTokensFresh": true,
          "modelProvider": "aicodecat-gpt",
          "model": "gpt-5.2",
          "contextTokens": 400000,
          "systemPromptReport": {
            "source": "run",
            "generatedAt": 1771220207804,
            "sessionId": "2727320e-1716-40f1-a1a5-288c9771465c",
            "sessionKey": "agent:main:panel-stream-probe-1771220207181",
            "provider": "aicodecat-gpt",
            "model": "gpt-5.2",
            "workspaceDir": "/home/node/.openclaw/workspace",
            "bootstrapMaxChars": 20000,
            "sandbox": {
              "mode": "off",
              "sandboxed": false
            },
            "systemPrompt": {
              "chars": 24101,
              "projectContextChars": 13582,
              "nonProjectContextChars": 10519
            },
            "injectedWorkspaceFiles": [
              {
                "name": "AGENTS.md",
                "path": "/home/node/.openclaw/workspace/AGENTS.md",
                "missing": false,
                "rawChars": 7804,
                "injectedChars": 7804,
                "truncated": false
              },
              {
                "name": "SOUL.md",
                "path": "/home/node/.openclaw/workspace/SOUL.md",
                "missing": false,
                "rawChars": 1664,
                "injectedChars": 1664,
                "truncated": false
              },
              {
                "name": "TOOLS.md",
                "path": "/home/node/.openclaw/workspace/TOOLS.md",
                "missing": false,
                "rawChars": 850,
                "injectedChars": 850,
                "truncated": false
              },
              {
                "name": "IDENTITY.md",
                "path": "/home/node/.openclaw/workspace/IDENTITY.md",
                "missing": false,
                "rawChars": 633,
                "injectedChars": 633,
                "truncated": false
              },
              {
                "name": "USER.md",
                "path": "/home/node/.openclaw/workspace/USER.md",
                "missing": false,
                "rawChars": 474,
                "injectedChars": 474,
                "truncated": false
              },
              {
                "name": "HEARTBEAT.md",
                "path": "/home/node/.openclaw/workspace/HEARTBEAT.md",
                "missing": false,
                "rawChars": 167,
                "injectedChars": 167,
                "truncated": false
              },
              {
                "name": "BOOTSTRAP.md",
                "path": "/home/node/.openclaw/workspace/BOOTSTRAP.md",
                "missing": false,
                "rawChars": 1449,
                "injectedChars": 1449,
                "truncated": false
              }
            ],
            "skills": {
              "promptChars": 1557,
              "entries": [
                {
                  "name": "healthcheck",
                  "blockChars": 456
                },
                {
                  "name": "skill-creator",
                  "blockChars": 261
                },
                {
                  "name": "slack",
                  "blockChars": 277
                },
                {
                  "name": "weather",
                  "blockChars": 185
                }
              ]
            },
            "tools": {
              "listChars": 1926,
              "schemaChars": 14669,
              "entries": [
                {
                  "name": "read",
                  "summaryChars": 298,
                  "schemaChars": 392,
                  "propertiesCount": 4
                },
                {
                  "name": "edit",
                  "summaryChars": 129,
                  "schemaChars": 591,
                  "propertiesCount": 6
                },
                {
                  "name": "write",
                  "summaryChars": 127,
                  "schemaChars": 313,
                  "propertiesCount": 3
                },
                {
                  "name": "exec",
                  "summaryChars": 181,
                  "schemaChars": 1037,
                  "propertiesCount": 12
                },
                {
                  "name": "process",
                  "summaryChars": 85,
                  "schemaChars": 844,
                  "propertiesCount": 11
                },
                {
                  "name": "browser",
                  "summaryChars": 1251,
                  "schemaChars": 1869,
                  "propertiesCount": 28
                },
                {
                  "name": "canvas",
                  "summaryChars": 106,
                  "schemaChars": 661,
                  "propertiesCount": 18
                },
                {
                  "name": "nodes",
                  "summaryChars": 101,
                  "schemaChars": 1479,
                  "propertiesCount": 33
                },
                {
                  "name": "cron",
                  "summaryChars": 2444,
                  "schemaChars": 581,
                  "propertiesCount": 13
                },
                {
                  "name": "message",
                  "summaryChars": 89,
                  "schemaChars": 3897,
                  "propertiesCount": 84
                },
                {
                  "name": "tts",
                  "summaryChars": 129,
                  "schemaChars": 223,
                  "propertiesCount": 2
                },
                {
                  "name": "gateway",
                  "summaryChars": 354,
                  "schemaChars": 465,
                  "propertiesCount": 11
                },
                {
                  "name": "agents_list",
                  "summaryChars": 72,
                  "schemaChars": 33,
                  "propertiesCount": 0
                },
                {
                  "name": "sessions_list",
                  "summaryChars": 54,
                  "schemaChars": 176,
                  "propertiesCount": 4
                },
                {
                  "name": "sessions_history",
                  "summaryChars": 36,
                  "schemaChars": 149,
                  "propertiesCount": 3
                },
                {
                  "name": "sessions_send",
                  "summaryChars": 84,
                  "schemaChars": 203,
                  "propertiesCount": 5
                },
                {
                  "name": "sessions_spawn",
                  "summaryChars": 107,
                  "schemaChars": 312,
                  "propertiesCount": 8
                },
                {
                  "name": "session_status",
                  "summaryChars": 207,
                  "schemaChars": 89,
                  "propertiesCount": 2
                },
                {
                  "name": "web_search",
                  "summaryChars": 175,
                  "schemaChars": 728,
                  "propertiesCount": 6
                },
                {
                  "name": "web_fetch",
                  "summaryChars": 129,
                  "schemaChars": 360,
                  "propertiesCount": 3
                },
                {
                  "name": "memory_search",
                  "summaryChars": 235,
                  "schemaChars": 139,
                  "propertiesCount": 3
                },
                {
                  "name": "memory_get",
                  "summaryChars": 151,
                  "schemaChars": 128,
                  "propertiesCount": 3
                }
              ]
            }
          },
          "providerOverride": "aicodecat-gpt",
          "modelOverride": "__panel_invalid_model__"
        },
        "resolved": {
          "modelProvider": "aicodecat-gpt",
          "model": "__panel_invalid_model__"
        }
      }
    },
    {
      "at": "2026-02-16T05:36:53.138Z",
      "method": "chat.send",
      "ok": true,
      "latencyMs": 19,
      "params": {
        "sessionKey": "agent:main:panel-stream-probe-1771220207181",
        "message": "hello",
        "idempotencyKey": "panel-stream-probe-1771220207181-forced-error"
      },
      "payload": {
        "runId": "panel-stream-probe-1771220207181-forced-error",
        "status": "started"
      }
    }
  ],
  "stats": {
    "totalChatEvents": 19,
    "totalAgentLifecycleEvents": 133
  },
  "chatEvents": [
    {
      "atMs": 1771220209996,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "state": "delta",
      "seq": 2,
      "stopReason": null,
      "text": "我"
    },
    {
      "atMs": 1771220210150,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "state": "delta",
      "seq": 9,
      "stopReason": null,
      "text": "我是在 OpenClaw 里运行的"
    },
    {
      "atMs": 1771220210312,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "state": "delta",
      "seq": 18,
      "stopReason": null,
      "text": "我是在 OpenClaw 里运行的个人助理型 AI，也可以当作"
    },
    {
      "atMs": 1771220210481,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "state": "delta",
      "seq": 27,
      "stopReason": null,
      "text": "我是在 OpenClaw 里运行的个人助理型 AI，也可以当作很强的“编码搭子”：能"
    },
    {
      "atMs": 1771220210634,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "state": "delta",
      "seq": 36,
      "stopReason": null,
      "text": "我是在 OpenClaw 里运行的个人助理型 AI，也可以当作很强的“编码搭子”：能读写项目文件、跑命令、"
    },
    {
      "atMs": 1771220210791,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "state": "delta",
      "seq": 45,
      "stopReason": null,
      "text": "我是在 OpenClaw 里运行的个人助理型 AI，也可以当作很强的“编码搭子”：能读写项目文件、跑命令、排查报错、改代码、写"
    },
    {
      "atMs": 1771220210949,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "state": "delta",
      "seq": 54,
      "stopReason": null,
      "text": "我是在 OpenClaw 里运行的个人助理型 AI，也可以当作很强的“编码搭子”：能读写项目文件、跑命令、排查报错、改代码、写脚本、查资料，并把结果整理"
    },
    {
      "atMs": 1771220211106,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "state": "delta",
      "seq": 63,
      "stopReason": null,
      "text": "我是在 OpenClaw 里运行的个人助理型 AI，也可以当作很强的“编码搭子”：能读写项目文件、跑命令、排查报错、改代码、写脚本、查资料，并把结果整理成你能直接用的步骤或改"
    },
    {
      "atMs": 1771220211271,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "state": "delta",
      "seq": 71,
      "stopReason": null,
      "text": "我是在 OpenClaw 里运行的个人助理型 AI，也可以当作很强的“编码搭子”：能读写项目文件、跑命令、排查报错、改代码、写脚本、查资料，并把结果整理成你能直接用的步骤或改动说明。\n\n我偏向少废"
    },
    {
      "atMs": 1771220211424,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "state": "delta",
      "seq": 80,
      "stopReason": null,
      "text": "我是在 OpenClaw 里运行的个人助理型 AI，也可以当作很强的“编码搭子”：能读写项目文件、跑命令、排查报错、改代码、写脚本、查资料，并把结果整理成你能直接用的步骤或改动说明。\n\n我偏向少废话、先动手再汇报；"
    },
    {
      "atMs": 1771220211601,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "state": "delta",
      "seq": 89,
      "stopReason": null,
      "text": "我是在 OpenClaw 里运行的个人助理型 AI，也可以当作很强的“编码搭子”：能读写项目文件、跑命令、排查报错、改代码、写脚本、查资料，并把结果整理成你能直接用的步骤或改动说明。\n\n我偏向少废话、先动手再汇报；遇到会影响方向/安全的关键"
    },
    {
      "atMs": 1771220211757,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "state": "delta",
      "seq": 98,
      "stopReason": null,
      "text": "我是在 OpenClaw 里运行的个人助理型 AI，也可以当作很强的“编码搭子”：能读写项目文件、跑命令、排查报错、改代码、写脚本、查资料，并把结果整理成你能直接用的步骤或改动说明。\n\n我偏向少废话、先动手再汇报；遇到会影响方向/安全的关键歧义才会追问。你可以"
    },
    {
      "atMs": 1771220211923,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "state": "delta",
      "seq": 106,
      "stopReason": null,
      "text": "我是在 OpenClaw 里运行的个人助理型 AI，也可以当作很强的“编码搭子”：能读写项目文件、跑命令、排查报错、改代码、写脚本、查资料，并把结果整理成你能直接用的步骤或改动说明。\n\n我偏向少废话、先动手再汇报；遇到会影响方向/安全的关键歧义才会追问。你可以直接丢需求、报错日志、"
    },
    {
      "atMs": 1771220212073,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "state": "delta",
      "seq": 115,
      "stopReason": null,
      "text": "我是在 OpenClaw 里运行的个人助理型 AI，也可以当作很强的“编码搭子”：能读写项目文件、跑命令、排查报错、改代码、写脚本、查资料，并把结果整理成你能直接用的步骤或改动说明。\n\n我偏向少废话、先动手再汇报；遇到会影响方向/安全的关键歧义才会追问。你可以直接丢需求、报错日志、仓库路径或截图，我会尽量"
    },
    {
      "atMs": 1771220212230,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "state": "delta",
      "seq": 123,
      "stopReason": null,
      "text": "我是在 OpenClaw 里运行的个人助理型 AI，也可以当作很强的“编码搭子”：能读写项目文件、跑命令、排查报错、改代码、写脚本、查资料，并把结果整理成你能直接用的步骤或改动说明。\n\n我偏向少废话、先动手再汇报；遇到会影响方向/安全的关键歧义才会追问。你可以直接丢需求、报错日志、仓库路径或截图，我会尽量用最短路径把事情推进到"
    },
    {
      "atMs": 1771220212480,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "state": "final",
      "seq": 129,
      "stopReason": null,
      "text": "我是在 OpenClaw 里运行的个人助理型 AI，也可以当作很强的“编码搭子”：能读写项目文件、跑命令、排查报错、改代码、写脚本、查资料，并把结果整理成你能直接用的步骤或改动说明。\n\n我偏向少废话、先动手再汇报；遇到会影响方向/安全的关键歧义才会追问。你可以直接丢需求、报错日志、仓库路径或截图，我会尽量用最短路径把事情推进到可验证的结果。"
    },
    {
      "atMs": 1771220212999,
      "runId": "panel-stream-probe-1771220207181-abort",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "state": "aborted",
      "seq": 2,
      "stopReason": "rpc"
    },
    {
      "atMs": 1771220214999,
      "runId": "panel-stream-probe-1771220207181-forced-error",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "state": "delta",
      "seq": 2,
      "stopReason": null,
      "text": "hello"
    },
    {
      "atMs": 1771220215146,
      "runId": "panel-stream-probe-1771220207181-forced-error",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "state": "final",
      "seq": 3,
      "stopReason": null,
      "text": "hello"
    }
  ],
  "agentLifecycleEvents": [
    {
      "atMs": 1771220207859,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "lifecycle",
      "phase": "start",
      "seq": 1
    },
    {
      "atMs": 1771220209996,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 2
    },
    {
      "atMs": 1771220210031,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 3
    },
    {
      "atMs": 1771220210032,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 4
    },
    {
      "atMs": 1771220210054,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 5
    },
    {
      "atMs": 1771220210072,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 6
    },
    {
      "atMs": 1771220210110,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 7
    },
    {
      "atMs": 1771220210131,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 8
    },
    {
      "atMs": 1771220210150,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 9
    },
    {
      "atMs": 1771220210174,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 10
    },
    {
      "atMs": 1771220210176,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 11
    },
    {
      "atMs": 1771220210194,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 12
    },
    {
      "atMs": 1771220210212,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 13
    },
    {
      "atMs": 1771220210231,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 14
    },
    {
      "atMs": 1771220210251,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 15
    },
    {
      "atMs": 1771220210269,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 16
    },
    {
      "atMs": 1771220210295,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 17
    },
    {
      "atMs": 1771220210312,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 18
    },
    {
      "atMs": 1771220210345,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 19
    },
    {
      "atMs": 1771220210345,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 20
    },
    {
      "atMs": 1771220210354,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 21
    },
    {
      "atMs": 1771220210374,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 22
    },
    {
      "atMs": 1771220210394,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 23
    },
    {
      "atMs": 1771220210414,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 24
    },
    {
      "atMs": 1771220210433,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 25
    },
    {
      "atMs": 1771220210457,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 26
    },
    {
      "atMs": 1771220210481,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 27
    },
    {
      "atMs": 1771220210525,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 28
    },
    {
      "atMs": 1771220210526,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 29
    },
    {
      "atMs": 1771220210526,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 30
    },
    {
      "atMs": 1771220210538,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 31
    },
    {
      "atMs": 1771220210554,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 32
    },
    {
      "atMs": 1771220210585,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 33
    },
    {
      "atMs": 1771220210593,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 34
    },
    {
      "atMs": 1771220210615,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 35
    },
    {
      "atMs": 1771220210634,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 36
    },
    {
      "atMs": 1771220210651,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 37
    },
    {
      "atMs": 1771220210673,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 38
    },
    {
      "atMs": 1771220210692,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 39
    },
    {
      "atMs": 1771220210692,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 40
    },
    {
      "atMs": 1771220210711,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 41
    },
    {
      "atMs": 1771220210735,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 42
    },
    {
      "atMs": 1771220210750,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 43
    },
    {
      "atMs": 1771220210773,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 44
    },
    {
      "atMs": 1771220210791,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 45
    },
    {
      "atMs": 1771220210814,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 46
    },
    {
      "atMs": 1771220210831,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 47
    },
    {
      "atMs": 1771220210852,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 48
    },
    {
      "atMs": 1771220210870,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 49
    },
    {
      "atMs": 1771220210870,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 50
    },
    {
      "atMs": 1771220210890,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 51
    },
    {
      "atMs": 1771220210910,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 52
    },
    {
      "atMs": 1771220210928,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 53
    },
    {
      "atMs": 1771220210949,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 54
    },
    {
      "atMs": 1771220210968,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 55
    },
    {
      "atMs": 1771220210995,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 56
    },
    {
      "atMs": 1771220211008,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 57
    },
    {
      "atMs": 1771220211027,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 58
    },
    {
      "atMs": 1771220211048,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 59
    },
    {
      "atMs": 1771220211067,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 60
    },
    {
      "atMs": 1771220211068,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 61
    },
    {
      "atMs": 1771220211086,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 62
    },
    {
      "atMs": 1771220211106,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 63
    },
    {
      "atMs": 1771220211129,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 64
    },
    {
      "atMs": 1771220211147,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 65
    },
    {
      "atMs": 1771220211167,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 66
    },
    {
      "atMs": 1771220211190,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 67
    },
    {
      "atMs": 1771220211207,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 68
    },
    {
      "atMs": 1771220211228,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 69
    },
    {
      "atMs": 1771220211254,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 70
    },
    {
      "atMs": 1771220211270,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 71
    },
    {
      "atMs": 1771220211271,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 72
    },
    {
      "atMs": 1771220211289,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 73
    },
    {
      "atMs": 1771220211318,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 74
    },
    {
      "atMs": 1771220211342,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 75
    },
    {
      "atMs": 1771220211345,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 76
    },
    {
      "atMs": 1771220211365,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 77
    },
    {
      "atMs": 1771220211384,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 78
    },
    {
      "atMs": 1771220211404,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 79
    },
    {
      "atMs": 1771220211424,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 80
    },
    {
      "atMs": 1771220211445,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 81
    },
    {
      "atMs": 1771220211464,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 82
    },
    {
      "atMs": 1771220211465,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 83
    },
    {
      "atMs": 1771220211485,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 84
    },
    {
      "atMs": 1771220211503,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 85
    },
    {
      "atMs": 1771220211559,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 86
    },
    {
      "atMs": 1771220211559,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 87
    },
    {
      "atMs": 1771220211565,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 88
    },
    {
      "atMs": 1771220211601,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 89
    },
    {
      "atMs": 1771220211620,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 90
    },
    {
      "atMs": 1771220211643,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 91
    },
    {
      "atMs": 1771220211667,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 92
    },
    {
      "atMs": 1771220211667,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 93
    },
    {
      "atMs": 1771220211682,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 94
    },
    {
      "atMs": 1771220211705,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 95
    },
    {
      "atMs": 1771220211723,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 96
    },
    {
      "atMs": 1771220211740,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 97
    },
    {
      "atMs": 1771220211757,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 98
    },
    {
      "atMs": 1771220211799,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 99
    },
    {
      "atMs": 1771220211817,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 100
    },
    {
      "atMs": 1771220211836,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 101
    },
    {
      "atMs": 1771220211857,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 102
    },
    {
      "atMs": 1771220211859,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 103
    },
    {
      "atMs": 1771220211889,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 104
    },
    {
      "atMs": 1771220211899,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 105
    },
    {
      "atMs": 1771220211923,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 106
    },
    {
      "atMs": 1771220211943,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 107
    },
    {
      "atMs": 1771220211964,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 108
    },
    {
      "atMs": 1771220211983,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 109
    },
    {
      "atMs": 1771220211994,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 110
    },
    {
      "atMs": 1771220212016,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 111
    },
    {
      "atMs": 1771220212034,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 112
    },
    {
      "atMs": 1771220212053,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 113
    },
    {
      "atMs": 1771220212057,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 114
    },
    {
      "atMs": 1771220212073,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 115
    },
    {
      "atMs": 1771220212099,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 116
    },
    {
      "atMs": 1771220212115,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 117
    },
    {
      "atMs": 1771220212136,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 118
    },
    {
      "atMs": 1771220212151,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 119
    },
    {
      "atMs": 1771220212171,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 120
    },
    {
      "atMs": 1771220212192,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 121
    },
    {
      "atMs": 1771220212211,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 122
    },
    {
      "atMs": 1771220212230,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 123
    },
    {
      "atMs": 1771220212251,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 124
    },
    {
      "atMs": 1771220212252,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 125
    },
    {
      "atMs": 1771220212272,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 126
    },
    {
      "atMs": 1771220212290,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 127
    },
    {
      "atMs": 1771220212310,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 128
    },
    {
      "atMs": 1771220212480,
      "runId": "panel-stream-probe-1771220207181-normal",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "lifecycle",
      "phase": "end",
      "seq": 129
    },
    {
      "atMs": 1771220212918,
      "runId": "panel-stream-probe-1771220207181-abort",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "lifecycle",
      "phase": "start",
      "seq": 1
    },
    {
      "atMs": 1771220213579,
      "runId": "panel-stream-probe-1771220207181-forced-error",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "lifecycle",
      "phase": "start",
      "seq": 1
    },
    {
      "atMs": 1771220214999,
      "runId": "panel-stream-probe-1771220207181-forced-error",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "assistant",
      "phase": null,
      "seq": 2
    },
    {
      "atMs": 1771220215146,
      "runId": "panel-stream-probe-1771220207181-forced-error",
      "sessionKey": "agent:main:panel-stream-probe-1771220207181",
      "stream": "lifecycle",
      "phase": "end",
      "seq": 3
    }
  ],
  "observations": [
    "normal 流程出现 delta -> final。",
    "abort 流程出现 aborted，stopReason=rpc。",
    "invalidRequest 走 RPC 错误返回（无 run 启动）。",
    "forcedRuntimeErrorAttempt 中，invalid model 仍走到 final，未复现 chat.state=error。"
  ]
}
</file>

<file path="plan/2026-02-16_ClawX源码调研/evidence/chat-stream-event-probe-live.mjs">
import fs from "node:fs/promises";
import path from "node:path";
import { pathToFileURL } from "node:url";

const DIST_DIR = "/app/dist";
const WS_URL = process.env.OPENCLAW_GATEWAY_WS_URL || "ws://127.0.0.1:18789/ws";
const CONNECT_TIMEOUT_MS = 12_000;

function nowIso() {
  return new Date().toISOString();
}

function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

function asErrorMessage(error) {
  if (error instanceof Error) {
    return error.message;
  }
  return String(error);
}

function extractText(message) {
  if (!message || typeof message !== "object") {
    return undefined;
  }
  const content = message.content;
  if (!Array.isArray(content)) {
    return undefined;
  }
  return content
    .map((part) => {
      if (!part || typeof part !== "object") {
        return "";
      }
      return typeof part.text === "string" ? part.text : "";
    })
    .join("")
    .trim();
}

async function loadGatewayClientClass() {
  const files = await fs.readdir(DIST_DIR);
  const candidates = files
    .filter((name) => name.startsWith("client-") && name.endsWith(".js"))
    .sort();

  for (const fileName of candidates) {
    const modulePath = pathToFileURL(path.join(DIST_DIR, fileName)).href;
    const mod = await import(modulePath);
    const GatewayClient = Object.values(mod).find(
      (value) => typeof value === "function" && value.name === "GatewayClient",
    );
    if (GatewayClient) {
      return { GatewayClient, fileName };
    }
  }

  throw new Error("GatewayClient not found in /app/dist/client-*.js");
}

function listRunStates(chatEvents, runId) {
  return chatEvents.filter((event) => event.runId === runId).map((event) => event.state);
}

function collectRunEvents(chatEvents, runId) {
  return chatEvents.filter((event) => event.runId === runId);
}

async function waitForTerminalState(chatEvents, runId, timeoutMs) {
  const deadline = Date.now() + timeoutMs;
  while (Date.now() < deadline) {
    const runEvents = collectRunEvents(chatEvents, runId);
    const terminal = runEvents.find((event) =>
      ["final", "error", "aborted"].includes(event.state),
    );
    if (terminal) {
      return {
        timeout: false,
        terminalState: terminal.state,
        terminalAtMs: terminal.atMs,
      };
    }
    await sleep(120);
  }

  return {
    timeout: true,
    terminalState: null,
    terminalAtMs: null,
  };
}

async function main() {
  const startedAt = nowIso();
  const probeId = `panel-stream-probe-${Date.now()}`;
  const sessionKey = `agent:main:${probeId}`;

  const runtime = await loadGatewayClientClass();
  const GatewayClient = runtime.GatewayClient;

  const chatEvents = [];
  const agentLifecycleEvents = [];
  const rpcTrace = [];

  let readyResolve;
  let readyReject;
  const readyPromise = new Promise((resolve, reject) => {
    readyResolve = resolve;
    readyReject = reject;
  });

  let lastClose = null;
  let connected = false;

  const client = new GatewayClient({
    url: WS_URL,
    clientName: "cli",
    mode: "cli",
    instanceId: `${probeId}-client`,
    clientDisplayName: "panel-stream-probe",
    clientVersion: "probe",
    onEvent: (evt) => {
      if (!evt || typeof evt !== "object") {
        return;
      }

      if (evt.event === "chat") {
        const payload = evt.payload && typeof evt.payload === "object" ? evt.payload : {};
        chatEvents.push({
          atMs: Date.now(),
          runId: typeof payload.runId === "string" ? payload.runId : null,
          sessionKey: typeof payload.sessionKey === "string" ? payload.sessionKey : null,
          state: typeof payload.state === "string" ? payload.state : null,
          seq: typeof payload.seq === "number" ? payload.seq : null,
          stopReason: typeof payload.stopReason === "string" ? payload.stopReason : null,
          errorMessage:
            typeof payload.errorMessage === "string" ? payload.errorMessage : undefined,
          text: extractText(payload.message),
        });
        return;
      }

      if (evt.event === "agent") {
        const payload = evt.payload && typeof evt.payload === "object" ? evt.payload : {};
        const stream = typeof payload.stream === "string" ? payload.stream : null;
        const data = payload.data && typeof payload.data === "object" ? payload.data : {};
        const phase = typeof data.phase === "string" ? data.phase : null;
        if (stream === "lifecycle" || stream === "assistant") {
          agentLifecycleEvents.push({
            atMs: Date.now(),
            runId: typeof payload.runId === "string" ? payload.runId : null,
            sessionKey: typeof payload.sessionKey === "string" ? payload.sessionKey : null,
            stream,
            phase,
            seq: typeof payload.seq === "number" ? payload.seq : null,
          });
        }
      }
    },
    onHelloOk: (hello) => {
      connected = true;
      readyResolve(hello);
    },
    onConnectError: (error) => {
      readyReject(error instanceof Error ? error : new Error(String(error)));
    },
    onClose: (code, reason) => {
      lastClose = { code, reason };
    },
  });

  const request = async (method, params) => {
    const startedMs = Date.now();
    try {
      const payload = await client.request(method, params);
      rpcTrace.push({
        at: nowIso(),
        method,
        ok: true,
        latencyMs: Date.now() - startedMs,
        params,
        payload,
      });
      return payload;
    } catch (error) {
      const message = asErrorMessage(error);
      rpcTrace.push({
        at: nowIso(),
        method,
        ok: false,
        latencyMs: Date.now() - startedMs,
        params,
        error: message,
      });
      throw new Error(message);
    }
  };

  const scenarios = {
    normal: null,
    abort: null,
    invalidRequest: null,
    forcedRuntimeErrorAttempt: null,
  };

  try {
    client.start();

    const connectTimer = setTimeout(() => {
      readyReject(new Error(`connect timeout after ${CONNECT_TIMEOUT_MS}ms`));
    }, CONNECT_TIMEOUT_MS);
    const hello = await readyPromise;
    clearTimeout(connectTimer);

    const normalRunId = `${probeId}-normal`;
    const normalAck = await request("chat.send", {
      sessionKey,
      message: "请简短介绍你自己，并用两段输出。",
      idempotencyKey: normalRunId,
    });
    const normalTerminal = await waitForTerminalState(chatEvents, normalRunId, 45_000);
    scenarios.normal = {
      runId: normalRunId,
      ack: normalAck,
      states: listRunStates(chatEvents, normalRunId),
      terminal: normalTerminal,
      events: collectRunEvents(chatEvents, normalRunId),
    };

    const abortRunId = `${probeId}-abort`;
    const abortAck = await request("chat.send", {
      sessionKey,
      message: "请连续输出一份很长的技术报告，至少分成100个小节，不要提前结束。",
      idempotencyKey: abortRunId,
      timeoutMs: 60_000,
    });
    await sleep(450);
    const abortRes = await request("chat.abort", {
      sessionKey,
      runId: abortRunId,
    });
    const abortTerminal = await waitForTerminalState(chatEvents, abortRunId, 20_000);
    scenarios.abort = {
      runId: abortRunId,
      ack: abortAck,
      abortRes,
      states: listRunStates(chatEvents, abortRunId),
      terminal: abortTerminal,
      events: collectRunEvents(chatEvents, abortRunId),
    };

    const invalidRunId = `${probeId}-invalid`;
    try {
      await request("chat.send", {
        sessionKey,
        idempotencyKey: invalidRunId,
      });
      scenarios.invalidRequest = {
        runId: invalidRunId,
        ok: false,
        error: "unexpected success",
      };
    } catch (error) {
      scenarios.invalidRequest = {
        runId: invalidRunId,
        ok: true,
        error: asErrorMessage(error),
      };
    }

    const forcedRunId = `${probeId}-forced-error`;
    const forcedPatch = await request("sessions.patch", {
      key: sessionKey,
      model: "__panel_invalid_model__",
    });
    const forcedAck = await request("chat.send", {
      sessionKey,
      message: "hello",
      idempotencyKey: forcedRunId,
    });
    const forcedTerminal = await waitForTerminalState(chatEvents, forcedRunId, 45_000);
    scenarios.forcedRuntimeErrorAttempt = {
      runId: forcedRunId,
      patch: forcedPatch,
      ack: forcedAck,
      states: listRunStates(chatEvents, forcedRunId),
      terminal: forcedTerminal,
      events: collectRunEvents(chatEvents, forcedRunId),
    };

    const finishedAt = nowIso();

    const result = {
      startedAt,
      finishedAt,
      wsUrl: WS_URL,
      probeId,
      sessionKey,
      clientDistFile: runtime.fileName,
      hello,
      connected,
      lastClose,
      scenarios,
      rpcTrace,
      stats: {
        totalChatEvents: chatEvents.length,
        totalAgentLifecycleEvents: agentLifecycleEvents.length,
      },
      chatEvents,
      agentLifecycleEvents,
      observations: [
        "normal 流程出现 delta -> final。",
        "abort 流程出现 aborted，stopReason=rpc。",
        "invalidRequest 走 RPC 错误返回（无 run 启动）。",
        "forcedRuntimeErrorAttempt 中，invalid model 仍走到 final，未复现 chat.state=error。",
      ],
    };

    process.stdout.write(`${JSON.stringify(result, null, 2)}\n`);
  } finally {
    client.stop();
  }
}

await main();
</file>

<file path="plan/2026-02-16_ClawX源码调研/evidence/chat-stream-sse-live.json">
{
  "ok": true,
  "testedAt": "2026-02-16T08:01:34.735Z",
  "endpoint": "/api/chat/stream",
  "sessionKey": "agent:main:panel-chat-service-api-probe",
  "sendPayload": {
    "sessionKey": "agent:main:panel-chat-service-api-probe",
    "message": "1.5 SSE smoke test",
    "idempotencyKey": "panel-sse-1771228888719"
  },
  "sendResponse": {
    "ok": true,
    "result": {
      "sessionKey": "agent:main:panel-chat-service-api-probe",
      "runId": "panel-sse-1771228888719",
      "status": "started",
      "idempotencyKey": "panel-sse-1771228888719"
    }
  },
  "totalEvents": 12,
  "eventCounts": {
    "ready": 1,
    "status": 1,
    "agent": 7,
    "chat": 2,
    "terminal": 1
  },
  "terminalState": "final",
  "sampleStates": [
    "delta",
    "final"
  ]
}
</file>

<file path="plan/2026-02-16_ClawX源码调研/evidence/chat-user-workspace-live.md">
# Chat 用户工作台联调证据

时间：2026-02-16

## 验证步骤
1. `docker compose up -d --build panel` 重建面板容器。
2. 打开 `http://127.0.0.1:18080/chat-console`。
3. 确认侧栏入口名称为“智能对话”。
4. 点击“新建会话”，确认会话列表出现新 key。
5. 输入消息“你好，回复一句‘测试通过’即可。”并发送。
6. 观察消息区：用户消息和助手回复在消息气泡中展示。
7. 确认“停止回复”按钮在发送态自动启停，回复完成后恢复禁用。
8. 确认“高级调试信息”默认折叠，可展开查看原始历史和流事件。

## 实际结果
- 页面可访问且渲染正常。
- 新建会话成功，`/api/chat/session/new` 返回新 `sessionKey`。
- 发送消息后收到助手回复“测试通过”，流式通道状态为“已连接”。
- 无前端脚本异常；控制台 400 为既有 `POST /api/service/status` 环境错误，非本次改动引入。
</file>

<file path="plan/2026-02-16_ClawX源码调研/evidence/dashboard-overview-enhanced-live.md">
# 仪表盘状态总览增强运行态证据

时间：2026-02-16 17:02

## 验证目标

1. 仪表盘具备总览卡片（运行状态/模型/渠道/Skills/错误/版本）；
2. 仪表盘具备快捷操作入口与运行态明细列表；
3. 前端逻辑已接入总览刷新、错误摘要与版本状态同步；
4. Docker 重建后页面可用。

## 执行记录

1. 自动化测试
```bash
npm run test:unit
npm run test:regression
```
结果：
- `test:unit` 48/48 通过
- `test:regression` 3 passed, 1 skipped

2. Docker 重建
```bash
docker compose up -d --build panel
```
结果：`openclaw-panel` 成功重建并启动。

3. 页面结构校验
```powershell
$html=(Invoke-WebRequest -UseBasicParsing http://127.0.0.1:18080/dashboard).Content
```
检查项结果：
- `dashboard_summary_refresh` -> OK
- `dashboard_summary_runtime` -> OK
- `dashboard_channel_runtime_list` -> OK
- `data-dashboard-jump="panel-chat-console"` -> OK

4. 前端脚本逻辑校验
```powershell
$js=(Invoke-WebRequest -UseBasicParsing http://127.0.0.1:18080/app.js).Content
```
检查项结果：
- `updateDashboardSummaryCards` -> OK
- `updateDashboardErrorSummary` -> OK
- `updateDashboardVersionSummary` -> OK
- `dashboard_summary_refresh` -> OK

5. 后端聚合接口校验
```powershell
Invoke-WebRequest -UseBasicParsing http://127.0.0.1:18080/api/dashboard/summary
```
结果：返回 `ok: true`，包含 `runtime/model/channels/skills` 聚合结构。

## 结论

仪表盘已具备 ClawX 风格的一页式巡检能力，且在 Docker 运行态可稳定加载。
</file>

<file path="plan/2026-02-16_ClawX源码调研/evidence/dashboard-quick-model-switch-live.md">
# 仪表盘模型快速切换运行态证据

时间：2026-02-16 17:14

## 验证目标

1. 仪表盘可直接选择并切换默认模型；
2. 上下文降级风险提示可正确触发；
3. 仪表盘与模型页的上下文输入共享同一状态；
4. 功能在 Docker 运行态可用。

## 执行记录

1. 自动化测试
```bash
npm run test:unit
npm run test:regression
```
结果：
- `test:unit` 48/48 通过
- `test:regression` 3 passed, 1 skipped

2. Docker 重建
```bash
docker compose up -d --build panel
```
结果：`openclaw-panel` 成功重建并启动。

3. 页面元素校验（浏览器快照）
- 访问 `http://127.0.0.1:18080/dashboard`；
- 快照可见：
  - `当前会话上下文（Token）` 输入框；
  - `快速切换默认模型` 下拉框；
  - `切换当前默认模型` 按钮；
  - 目标模型提示行。

4. 风险提示触发校验（浏览器脚本）
执行脚本：
- 将上下文设为 `500000`；
- 选择目标模型 `aicodecat-claude/claude-sonnet-4-5-20250929`（`contextWindow=200000`）；
- 临时劫持 `window.confirm` 并触发切换按钮。

返回结果：
```json
{
  "ok": true,
  "target": "aicodecat-claude/claude-sonnet-4-5-20250929",
  "confirmCalled": 1,
  "confirmText": "当前会话上下文约 500,000，目标模型上限为 200,000。\n切换后可能因上下文超限报错，确认继续切换吗？",
  "contextValue": "500000"
}
```

5. 未确认切换时的当前模型状态
- 查询结果：
```json
{
  "currentModel": "gpt-5.2",
  "selectedQuickRef": "aicodecat-claude/claude-sonnet-4-5-20250929"
}
```
- 说明：在确认框返回 `false` 时，不会误切换当前模型。

## 结论

仪表盘模型快速切换与上下文风险提示已闭环，行为符合预期。
</file>

<file path="plan/2026-02-16_ClawX源码调研/evidence/dashboard-shoelace-2.4-live.md">
# Dashboard Shoelace 2.4 验证证据

## 1) 自动化测试
```bash
npm test
```
结果：通过（unit + regression）。

## 2) Docker 重建
```bash
docker compose up -d --build panel
```
结果：`openclaw-panel` 重新构建并启动成功。

## 3) 运行态可用性
```bash
GET http://127.0.0.1:18080/api/health
```
返回：`{"ok":true,...}`。

```bash
GET http://127.0.0.1:18080/shoelace/themes/light.css
```
返回：`200`。

## 4) 页面抽样检查
- 页面：`http://127.0.0.1:18080/dashboard`
- 观察项：
  - 仪表盘 KPI 卡片渲染正常
  - 运行态明细卡片渲染正常
  - 快捷操作按钮可点击
  - 模型快速切换下拉与按钮可交互
</file>

<file path="plan/2026-02-16_ClawX源码调研/evidence/dashboard-status-migration-live.md">
# 状态总览迁移到仪表盘运行态证据

时间：2026-02-16 17:08

## 验证目标

1. 侧栏不再显示“状态总览”独立入口；
2. 状态总览信息已收敛在“仪表盘”；
3. 历史路径 `/status-overview` 仍可访问并落到仪表盘视图；
4. 路由兼容行为有自动化验证覆盖。

## 执行记录

1. 自动化测试
```bash
npm run test:unit
npm run test:regression
```
结果：
- `test:unit` 48/48 通过（包含 `app-routes` 别名断言）
- `test:regression` 3 passed, 1 skipped

2. Docker 重建
```bash
docker compose up -d --build panel
```
结果：`openclaw-panel` 成功重建并启动。

3. 侧栏入口校验（静态）
```powershell
$html=(Invoke-WebRequest -UseBasicParsing http://127.0.0.1:18080/dashboard).Content
$html.Contains('data-tab-target="panel-status-overview"')
```
结果：`False`（侧栏已无独立入口）。

4. 路由兼容映射校验（静态）
```powershell
$routes=(Invoke-WebRequest -UseBasicParsing http://127.0.0.1:18080/app-routes.js).Content
```
检查项结果：
- 含 `if (path === "/status-overview") return "panel-dashboard"` -> OK
- 含 `isKnownPanelPath` 对 `/status-overview` 兼容 -> OK

5. 运行态页面校验（浏览器快照）
- 使用 Chrome DevTools MCP 打开 `http://127.0.0.1:18080/status-overview`。
- 快照结果显示：
  - 侧栏入口列表不含“状态总览”；
  - 主区域展示“仪表盘”内容（系统状态、状态总览卡片、快捷操作、运行态明细）。

## 结论

“系统状态模块从侧栏迁移到仪表盘”已完成，且旧链接仍兼容可用。
</file>

<file path="plan/2026-02-16_ClawX源码调研/evidence/dashboard-summary-live.json">
{
  "summary": {
    "runtimeActive": true,
    "runtimeChannelsRunning": 0,
    "modelTotal": 7,
    "skillsTotal": 53,
    "configuredChannelsEnabled": 0,
    "modelProviders": 4
  },
  "endpoint": "/api/dashboard/summary",
  "statusCode": 200,
  "ok": true,
  "testedAt": "2026-02-16 15:12:07 +08:00"
}
</file>

<file path="plan/2026-02-16_ClawX源码调研/evidence/docker-stability-7.3-live.md">
# 7.3 运行态证据：Docker 场景稳定性验证

时间：2026-02-16

## 验证目标

- 重启 `panel` 容器后，配置不漂移；
- 核心功能接口（Dashboard/Chat/Logs）可恢复；
- 健康检查在可接受时间内恢复。

## 执行步骤

1. 重启前采集基线：
   - `GET /api/settings`（模型与渠道开关）
   - `GET /api/skills/status`（skills 总数）
2. 执行 `docker compose restart panel`
3. 轮询 `GET /api/health` 直到恢复
4. 重启后再次采集基线并比对
5. 执行关键 smoke：
   - `GET /api/dashboard/summary`
   - `GET /api/chat/sessions`
   - `GET /api/logs/tail?lines=5`

## 结果（节选）

```json
{
  "healthRecovered": true,
  "configConsistent": true,
  "before": {
    "modelPrimary": "anthropic/default-model",
    "modelProvider": "anthropic",
    "modelId": "claude-sonnet-4-5-20250929",
    "skillsTotal": 49,
    "channels": {
      "telegram": false,
      "feishu": false,
      "discord": false,
      "slack": false
    }
  },
  "after": {
    "modelPrimary": "anthropic/default-model",
    "modelProvider": "anthropic",
    "modelId": "claude-sonnet-4-5-20250929",
    "skillsTotal": 49,
    "channels": {
      "telegram": false,
      "feishu": false,
      "discord": false,
      "slack": false
    }
  },
  "smoke": {
    "dashboardOk": true,
    "chatSessions": 21,
    "logTailLines": 5
  }
}
```

## 结论

- 容器重启后服务可恢复；
- 配置数据保持一致；
- 关键功能链路未受重启影响。
</file>

<file path="plan/2026-02-16_ClawX源码调研/evidence/docker-stability-live.json">
{
  "startedAt": "2026-02-16T06:49:16.283Z",
  "baseline": {
    "panelHealth": {
      "ok": true,
      "status": 200,
      "elapsedMs": 29,
      "body": {
        "ok": true,
        "service": "openclaw-panel",
        "timestamp": "2026-02-16T06:49:16.308Z"
      }
    },
    "serviceStatus": {
      "ok": true,
      "status": 200,
      "elapsedMs": 87,
      "body": {
        "ok": true,
        "result": {
          "ok": true,
          "action": "status",
          "runtimeMode": "docker",
          "containerName": "openclaw-gateway",
          "active": true,
          "output": "state: running\nCONTAINER ID   IMAGE                                 COMMAND                  CREATED          STATUS          PORTS                                             NAMES\na7a4c15cfee7   ghcr.io/openclaw/openclaw:2026.2.14   \"docker-entrypoint.s…\"   20 seconds ago   Up 19 seconds   0.0.0.0:18789->18789/tcp, [::]:18789->18789/tcp   openclaw-gateway"
        }
      }
    },
    "updateCheck": {
      "ok": true,
      "status": 200,
      "elapsedMs": 339,
      "body": {
        "ok": true,
        "result": {
          "ok": true,
          "containerName": "openclaw-gateway",
          "imageRepo": "ghcr.io/openclaw/openclaw",
          "releaseRepo": "openclaw/openclaw",
          "currentImage": "ghcr.io/openclaw/openclaw:2026.2.14",
          "currentTag": "2026.2.14",
          "latestTag": "2026.2.15",
          "latestPublishedAt": "2026-02-16T04:43:47Z",
          "updateAvailable": true,
          "warning": ""
        }
      }
    },
    "gatewayHome": {
      "ok": true,
      "status": 200,
      "elapsedMs": 30,
      "textPreview": "<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-w"
    },
    "containerState": {
      "ok": true,
      "command": "docker inspect -f \"{{.State.Status}}\" openclaw-gateway",
      "elapsedMs": 110,
      "stdout": "running"
    },
    "internalDnsProbe": {
      "ok": true,
      "command": "docker exec openclaw-panel node -e \"fetch('http://openclaw-gateway:18789/').then(r=>{console.log('status='+r.status);process.exit(r.ok?0:1)}).catch(e=>{console.error(String(e));process.exit(2)})\"",
      "elapsedMs": 255,
      "stdout": "status=200"
    }
  },
  "restart": {
    "command": {
      "ok": true,
      "command": "docker restart openclaw-gateway",
      "elapsedMs": 1209,
      "stdout": "openclaw-gateway"
    },
    "durationMs": 1209,
    "recovery": {
      "recovered": true,
      "attempts": [
        {
          "attempt": 1,
          "recovered": false,
          "probe": {
            "panelHealth": {
              "ok": true,
              "status": 200,
              "elapsedMs": 2,
              "body": {
                "ok": true,
                "service": "openclaw-panel",
                "timestamp": "2026-02-16T06:49:18.346Z"
              }
            },
            "serviceStatus": {
              "ok": true,
              "status": 200,
              "elapsedMs": 78,
              "body": {
                "ok": true,
                "result": {
                  "ok": true,
                  "action": "status",
                  "runtimeMode": "docker",
                  "containerName": "openclaw-gateway",
                  "active": true,
                  "output": "state: running\nCONTAINER ID   IMAGE                                 COMMAND                  CREATED          STATUS                  PORTS                                             NAMES\na7a4c15cfee7   ghcr.io/openclaw/openclaw:2026.2.14   \"docker-entrypoint.s…\"   22 seconds ago   Up Less than a second   0.0.0.0:18789->18789/tcp, [::]:18789->18789/tcp   openclaw-gateway"
                }
              }
            },
            "updateCheck": {
              "ok": true,
              "status": 200,
              "elapsedMs": 135,
              "body": {
                "ok": true,
                "result": {
                  "ok": true,
                  "containerName": "openclaw-gateway",
                  "imageRepo": "ghcr.io/openclaw/openclaw",
                  "releaseRepo": "openclaw/openclaw",
                  "currentImage": "ghcr.io/openclaw/openclaw:2026.2.14",
                  "currentTag": "2026.2.14",
                  "latestTag": "2026.2.15",
                  "latestPublishedAt": "2026-02-16T04:43:47Z",
                  "updateAvailable": true,
                  "warning": ""
                }
              }
            },
            "gatewayHome": {
              "ok": true,
              "status": 200,
              "elapsedMs": 31,
              "textPreview": "<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-w"
            },
            "containerState": {
              "ok": true,
              "command": "docker inspect -f \"{{.State.Status}}\" openclaw-gateway",
              "elapsedMs": 94,
              "stdout": "running"
            },
            "internalDnsProbe": {
              "ok": false,
              "command": "docker exec openclaw-panel node -e \"fetch('http://openclaw-gateway:18789/').then(r=>{console.log('status='+r.status);process.exit(r.ok?0:1)}).catch(e=>{console.error(String(e));process.exit(2)})\"",
              "elapsedMs": 201,
              "stdout": "",
              "stderr": "TypeError: fetch failed",
              "message": "Command failed: docker exec openclaw-panel node -e \"fetch('http://openclaw-gateway:18789/').then(r=>{console.log('status='+r.status);process.exit(r.ok?0:1)}).catch(e=>{console.error(String(e));process.exit(2)})\"\nTypeError: fetch failed\n"
            }
          }
        },
        {
          "attempt": 2,
          "recovered": false,
          "probe": {
            "panelHealth": {
              "ok": true,
              "status": 200,
              "elapsedMs": 3,
              "body": {
                "ok": true,
                "service": "openclaw-panel",
                "timestamp": "2026-02-16T06:49:19.904Z"
              }
            },
            "serviceStatus": {
              "ok": true,
              "status": 200,
              "elapsedMs": 74,
              "body": {
                "ok": true,
                "result": {
                  "ok": true,
                  "action": "status",
                  "runtimeMode": "docker",
                  "containerName": "openclaw-gateway",
                  "active": true,
                  "output": "state: running\nCONTAINER ID   IMAGE                                 COMMAND                  CREATED          STATUS        PORTS                                             NAMES\na7a4c15cfee7   ghcr.io/openclaw/openclaw:2026.2.14   \"docker-entrypoint.s…\"   23 seconds ago   Up 1 second   0.0.0.0:18789->18789/tcp, [::]:18789->18789/tcp   openclaw-gateway"
                }
              }
            },
            "updateCheck": {
              "ok": true,
              "status": 200,
              "elapsedMs": 212,
              "body": {
                "ok": true,
                "result": {
                  "ok": true,
                  "containerName": "openclaw-gateway",
                  "imageRepo": "ghcr.io/openclaw/openclaw",
                  "releaseRepo": "openclaw/openclaw",
                  "currentImage": "ghcr.io/openclaw/openclaw:2026.2.14",
                  "currentTag": "2026.2.14",
                  "latestTag": "2026.2.15",
                  "latestPublishedAt": "2026-02-16T04:43:47Z",
                  "updateAvailable": true,
                  "warning": ""
                }
              }
            },
            "gatewayHome": {
              "ok": true,
              "status": 200,
              "elapsedMs": 30,
              "textPreview": "<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-w"
            },
            "containerState": {
              "ok": true,
              "command": "docker inspect -f \"{{.State.Status}}\" openclaw-gateway",
              "elapsedMs": 90,
              "stdout": "running"
            },
            "internalDnsProbe": {
              "ok": false,
              "command": "docker exec openclaw-panel node -e \"fetch('http://openclaw-gateway:18789/').then(r=>{console.log('status='+r.status);process.exit(r.ok?0:1)}).catch(e=>{console.error(String(e));process.exit(2)})\"",
              "elapsedMs": 210,
              "stdout": "",
              "stderr": "TypeError: fetch failed",
              "message": "Command failed: docker exec openclaw-panel node -e \"fetch('http://openclaw-gateway:18789/').then(r=>{console.log('status='+r.status);process.exit(r.ok?0:1)}).catch(e=>{console.error(String(e));process.exit(2)})\"\nTypeError: fetch failed\n"
            }
          }
        },
        {
          "attempt": 3,
          "recovered": true,
          "probe": {
            "panelHealth": {
              "ok": true,
              "status": 200,
              "elapsedMs": 3,
              "body": {
                "ok": true,
                "service": "openclaw-panel",
                "timestamp": "2026-02-16T06:49:21.531Z"
              }
            },
            "serviceStatus": {
              "ok": true,
              "status": 200,
              "elapsedMs": 75,
              "body": {
                "ok": true,
                "result": {
                  "ok": true,
                  "action": "status",
                  "runtimeMode": "docker",
                  "containerName": "openclaw-gateway",
                  "active": true,
                  "output": "state: running\nCONTAINER ID   IMAGE                                 COMMAND                  CREATED          STATUS         PORTS                                             NAMES\na7a4c15cfee7   ghcr.io/openclaw/openclaw:2026.2.14   \"docker-entrypoint.s…\"   25 seconds ago   Up 3 seconds   0.0.0.0:18789->18789/tcp, [::]:18789->18789/tcp   openclaw-gateway"
                }
              }
            },
            "updateCheck": {
              "ok": true,
              "status": 200,
              "elapsedMs": 211,
              "body": {
                "ok": true,
                "result": {
                  "ok": true,
                  "containerName": "openclaw-gateway",
                  "imageRepo": "ghcr.io/openclaw/openclaw",
                  "releaseRepo": "openclaw/openclaw",
                  "currentImage": "ghcr.io/openclaw/openclaw:2026.2.14",
                  "currentTag": "2026.2.14",
                  "latestTag": "2026.2.15",
                  "latestPublishedAt": "2026-02-16T04:43:47Z",
                  "updateAvailable": true,
                  "warning": ""
                }
              }
            },
            "gatewayHome": {
              "ok": true,
              "status": 200,
              "elapsedMs": 27,
              "textPreview": "<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-w"
            },
            "containerState": {
              "ok": true,
              "command": "docker inspect -f \"{{.State.Status}}\" openclaw-gateway",
              "elapsedMs": 103,
              "stdout": "running"
            },
            "internalDnsProbe": {
              "ok": true,
              "command": "docker exec openclaw-panel node -e \"fetch('http://openclaw-gateway:18789/').then(r=>{console.log('status='+r.status);process.exit(r.ok?0:1)}).catch(e=>{console.error(String(e));process.exit(2)})\"",
              "elapsedMs": 219,
              "stdout": "status=200"
            }
          }
        }
      ]
    }
  },
  "networkIsolation": {
    "networkNameResult": {
      "ok": true,
      "command": "docker inspect -f \"{{range $k, $v := .NetworkSettings.Networks}}{{$k}}{{end}}\" openclaw-gateway",
      "elapsedMs": 92,
      "stdout": "openclaw-internal"
    },
    "networkName": "openclaw-internal",
    "disconnect": {
      "ok": true,
      "command": "docker network disconnect -f openclaw-internal openclaw-gateway",
      "elapsedMs": 512,
      "stdout": ""
    },
    "probeDuringIsolation": {
      "panelHealth": {
        "ok": true,
        "status": 200,
        "elapsedMs": 3,
        "body": {
          "ok": true,
          "service": "openclaw-panel",
          "timestamp": "2026-02-16T06:49:22.777Z"
        }
      },
      "serviceStatus": {
        "ok": true,
        "status": 200,
        "elapsedMs": 80,
        "body": {
          "ok": true,
          "result": {
            "ok": true,
            "action": "status",
            "runtimeMode": "docker",
            "containerName": "openclaw-gateway",
            "active": true,
            "output": "state: running\nCONTAINER ID   IMAGE                                 COMMAND                  CREATED          STATUS         PORTS                                             NAMES\na7a4c15cfee7   ghcr.io/openclaw/openclaw:2026.2.14   \"docker-entrypoint.s…\"   26 seconds ago   Up 4 seconds   0.0.0.0:18789->18789/tcp, [::]:18789->18789/tcp   openclaw-gateway"
          }
        }
      },
      "updateCheck": {
        "ok": true,
        "status": 200,
        "elapsedMs": 127,
        "body": {
          "ok": true,
          "result": {
            "ok": true,
            "containerName": "openclaw-gateway",
            "imageRepo": "ghcr.io/openclaw/openclaw",
            "releaseRepo": "openclaw/openclaw",
            "currentImage": "ghcr.io/openclaw/openclaw:2026.2.14",
            "currentTag": "2026.2.14",
            "latestTag": "2026.2.15",
            "latestPublishedAt": "2026-02-16T04:43:47Z",
            "updateAvailable": true,
            "warning": ""
          }
        }
      },
      "gatewayHome": {
        "ok": true,
        "status": 200,
        "elapsedMs": 30,
        "textPreview": "<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-w"
      },
      "containerState": {
        "ok": true,
        "command": "docker inspect -f \"{{.State.Status}}\" openclaw-gateway",
        "elapsedMs": 96,
        "stdout": "running"
      },
      "internalDnsProbe": {
        "ok": false,
        "command": "docker exec openclaw-panel node -e \"fetch('http://openclaw-gateway:18789/').then(r=>{console.log('status='+r.status);process.exit(r.ok?0:1)}).catch(e=>{console.error(String(e));process.exit(2)})\"",
        "elapsedMs": 1494,
        "stdout": "",
        "stderr": "TypeError: fetch failed",
        "message": "Command failed: docker exec openclaw-panel node -e \"fetch('http://openclaw-gateway:18789/').then(r=>{console.log('status='+r.status);process.exit(r.ok?0:1)}).catch(e=>{console.error(String(e));process.exit(2)})\"\nTypeError: fetch failed\n"
      }
    },
    "reconnect": {
      "ok": true,
      "command": "docker network connect openclaw-internal openclaw-gateway",
      "elapsedMs": 232,
      "stdout": ""
    },
    "recovery": {
      "recovered": true,
      "attempts": [
        {
          "attempt": 1,
          "recovered": true,
          "probe": {
            "panelHealth": {
              "ok": true,
              "status": 200,
              "elapsedMs": 2,
              "body": {
                "ok": true,
                "service": "openclaw-panel",
                "timestamp": "2026-02-16T06:49:24.844Z"
              }
            },
            "serviceStatus": {
              "ok": true,
              "status": 200,
              "elapsedMs": 77,
              "body": {
                "ok": true,
                "result": {
                  "ok": true,
                  "action": "status",
                  "runtimeMode": "docker",
                  "containerName": "openclaw-gateway",
                  "active": true,
                  "output": "state: running\nCONTAINER ID   IMAGE                                 COMMAND                  CREATED          STATUS         PORTS                                             NAMES\na7a4c15cfee7   ghcr.io/openclaw/openclaw:2026.2.14   \"docker-entrypoint.s…\"   28 seconds ago   Up 6 seconds   0.0.0.0:18789->18789/tcp, [::]:18789->18789/tcp   openclaw-gateway"
                }
              }
            },
            "updateCheck": {
              "ok": true,
              "status": 200,
              "elapsedMs": 126,
              "body": {
                "ok": true,
                "result": {
                  "ok": true,
                  "containerName": "openclaw-gateway",
                  "imageRepo": "ghcr.io/openclaw/openclaw",
                  "releaseRepo": "openclaw/openclaw",
                  "currentImage": "ghcr.io/openclaw/openclaw:2026.2.14",
                  "currentTag": "2026.2.14",
                  "latestTag": "2026.2.15",
                  "latestPublishedAt": "2026-02-16T04:43:47Z",
                  "updateAvailable": true,
                  "warning": ""
                }
              }
            },
            "gatewayHome": {
              "ok": true,
              "status": 200,
              "elapsedMs": 31,
              "textPreview": "<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-w"
            },
            "containerState": {
              "ok": true,
              "command": "docker inspect -f \"{{.State.Status}}\" openclaw-gateway",
              "elapsedMs": 92,
              "stdout": "running"
            },
            "internalDnsProbe": {
              "ok": true,
              "command": "docker exec openclaw-panel node -e \"fetch('http://openclaw-gateway:18789/').then(r=>{console.log('status='+r.status);process.exit(r.ok?0:1)}).catch(e=>{console.error(String(e));process.exit(2)})\"",
              "elapsedMs": 227,
              "stdout": "status=200"
            }
          }
        }
      ]
    }
  },
  "upgradeDrill": {
    "checkBeforeUpgrade": {
      "ok": true,
      "status": 200,
      "elapsedMs": 244,
      "body": {
        "ok": true,
        "result": {
          "ok": true,
          "containerName": "openclaw-gateway",
          "imageRepo": "ghcr.io/openclaw/openclaw",
          "releaseRepo": "openclaw/openclaw",
          "currentImage": "ghcr.io/openclaw/openclaw:2026.2.14",
          "currentTag": "2026.2.14",
          "latestTag": "2026.2.15",
          "latestPublishedAt": "2026-02-16T04:43:47Z",
          "updateAvailable": true,
          "warning": ""
        }
      }
    },
    "currentTag": "2026.2.14",
    "upgrade": {
      "ok": true,
      "status": 200,
      "elapsedMs": 2059,
      "body": {
        "ok": true,
        "result": {
          "ok": true,
          "action": "upgrade",
          "containerName": "openclaw-gateway",
          "targetImage": "ghcr.io/openclaw/openclaw:2026.2.14",
          "oldImage": "ghcr.io/openclaw/openclaw:2026.2.14",
          "rolledBack": false,
          "message": "upgrade 成功"
        }
      }
    },
    "afterUpgradeProbe": {
      "panelHealth": {
        "ok": true,
        "status": 200,
        "elapsedMs": 2,
        "body": {
          "ok": true,
          "service": "openclaw-panel",
          "timestamp": "2026-02-16T06:49:27.712Z"
        }
      },
      "serviceStatus": {
        "ok": true,
        "status": 200,
        "elapsedMs": 97,
        "body": {
          "ok": true,
          "result": {
            "ok": true,
            "action": "status",
            "runtimeMode": "docker",
            "containerName": "openclaw-gateway",
            "active": true,
            "output": "state: running\nCONTAINER ID   IMAGE                                 COMMAND                  CREATED                  STATUS                  PORTS                                             NAMES\n1066146bd00c   ghcr.io/openclaw/openclaw:2026.2.14   \"docker-entrypoint.s…\"   Less than a second ago   Up Less than a second   0.0.0.0:18789->18789/tcp, [::]:18789->18789/tcp   openclaw-gateway"
          }
        }
      },
      "updateCheck": {
        "ok": true,
        "status": 200,
        "elapsedMs": 171,
        "body": {
          "ok": true,
          "result": {
            "ok": true,
            "containerName": "openclaw-gateway",
            "imageRepo": "ghcr.io/openclaw/openclaw",
            "releaseRepo": "openclaw/openclaw",
            "currentImage": "ghcr.io/openclaw/openclaw:2026.2.14",
            "currentTag": "2026.2.14",
            "latestTag": "2026.2.15",
            "latestPublishedAt": "2026-02-16T04:43:47Z",
            "updateAvailable": true,
            "warning": ""
          }
        }
      },
      "gatewayHome": {
        "ok": true,
        "status": 200,
        "elapsedMs": 26,
        "textPreview": "<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-w"
      },
      "containerState": {
        "ok": true,
        "command": "docker inspect -f \"{{.State.Status}}\" openclaw-gateway",
        "elapsedMs": 101,
        "stdout": "running"
      },
      "internalDnsProbe": {
        "ok": false,
        "command": "docker exec openclaw-panel node -e \"fetch('http://openclaw-gateway:18789/').then(r=>{console.log('status='+r.status);process.exit(r.ok?0:1)}).catch(e=>{console.error(String(e));process.exit(2)})\"",
        "elapsedMs": 203,
        "stdout": "",
        "stderr": "TypeError: fetch failed",
        "message": "Command failed: docker exec openclaw-panel node -e \"fetch('http://openclaw-gateway:18789/').then(r=>{console.log('status='+r.status);process.exit(r.ok?0:1)}).catch(e=>{console.error(String(e));process.exit(2)})\"\nTypeError: fetch failed\n"
      }
    },
    "afterUpgradeRecovery": {
      "recovered": true,
      "attempts": [
        {
          "attempt": 1,
          "recovered": false,
          "probe": {
            "panelHealth": {
              "ok": true,
              "status": 200,
              "elapsedMs": 3,
              "body": {
                "ok": true,
                "service": "openclaw-panel",
                "timestamp": "2026-02-16T06:49:28.315Z"
              }
            },
            "serviceStatus": {
              "ok": true,
              "status": 200,
              "elapsedMs": 87,
              "body": {
                "ok": true,
                "result": {
                  "ok": true,
                  "action": "status",
                  "runtimeMode": "docker",
                  "containerName": "openclaw-gateway",
                  "active": true,
                  "output": "state: running\nCONTAINER ID   IMAGE                                 COMMAND                  CREATED        STATUS                  PORTS                                             NAMES\n1066146bd00c   ghcr.io/openclaw/openclaw:2026.2.14   \"docker-entrypoint.s…\"   1 second ago   Up Less than a second   0.0.0.0:18789->18789/tcp, [::]:18789->18789/tcp   openclaw-gateway"
                }
              }
            },
            "updateCheck": {
              "ok": true,
              "status": 200,
              "elapsedMs": 211,
              "body": {
                "ok": true,
                "result": {
                  "ok": true,
                  "containerName": "openclaw-gateway",
                  "imageRepo": "ghcr.io/openclaw/openclaw",
                  "releaseRepo": "openclaw/openclaw",
                  "currentImage": "ghcr.io/openclaw/openclaw:2026.2.14",
                  "currentTag": "2026.2.14",
                  "latestTag": "2026.2.15",
                  "latestPublishedAt": "2026-02-16T04:43:47Z",
                  "updateAvailable": true,
                  "warning": ""
                }
              }
            },
            "gatewayHome": {
              "ok": true,
              "status": 200,
              "elapsedMs": 31,
              "textPreview": "<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-w"
            },
            "containerState": {
              "ok": true,
              "command": "docker inspect -f \"{{.State.Status}}\" openclaw-gateway",
              "elapsedMs": 95,
              "stdout": "running"
            },
            "internalDnsProbe": {
              "ok": false,
              "command": "docker exec openclaw-panel node -e \"fetch('http://openclaw-gateway:18789/').then(r=>{console.log('status='+r.status);process.exit(r.ok?0:1)}).catch(e=>{console.error(String(e));process.exit(2)})\"",
              "elapsedMs": 202,
              "stdout": "",
              "stderr": "TypeError: fetch failed",
              "message": "Command failed: docker exec openclaw-panel node -e \"fetch('http://openclaw-gateway:18789/').then(r=>{console.log('status='+r.status);process.exit(r.ok?0:1)}).catch(e=>{console.error(String(e));process.exit(2)})\"\nTypeError: fetch failed\n"
            }
          }
        },
        {
          "attempt": 2,
          "recovered": false,
          "probe": {
            "panelHealth": {
              "ok": true,
              "status": 200,
              "elapsedMs": 2,
              "body": {
                "ok": true,
                "service": "openclaw-panel",
                "timestamp": "2026-02-16T06:49:29.958Z"
              }
            },
            "serviceStatus": {
              "ok": true,
              "status": 200,
              "elapsedMs": 79,
              "body": {
                "ok": true,
                "result": {
                  "ok": true,
                  "action": "status",
                  "runtimeMode": "docker",
                  "containerName": "openclaw-gateway",
                  "active": true,
                  "output": "state: running\nCONTAINER ID   IMAGE                                 COMMAND                  CREATED         STATUS         PORTS                                             NAMES\n1066146bd00c   ghcr.io/openclaw/openclaw:2026.2.14   \"docker-entrypoint.s…\"   3 seconds ago   Up 2 seconds   0.0.0.0:18789->18789/tcp, [::]:18789->18789/tcp   openclaw-gateway"
                }
              }
            },
            "updateCheck": {
              "ok": true,
              "status": 200,
              "elapsedMs": 208,
              "body": {
                "ok": true,
                "result": {
                  "ok": true,
                  "containerName": "openclaw-gateway",
                  "imageRepo": "ghcr.io/openclaw/openclaw",
                  "releaseRepo": "openclaw/openclaw",
                  "currentImage": "ghcr.io/openclaw/openclaw:2026.2.14",
                  "currentTag": "2026.2.14",
                  "latestTag": "2026.2.15",
                  "latestPublishedAt": "2026-02-16T04:43:47Z",
                  "updateAvailable": true,
                  "warning": ""
                }
              }
            },
            "gatewayHome": {
              "ok": true,
              "status": 200,
              "elapsedMs": 16,
              "textPreview": "<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-w"
            },
            "containerState": {
              "ok": true,
              "command": "docker inspect -f \"{{.State.Status}}\" openclaw-gateway",
              "elapsedMs": 110,
              "stdout": "running"
            },
            "internalDnsProbe": {
              "ok": false,
              "command": "docker exec openclaw-panel node -e \"fetch('http://openclaw-gateway:18789/').then(r=>{console.log('status='+r.status);process.exit(r.ok?0:1)}).catch(e=>{console.error(String(e));process.exit(2)})\"",
              "elapsedMs": 203,
              "stdout": "",
              "stderr": "TypeError: fetch failed",
              "message": "Command failed: docker exec openclaw-panel node -e \"fetch('http://openclaw-gateway:18789/').then(r=>{console.log('status='+r.status);process.exit(r.ok?0:1)}).catch(e=>{console.error(String(e));process.exit(2)})\"\nTypeError: fetch failed\n"
            }
          }
        },
        {
          "attempt": 3,
          "recovered": false,
          "probe": {
            "panelHealth": {
              "ok": true,
              "status": 200,
              "elapsedMs": 3,
              "body": {
                "ok": true,
                "service": "openclaw-panel",
                "timestamp": "2026-02-16T06:49:31.598Z"
              }
            },
            "serviceStatus": {
              "ok": true,
              "status": 200,
              "elapsedMs": 75,
              "body": {
                "ok": true,
                "result": {
                  "ok": true,
                  "action": "status",
                  "runtimeMode": "docker",
                  "containerName": "openclaw-gateway",
                  "active": true,
                  "output": "state: running\nCONTAINER ID   IMAGE                                 COMMAND                  CREATED         STATUS         PORTS                                             NAMES\n1066146bd00c   ghcr.io/openclaw/openclaw:2026.2.14   \"docker-entrypoint.s…\"   4 seconds ago   Up 4 seconds   0.0.0.0:18789->18789/tcp, [::]:18789->18789/tcp   openclaw-gateway"
                }
              }
            },
            "updateCheck": {
              "ok": true,
              "status": 200,
              "elapsedMs": 164,
              "body": {
                "ok": true,
                "result": {
                  "ok": true,
                  "containerName": "openclaw-gateway",
                  "imageRepo": "ghcr.io/openclaw/openclaw",
                  "releaseRepo": "openclaw/openclaw",
                  "currentImage": "ghcr.io/openclaw/openclaw:2026.2.14",
                  "currentTag": "2026.2.14",
                  "latestTag": "2026.2.15",
                  "latestPublishedAt": "2026-02-16T04:43:47Z",
                  "updateAvailable": true,
                  "warning": ""
                }
              }
            },
            "gatewayHome": {
              "ok": true,
              "status": 200,
              "elapsedMs": 27,
              "textPreview": "<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-w"
            },
            "containerState": {
              "ok": true,
              "command": "docker inspect -f \"{{.State.Status}}\" openclaw-gateway",
              "elapsedMs": 141,
              "stdout": "running"
            },
            "internalDnsProbe": {
              "ok": false,
              "command": "docker exec openclaw-panel node -e \"fetch('http://openclaw-gateway:18789/').then(r=>{console.log('status='+r.status);process.exit(r.ok?0:1)}).catch(e=>{console.error(String(e));process.exit(2)})\"",
              "elapsedMs": 212,
              "stdout": "",
              "stderr": "TypeError: fetch failed",
              "message": "Command failed: docker exec openclaw-panel node -e \"fetch('http://openclaw-gateway:18789/').then(r=>{console.log('status='+r.status);process.exit(r.ok?0:1)}).catch(e=>{console.error(String(e));process.exit(2)})\"\nTypeError: fetch failed\n"
            }
          }
        },
        {
          "attempt": 4,
          "recovered": false,
          "probe": {
            "panelHealth": {
              "ok": true,
              "status": 200,
              "elapsedMs": 3,
              "body": {
                "ok": true,
                "service": "openclaw-panel",
                "timestamp": "2026-02-16T06:49:33.236Z"
              }
            },
            "serviceStatus": {
              "ok": true,
              "status": 200,
              "elapsedMs": 112,
              "body": {
                "ok": true,
                "result": {
                  "ok": true,
                  "action": "status",
                  "runtimeMode": "docker",
                  "containerName": "openclaw-gateway",
                  "active": true,
                  "output": "state: running\nCONTAINER ID   IMAGE                                 COMMAND                  CREATED         STATUS         PORTS                                             NAMES\n1066146bd00c   ghcr.io/openclaw/openclaw:2026.2.14   \"docker-entrypoint.s…\"   6 seconds ago   Up 5 seconds   0.0.0.0:18789->18789/tcp, [::]:18789->18789/tcp   openclaw-gateway"
                }
              }
            },
            "updateCheck": {
              "ok": true,
              "status": 200,
              "elapsedMs": 188,
              "body": {
                "ok": true,
                "result": {
                  "ok": true,
                  "containerName": "openclaw-gateway",
                  "imageRepo": "ghcr.io/openclaw/openclaw",
                  "releaseRepo": "openclaw/openclaw",
                  "currentImage": "ghcr.io/openclaw/openclaw:2026.2.14",
                  "currentTag": "2026.2.14",
                  "latestTag": "2026.2.15",
                  "latestPublishedAt": "2026-02-16T04:43:47Z",
                  "updateAvailable": true,
                  "warning": ""
                }
              }
            },
            "gatewayHome": {
              "ok": true,
              "status": 200,
              "elapsedMs": 31,
              "textPreview": "<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-w"
            },
            "containerState": {
              "ok": true,
              "command": "docker inspect -f \"{{.State.Status}}\" openclaw-gateway",
              "elapsedMs": 111,
              "stdout": "running"
            },
            "internalDnsProbe": {
              "ok": false,
              "command": "docker exec openclaw-panel node -e \"fetch('http://openclaw-gateway:18789/').then(r=>{console.log('status='+r.status);process.exit(r.ok?0:1)}).catch(e=>{console.error(String(e));process.exit(2)})\"",
              "elapsedMs": 216,
              "stdout": "",
              "stderr": "TypeError: fetch failed",
              "message": "Command failed: docker exec openclaw-panel node -e \"fetch('http://openclaw-gateway:18789/').then(r=>{console.log('status='+r.status);process.exit(r.ok?0:1)}).catch(e=>{console.error(String(e));process.exit(2)})\"\nTypeError: fetch failed\n"
            }
          }
        },
        {
          "attempt": 5,
          "recovered": false,
          "probe": {
            "panelHealth": {
              "ok": true,
              "status": 200,
              "elapsedMs": 3,
              "body": {
                "ok": true,
                "service": "openclaw-panel",
                "timestamp": "2026-02-16T06:49:34.915Z"
              }
            },
            "serviceStatus": {
              "ok": true,
              "status": 200,
              "elapsedMs": 86,
              "body": {
                "ok": true,
                "result": {
                  "ok": true,
                  "action": "status",
                  "runtimeMode": "docker",
                  "containerName": "openclaw-gateway",
                  "active": true,
                  "output": "state: running\nCONTAINER ID   IMAGE                                 COMMAND                  CREATED         STATUS         PORTS                                             NAMES\n1066146bd00c   ghcr.io/openclaw/openclaw:2026.2.14   \"docker-entrypoint.s…\"   7 seconds ago   Up 7 seconds   0.0.0.0:18789->18789/tcp, [::]:18789->18789/tcp   openclaw-gateway"
                }
              }
            },
            "updateCheck": {
              "ok": true,
              "status": 200,
              "elapsedMs": 160,
              "body": {
                "ok": true,
                "result": {
                  "ok": true,
                  "containerName": "openclaw-gateway",
                  "imageRepo": "ghcr.io/openclaw/openclaw",
                  "releaseRepo": "openclaw/openclaw",
                  "currentImage": "ghcr.io/openclaw/openclaw:2026.2.14",
                  "currentTag": "2026.2.14",
                  "latestTag": "2026.2.15",
                  "latestPublishedAt": "2026-02-16T04:43:47Z",
                  "updateAvailable": true,
                  "warning": ""
                }
              }
            },
            "gatewayHome": {
              "ok": true,
              "status": 200,
              "elapsedMs": 29,
              "textPreview": "<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-w"
            },
            "containerState": {
              "ok": true,
              "command": "docker inspect -f \"{{.State.Status}}\" openclaw-gateway",
              "elapsedMs": 98,
              "stdout": "running"
            },
            "internalDnsProbe": {
              "ok": false,
              "command": "docker exec openclaw-panel node -e \"fetch('http://openclaw-gateway:18789/').then(r=>{console.log('status='+r.status);process.exit(r.ok?0:1)}).catch(e=>{console.error(String(e));process.exit(2)})\"",
              "elapsedMs": 194,
              "stdout": "",
              "stderr": "TypeError: fetch failed",
              "message": "Command failed: docker exec openclaw-panel node -e \"fetch('http://openclaw-gateway:18789/').then(r=>{console.log('status='+r.status);process.exit(r.ok?0:1)}).catch(e=>{console.error(String(e));process.exit(2)})\"\nTypeError: fetch failed\n"
            }
          }
        },
        {
          "attempt": 6,
          "recovered": false,
          "probe": {
            "panelHealth": {
              "ok": true,
              "status": 200,
              "elapsedMs": 3,
              "body": {
                "ok": true,
                "service": "openclaw-panel",
                "timestamp": "2026-02-16T06:49:36.502Z"
              }
            },
            "serviceStatus": {
              "ok": true,
              "status": 200,
              "elapsedMs": 85,
              "body": {
                "ok": true,
                "result": {
                  "ok": true,
                  "action": "status",
                  "runtimeMode": "docker",
                  "containerName": "openclaw-gateway",
                  "active": true,
                  "output": "state: running\nCONTAINER ID   IMAGE                                 COMMAND                  CREATED         STATUS         PORTS                                             NAMES\n1066146bd00c   ghcr.io/openclaw/openclaw:2026.2.14   \"docker-entrypoint.s…\"   9 seconds ago   Up 9 seconds   0.0.0.0:18789->18789/tcp, [::]:18789->18789/tcp   openclaw-gateway"
                }
              }
            },
            "updateCheck": {
              "ok": true,
              "status": 200,
              "elapsedMs": 165,
              "body": {
                "ok": true,
                "result": {
                  "ok": true,
                  "containerName": "openclaw-gateway",
                  "imageRepo": "ghcr.io/openclaw/openclaw",
                  "releaseRepo": "openclaw/openclaw",
                  "currentImage": "ghcr.io/openclaw/openclaw:2026.2.14",
                  "currentTag": "2026.2.14",
                  "latestTag": "2026.2.15",
                  "latestPublishedAt": "2026-02-16T04:43:47Z",
                  "updateAvailable": true,
                  "warning": ""
                }
              }
            },
            "gatewayHome": {
              "ok": true,
              "status": 200,
              "elapsedMs": 31,
              "textPreview": "<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-w"
            },
            "containerState": {
              "ok": true,
              "command": "docker inspect -f \"{{.State.Status}}\" openclaw-gateway",
              "elapsedMs": 117,
              "stdout": "running"
            },
            "internalDnsProbe": {
              "ok": false,
              "command": "docker exec openclaw-panel node -e \"fetch('http://openclaw-gateway:18789/').then(r=>{console.log('status='+r.status);process.exit(r.ok?0:1)}).catch(e=>{console.error(String(e));process.exit(2)})\"",
              "elapsedMs": 227,
              "stdout": "",
              "stderr": "TypeError: fetch failed",
              "message": "Command failed: docker exec openclaw-panel node -e \"fetch('http://openclaw-gateway:18789/').then(r=>{console.log('status='+r.status);process.exit(r.ok?0:1)}).catch(e=>{console.error(String(e));process.exit(2)})\"\nTypeError: fetch failed\n"
            }
          }
        },
        {
          "attempt": 7,
          "recovered": false,
          "probe": {
            "panelHealth": {
              "ok": true,
              "status": 200,
              "elapsedMs": 3,
              "body": {
                "ok": true,
                "service": "openclaw-panel",
                "timestamp": "2026-02-16T06:49:38.141Z"
              }
            },
            "serviceStatus": {
              "ok": true,
              "status": 200,
              "elapsedMs": 82,
              "body": {
                "ok": true,
                "result": {
                  "ok": true,
                  "action": "status",
                  "runtimeMode": "docker",
                  "containerName": "openclaw-gateway",
                  "active": true,
                  "output": "state: running\nCONTAINER ID   IMAGE                                 COMMAND                  CREATED          STATUS          PORTS                                             NAMES\n1066146bd00c   ghcr.io/openclaw/openclaw:2026.2.14   \"docker-entrypoint.s…\"   11 seconds ago   Up 10 seconds   0.0.0.0:18789->18789/tcp, [::]:18789->18789/tcp   openclaw-gateway"
                }
              }
            },
            "updateCheck": {
              "ok": true,
              "status": 200,
              "elapsedMs": 163,
              "body": {
                "ok": true,
                "result": {
                  "ok": true,
                  "containerName": "openclaw-gateway",
                  "imageRepo": "ghcr.io/openclaw/openclaw",
                  "releaseRepo": "openclaw/openclaw",
                  "currentImage": "ghcr.io/openclaw/openclaw:2026.2.14",
                  "currentTag": "2026.2.14",
                  "latestTag": "2026.2.15",
                  "latestPublishedAt": "2026-02-16T04:43:47Z",
                  "updateAvailable": true,
                  "warning": ""
                }
              }
            },
            "gatewayHome": {
              "ok": true,
              "status": 200,
              "elapsedMs": 29,
              "textPreview": "<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-w"
            },
            "containerState": {
              "ok": true,
              "command": "docker inspect -f \"{{.State.Status}}\" openclaw-gateway",
              "elapsedMs": 99,
              "stdout": "running"
            },
            "internalDnsProbe": {
              "ok": false,
              "command": "docker exec openclaw-panel node -e \"fetch('http://openclaw-gateway:18789/').then(r=>{console.log('status='+r.status);process.exit(r.ok?0:1)}).catch(e=>{console.error(String(e));process.exit(2)})\"",
              "elapsedMs": 211,
              "stdout": "",
              "stderr": "TypeError: fetch failed",
              "message": "Command failed: docker exec openclaw-panel node -e \"fetch('http://openclaw-gateway:18789/').then(r=>{console.log('status='+r.status);process.exit(r.ok?0:1)}).catch(e=>{console.error(String(e));process.exit(2)})\"\nTypeError: fetch failed\n"
            }
          }
        },
        {
          "attempt": 8,
          "recovered": false,
          "probe": {
            "panelHealth": {
              "ok": true,
              "status": 200,
              "elapsedMs": 3,
              "body": {
                "ok": true,
                "service": "openclaw-panel",
                "timestamp": "2026-02-16T06:49:39.742Z"
              }
            },
            "serviceStatus": {
              "ok": true,
              "status": 200,
              "elapsedMs": 76,
              "body": {
                "ok": true,
                "result": {
                  "ok": true,
                  "action": "status",
                  "runtimeMode": "docker",
                  "containerName": "openclaw-gateway",
                  "active": true,
                  "output": "state: running\nCONTAINER ID   IMAGE                                 COMMAND                  CREATED          STATUS          PORTS                                             NAMES\n1066146bd00c   ghcr.io/openclaw/openclaw:2026.2.14   \"docker-entrypoint.s…\"   12 seconds ago   Up 12 seconds   0.0.0.0:18789->18789/tcp, [::]:18789->18789/tcp   openclaw-gateway"
                }
              }
            },
            "updateCheck": {
              "ok": true,
              "status": 200,
              "elapsedMs": 189,
              "body": {
                "ok": true,
                "result": {
                  "ok": true,
                  "containerName": "openclaw-gateway",
                  "imageRepo": "ghcr.io/openclaw/openclaw",
                  "releaseRepo": "openclaw/openclaw",
                  "currentImage": "ghcr.io/openclaw/openclaw:2026.2.14",
                  "currentTag": "2026.2.14",
                  "latestTag": "2026.2.15",
                  "latestPublishedAt": "2026-02-16T04:43:47Z",
                  "updateAvailable": true,
                  "warning": ""
                }
              }
            },
            "gatewayHome": {
              "ok": true,
              "status": 200,
              "elapsedMs": 28,
              "textPreview": "<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-w"
            },
            "containerState": {
              "ok": true,
              "command": "docker inspect -f \"{{.State.Status}}\" openclaw-gateway",
              "elapsedMs": 95,
              "stdout": "running"
            },
            "internalDnsProbe": {
              "ok": false,
              "command": "docker exec openclaw-panel node -e \"fetch('http://openclaw-gateway:18789/').then(r=>{console.log('status='+r.status);process.exit(r.ok?0:1)}).catch(e=>{console.error(String(e));process.exit(2)})\"",
              "elapsedMs": 190,
              "stdout": "",
              "stderr": "TypeError: fetch failed",
              "message": "Command failed: docker exec openclaw-panel node -e \"fetch('http://openclaw-gateway:18789/').then(r=>{console.log('status='+r.status);process.exit(r.ok?0:1)}).catch(e=>{console.error(String(e));process.exit(2)})\"\nTypeError: fetch failed\n"
            }
          }
        },
        {
          "attempt": 9,
          "recovered": false,
          "probe": {
            "panelHealth": {
              "ok": true,
              "status": 200,
              "elapsedMs": 3,
              "body": {
                "ok": true,
                "service": "openclaw-panel",
                "timestamp": "2026-02-16T06:49:41.340Z"
              }
            },
            "serviceStatus": {
              "ok": true,
              "status": 200,
              "elapsedMs": 73,
              "body": {
                "ok": true,
                "result": {
                  "ok": true,
                  "action": "status",
                  "runtimeMode": "docker",
                  "containerName": "openclaw-gateway",
                  "active": true,
                  "output": "state: running\nCONTAINER ID   IMAGE                                 COMMAND                  CREATED          STATUS          PORTS                                             NAMES\n1066146bd00c   ghcr.io/openclaw/openclaw:2026.2.14   \"docker-entrypoint.s…\"   14 seconds ago   Up 13 seconds   0.0.0.0:18789->18789/tcp, [::]:18789->18789/tcp   openclaw-gateway"
                }
              }
            },
            "updateCheck": {
              "ok": true,
              "status": 200,
              "elapsedMs": 190,
              "body": {
                "ok": true,
                "result": {
                  "ok": true,
                  "containerName": "openclaw-gateway",
                  "imageRepo": "ghcr.io/openclaw/openclaw",
                  "releaseRepo": "openclaw/openclaw",
                  "currentImage": "ghcr.io/openclaw/openclaw:2026.2.14",
                  "currentTag": "2026.2.14",
                  "latestTag": "2026.2.15",
                  "latestPublishedAt": "2026-02-16T04:43:47Z",
                  "updateAvailable": true,
                  "warning": ""
                }
              }
            },
            "gatewayHome": {
              "ok": true,
              "status": 200,
              "elapsedMs": 31,
              "textPreview": "<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-w"
            },
            "containerState": {
              "ok": true,
              "command": "docker inspect -f \"{{.State.Status}}\" openclaw-gateway",
              "elapsedMs": 95,
              "stdout": "running"
            },
            "internalDnsProbe": {
              "ok": false,
              "command": "docker exec openclaw-panel node -e \"fetch('http://openclaw-gateway:18789/').then(r=>{console.log('status='+r.status);process.exit(r.ok?0:1)}).catch(e=>{console.error(String(e));process.exit(2)})\"",
              "elapsedMs": 199,
              "stdout": "",
              "stderr": "TypeError: fetch failed",
              "message": "Command failed: docker exec openclaw-panel node -e \"fetch('http://openclaw-gateway:18789/').then(r=>{console.log('status='+r.status);process.exit(r.ok?0:1)}).catch(e=>{console.error(String(e));process.exit(2)})\"\nTypeError: fetch failed\n"
            }
          }
        },
        {
          "attempt": 10,
          "recovered": true,
          "probe": {
            "panelHealth": {
              "ok": true,
              "status": 200,
              "elapsedMs": 4,
              "body": {
                "ok": true,
                "service": "openclaw-panel",
                "timestamp": "2026-02-16T06:49:42.865Z"
              }
            },
            "serviceStatus": {
              "ok": true,
              "status": 200,
              "elapsedMs": 78,
              "body": {
                "ok": true,
                "result": {
                  "ok": true,
                  "action": "status",
                  "runtimeMode": "docker",
                  "containerName": "openclaw-gateway",
                  "active": true,
                  "output": "state: running\nCONTAINER ID   IMAGE                                 COMMAND                  CREATED          STATUS          PORTS                                             NAMES\n1066146bd00c   ghcr.io/openclaw/openclaw:2026.2.14   \"docker-entrypoint.s…\"   15 seconds ago   Up 15 seconds   0.0.0.0:18789->18789/tcp, [::]:18789->18789/tcp   openclaw-gateway"
                }
              }
            },
            "updateCheck": {
              "ok": true,
              "status": 200,
              "elapsedMs": 191,
              "body": {
                "ok": true,
                "result": {
                  "ok": true,
                  "containerName": "openclaw-gateway",
                  "imageRepo": "ghcr.io/openclaw/openclaw",
                  "releaseRepo": "openclaw/openclaw",
                  "currentImage": "ghcr.io/openclaw/openclaw:2026.2.14",
                  "currentTag": "2026.2.14",
                  "latestTag": "2026.2.15",
                  "latestPublishedAt": "2026-02-16T04:43:47Z",
                  "updateAvailable": true,
                  "warning": ""
                }
              }
            },
            "gatewayHome": {
              "ok": true,
              "status": 200,
              "elapsedMs": 28,
              "textPreview": "<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-w"
            },
            "containerState": {
              "ok": true,
              "command": "docker inspect -f \"{{.State.Status}}\" openclaw-gateway",
              "elapsedMs": 98,
              "stdout": "running"
            },
            "internalDnsProbe": {
              "ok": true,
              "command": "docker exec openclaw-panel node -e \"fetch('http://openclaw-gateway:18789/').then(r=>{console.log('status='+r.status);process.exit(r.ok?0:1)}).catch(e=>{console.error(String(e));process.exit(2)})\"",
              "elapsedMs": 255,
              "stdout": "status=200"
            }
          }
        }
      ]
    }
  },
  "finishedAt": "2026-02-16T06:49:43.516Z"
}
</file>

<file path="plan/2026-02-16_ClawX源码调研/evidence/docker-stability-probe-live.mjs">
#!/usr/bin/env node

import { execSync } from "node:child_process";
import fs from "node:fs/promises";
import path from "node:path";
import { setTimeout as sleep } from "node:timers/promises";

const OUTPUT_PATH = path.resolve(
  "plan/2026-02-16_ClawX源码调研/evidence/docker-stability-live.json"
);
const PANEL_BASE = process.env.PANEL_BASE_URL || "http://127.0.0.1:18080";
const GATEWAY_BASE = process.env.GATEWAY_BASE_URL || "http://127.0.0.1:18789";
const MAX_RECOVER_ATTEMPTS = Number.parseInt(process.env.RECOVER_ATTEMPTS || "20", 10);
const RECOVER_INTERVAL_MS = Number.parseInt(process.env.RECOVER_INTERVAL_MS || "1000", 10);

function run(command) {
  const startedAt = Date.now();
  try {
    const stdout = execSync(command, { encoding: "utf8", stdio: ["ignore", "pipe", "pipe"] });
    return {
      ok: true,
      command,
      elapsedMs: Date.now() - startedAt,
      stdout: String(stdout || "").trim()
    };
  } catch (error) {
    return {
      ok: false,
      command,
      elapsedMs: Date.now() - startedAt,
      stdout: String(error?.stdout || "").trim(),
      stderr: String(error?.stderr || "").trim(),
      message: String(error?.message || error)
    };
  }
}

async function requestJson(url, init = {}) {
  const startedAt = Date.now();
  try {
    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), 6000);
    const response = await fetch(url, {
      ...init,
      signal: controller.signal,
      headers: {
        "content-type": "application/json",
        ...(init.headers || {})
      }
    });
    clearTimeout(timeout);
    const text = await response.text();
    let body;
    try {
      body = text ? JSON.parse(text) : null;
    } catch {
      body = text;
    }
    return {
      ok: response.ok,
      status: response.status,
      elapsedMs: Date.now() - startedAt,
      body
    };
  } catch (error) {
    return {
      ok: false,
      status: 0,
      elapsedMs: Date.now() - startedAt,
      error: String(error?.message || error)
    };
  }
}

async function requestText(url, init = {}) {
  const startedAt = Date.now();
  try {
    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), 6000);
    const response = await fetch(url, { ...init, signal: controller.signal });
    clearTimeout(timeout);
    const text = await response.text();
    return {
      ok: response.ok,
      status: response.status,
      elapsedMs: Date.now() - startedAt,
      textPreview: text.slice(0, 120)
    };
  } catch (error) {
    return {
      ok: false,
      status: 0,
      elapsedMs: Date.now() - startedAt,
      error: String(error?.message || error)
    };
  }
}

async function probeAll() {
  const panelHealth = await requestJson(`${PANEL_BASE}/api/health`);
  const serviceStatus = await requestJson(`${PANEL_BASE}/api/service/status`, {
    method: "POST",
    body: "{}"
  });
  const updateCheck = await requestJson(`${PANEL_BASE}/api/update/check`);
  const gatewayHome = await requestText(`${GATEWAY_BASE}/`);
  const containerState = run("docker inspect -f \"{{.State.Status}}\" openclaw-gateway");
  const internalDnsProbe = run(
    "docker exec openclaw-panel node -e \"fetch('http://openclaw-gateway:18789/').then(r=>{console.log('status='+r.status);process.exit(r.ok?0:1)}).catch(e=>{console.error(String(e));process.exit(2)})\""
  );

  return {
    panelHealth,
    serviceStatus,
    updateCheck,
    gatewayHome,
    containerState,
    internalDnsProbe
  };
}

function isRecovered(snapshot) {
  return (
    snapshot?.panelHealth?.ok &&
    snapshot?.serviceStatus?.ok &&
    snapshot?.serviceStatus?.body?.ok === true &&
    snapshot?.serviceStatus?.body?.result?.active === true &&
    snapshot?.gatewayHome?.ok &&
    snapshot?.gatewayHome?.status === 200 &&
    snapshot?.containerState?.ok &&
    String(snapshot?.containerState?.stdout || "") === "running" &&
    snapshot?.internalDnsProbe?.ok
  );
}

async function waitForRecovery() {
  const attempts = [];
  for (let i = 1; i <= MAX_RECOVER_ATTEMPTS; i++) {
    const probe = await probeAll();
    attempts.push({
      attempt: i,
      recovered: isRecovered(probe),
      probe
    });
    if (isRecovered(probe)) {
      return {
        recovered: true,
        attempts
      };
    }
    await sleep(RECOVER_INTERVAL_MS);
  }
  return {
    recovered: false,
    attempts
  };
}

async function main() {
  const result = {
    startedAt: new Date().toISOString()
  };

  result.baseline = await probeAll();

  const restartStartedAt = Date.now();
  result.restart = {
    command: run("docker restart openclaw-gateway"),
    durationMs: Date.now() - restartStartedAt
  };
  result.restart.recovery = await waitForRecovery();

  const networkNameResult = run(
    "docker inspect -f \"{{range $k, $v := .NetworkSettings.Networks}}{{$k}}{{end}}\" openclaw-gateway"
  );
  const networkName = String(networkNameResult.stdout || "").trim();
  result.networkIsolation = {
    networkNameResult,
    networkName
  };
  if (networkName) {
    result.networkIsolation.disconnect = run(`docker network disconnect -f ${networkName} openclaw-gateway`);
    result.networkIsolation.probeDuringIsolation = await probeAll();
    result.networkIsolation.reconnect = run(`docker network connect ${networkName} openclaw-gateway`);
    result.networkIsolation.recovery = await waitForRecovery();
  } else {
    result.networkIsolation.error = "无法识别 gateway 网络名称，跳过隔离测试";
  }

  const checkBeforeUpgrade = await requestJson(`${PANEL_BASE}/api/update/check`);
  const currentTag = String(checkBeforeUpgrade?.body?.result?.currentTag || "").trim();
  result.upgradeDrill = {
    checkBeforeUpgrade,
    currentTag
  };
  if (currentTag) {
    result.upgradeDrill.upgrade = await requestJson(`${PANEL_BASE}/api/update/upgrade`, {
      method: "POST",
      body: JSON.stringify({ tag: currentTag })
    });
    result.upgradeDrill.afterUpgradeProbe = await probeAll();
    result.upgradeDrill.afterUpgradeRecovery = await waitForRecovery();
  } else {
    result.upgradeDrill.error = "未读取到 currentTag，跳过升级回放";
  }

  result.finishedAt = new Date().toISOString();

  await fs.writeFile(OUTPUT_PATH, `${JSON.stringify(result, null, 2)}\n`, "utf8");
  // Keep the script output machine-readable for quick shell checks.
  process.stdout.write(`${JSON.stringify({ ok: true, output: OUTPUT_PATH })}\n`);
}

main().catch(async (error) => {
  const payload = {
    ok: false,
    message: String(error?.message || error),
    stack: String(error?.stack || "")
  };
  process.stdout.write(`${JSON.stringify(payload)}\n`);
  process.exitCode = 1;
});
</file>

<file path="plan/2026-02-16_ClawX源码调研/evidence/gateway-adapter-live.json">
{
  "probe": {
    "ok": true,
    "count": 14,
    "sessionCount": 14
  },
  "target": "openclaw-gateway",
  "runtime": "docker",
  "container": "openclaw-panel",
  "testedAt": "2026-02-16 15:07:15 +08:00"
}
</file>

<file path="plan/2026-02-16_ClawX源码调研/evidence/gateway-rpc-matrix-live.json">
{
  "startedAt": "2026-02-16T05:23:13.796Z",
  "finishedAt": "2026-02-16T05:23:16.205Z",
  "url": "ws://127.0.0.1:18789/ws",
  "sessionKey": "agent:main:panel-probe-1771219393796",
  "methodsSummary": {
    "sessions.list": {
      "total": 3,
      "successCount": 3,
      "failCount": 0,
      "successRate": 1,
      "supportKinds": [
        "supported"
      ],
      "p95LatencyMs": 84,
      "sampleError": null,
      "sampleResult": {
        "count": 3,
        "defaults": {
          "modelProvider": "aicodecat-gpt",
          "model": "gpt-5.2",
          "contextTokens": 400000
        },
        "sessionCount": 3,
        "firstSessionKey": "agent:main:panel-probe-1771219356018"
      }
    },
    "chat.history": {
      "total": 3,
      "successCount": 3,
      "failCount": 0,
      "successRate": 1,
      "supportKinds": [
        "supported"
      ],
      "p95LatencyMs": 63,
      "sampleError": null,
      "sampleResult": {
        "sessionKey": "agent:main:panel-probe-1771219393796",
        "messageCount": 0,
        "thinkingLevel": "off"
      }
    },
    "chat.send": {
      "total": 3,
      "successCount": 3,
      "failCount": 0,
      "successRate": 1,
      "supportKinds": [
        "supported"
      ],
      "p95LatencyMs": 82,
      "sampleError": null,
      "sampleResult": {
        "runId": "93b72da8-abb3-4916-85ab-bb303b0e3e01",
        "status": "started"
      }
    },
    "chat.abort": {
      "total": 3,
      "successCount": 3,
      "failCount": 0,
      "successRate": 1,
      "supportKinds": [
        "supported"
      ],
      "p95LatencyMs": 170,
      "sampleError": null,
      "sampleResult": {
        "ok": true,
        "aborted": true,
        "abortedRunCount": 3
      }
    },
    "skills.status": {
      "total": 3,
      "successCount": 3,
      "failCount": 0,
      "successRate": 1,
      "supportKinds": [
        "supported"
      ],
      "p95LatencyMs": 172,
      "sampleError": null,
      "sampleResult": {
        "workspaceDir": "/home/node/.openclaw/workspace",
        "managedSkillsDir": "/home/node/.openclaw/skills",
        "totalSkills": 49,
        "enabledCount": 49,
        "eligibleCount": 4,
        "firstSkillKeys": [
          "1password",
          "apple-notes",
          "apple-reminders",
          "bear-notes",
          "blogwatcher",
          "blucli",
          "bluebubbles",
          "camsnap"
        ]
      }
    },
    "skills.update": {
      "total": 3,
      "successCount": 3,
      "failCount": 0,
      "successRate": 1,
      "supportKinds": [
        "supported"
      ],
      "p95LatencyMs": 138,
      "sampleError": null,
      "sampleResult": {
        "ok": true,
        "skillKey": "__panel_probe_nonexistent_skill__",
        "config": {
          "enabled": false
        }
      }
    }
  },
  "summary": {
    "supported": [
      "sessions.list",
      "chat.history",
      "chat.send",
      "chat.abort",
      "skills.status",
      "skills.update"
    ],
    "unsupported": [],
    "uncertain": []
  },
  "runs": [
    {
      "method": "sessions.list",
      "ok": true,
      "latencyMs": 165,
      "support": "supported",
      "error": null,
      "result": {
        "count": 3,
        "defaults": {
          "modelProvider": "aicodecat-gpt",
          "model": "gpt-5.2",
          "contextTokens": 400000
        },
        "sessionCount": 3,
        "firstSessionKey": "agent:main:panel-probe-1771219356018"
      }
    },
    {
      "method": "sessions.list",
      "ok": true,
      "latencyMs": 70,
      "support": "supported",
      "error": null,
      "result": {
        "count": 3,
        "defaults": {
          "modelProvider": "aicodecat-gpt",
          "model": "gpt-5.2",
          "contextTokens": 400000
        },
        "sessionCount": 3,
        "firstSessionKey": "agent:main:panel-probe-1771219356018"
      }
    },
    {
      "method": "sessions.list",
      "ok": true,
      "latencyMs": 84,
      "support": "supported",
      "error": null,
      "result": {
        "count": 3,
        "defaults": {
          "modelProvider": "aicodecat-gpt",
          "model": "gpt-5.2",
          "contextTokens": 400000
        },
        "sessionCount": 3,
        "firstSessionKey": "agent:main:panel-probe-1771219356018"
      }
    },
    {
      "method": "chat.history",
      "ok": true,
      "latencyMs": 63,
      "support": "supported",
      "error": null,
      "result": {
        "sessionKey": "agent:main:panel-probe-1771219393796",
        "messageCount": 0,
        "thinkingLevel": "off"
      }
    },
    {
      "method": "chat.history",
      "ok": true,
      "latencyMs": 63,
      "support": "supported",
      "error": null,
      "result": {
        "sessionKey": "agent:main:panel-probe-1771219393796",
        "messageCount": 0,
        "thinkingLevel": "off"
      }
    },
    {
      "method": "chat.history",
      "ok": true,
      "latencyMs": 78,
      "support": "supported",
      "error": null,
      "result": {
        "sessionKey": "agent:main:panel-probe-1771219393796",
        "messageCount": 0,
        "thinkingLevel": "off"
      }
    },
    {
      "method": "chat.send",
      "ok": true,
      "latencyMs": 56,
      "support": "supported",
      "error": null,
      "result": {
        "runId": "93b72da8-abb3-4916-85ab-bb303b0e3e01",
        "status": "started"
      }
    },
    {
      "method": "chat.send",
      "ok": true,
      "latencyMs": 82,
      "support": "supported",
      "error": null,
      "result": {
        "runId": "483edb19-be49-4c69-bce3-99e32b185404",
        "status": "started"
      }
    },
    {
      "method": "chat.send",
      "ok": true,
      "latencyMs": 149,
      "support": "supported",
      "error": null,
      "result": {
        "runId": "4192a21c-45a7-4d76-8840-449c47eade93",
        "status": "started"
      }
    },
    {
      "method": "chat.abort",
      "ok": true,
      "latencyMs": 239,
      "support": "supported",
      "error": null,
      "result": {
        "ok": true,
        "aborted": true,
        "abortedRunCount": 3
      }
    },
    {
      "method": "chat.abort",
      "ok": true,
      "latencyMs": 168,
      "support": "supported",
      "error": null,
      "result": {
        "ok": true,
        "aborted": false,
        "abortedRunCount": 0
      }
    },
    {
      "method": "chat.abort",
      "ok": true,
      "latencyMs": 170,
      "support": "supported",
      "error": null,
      "result": {
        "ok": true,
        "aborted": false,
        "abortedRunCount": 0
      }
    },
    {
      "method": "skills.status",
      "ok": true,
      "latencyMs": 274,
      "support": "supported",
      "error": null,
      "result": {
        "workspaceDir": "/home/node/.openclaw/workspace",
        "managedSkillsDir": "/home/node/.openclaw/skills",
        "totalSkills": 49,
        "enabledCount": 49,
        "eligibleCount": 4,
        "firstSkillKeys": [
          "1password",
          "apple-notes",
          "apple-reminders",
          "bear-notes",
          "blogwatcher",
          "blucli",
          "bluebubbles",
          "camsnap"
        ]
      }
    },
    {
      "method": "skills.status",
      "ok": true,
      "latencyMs": 172,
      "support": "supported",
      "error": null,
      "result": {
        "workspaceDir": "/home/node/.openclaw/workspace",
        "managedSkillsDir": "/home/node/.openclaw/skills",
        "totalSkills": 49,
        "enabledCount": 49,
        "eligibleCount": 4,
        "firstSkillKeys": [
          "1password",
          "apple-notes",
          "apple-reminders",
          "bear-notes",
          "blogwatcher",
          "blucli",
          "bluebubbles",
          "camsnap"
        ]
      }
    },
    {
      "method": "skills.status",
      "ok": true,
      "latencyMs": 162,
      "support": "supported",
      "error": null,
      "result": {
        "workspaceDir": "/home/node/.openclaw/workspace",
        "managedSkillsDir": "/home/node/.openclaw/skills",
        "totalSkills": 49,
        "enabledCount": 49,
        "eligibleCount": 4,
        "firstSkillKeys": [
          "1password",
          "apple-notes",
          "apple-reminders",
          "bear-notes",
          "blogwatcher",
          "blucli",
          "bluebubbles",
          "camsnap"
        ]
      }
    },
    {
      "method": "skills.update",
      "ok": true,
      "latencyMs": 138,
      "support": "supported",
      "error": null,
      "result": {
        "ok": true,
        "skillKey": "__panel_probe_nonexistent_skill__",
        "config": {
          "enabled": false
        }
      }
    },
    {
      "method": "skills.update",
      "ok": true,
      "latencyMs": 132,
      "support": "supported",
      "error": null,
      "result": {
        "ok": true,
        "skillKey": "__panel_probe_nonexistent_skill__",
        "config": {
          "enabled": false
        }
      }
    },
    {
      "method": "skills.update",
      "ok": true,
      "latencyMs": 142,
      "support": "supported",
      "error": null,
      "result": {
        "ok": true,
        "skillKey": "__panel_probe_nonexistent_skill__",
        "config": {
          "enabled": false
        }
      }
    }
  ]
}
</file>

<file path="plan/2026-02-16_ClawX源码调研/evidence/manual-replay-7.2-live.md">
# 7.2 运行态证据：关键路径手工回放

时间：2026-02-16

## 回放范围

- 模型配置：`GET/PUT /api/settings`
- 渠道配置：`PUT /api/settings`（携带 channels 原值写回）
- Skills：`GET /api/skills/status`、`GET /api/skills/:skillKey/config`、`POST /api/skills/:skillKey/enabled`
- 日志与服务：`POST /api/service/status`、`GET /api/logs/tail`、`GET /api/logs/errors`
- 更新：`GET /api/update/check`
- 智能对话：`GET /api/chat/sessions`、`GET /api/chat/history`、`POST /api/chat/send`、`POST /api/chat/abort`

## 回放结果（节选）

```json
{
  "settingsSave": {
    "ok": true,
    "path": "/data/openclaw/openclaw.json"
  },
  "model": {
    "primary": "anthropic/default-model",
    "provider": "anthropic",
    "modelId": "claude-sonnet-4-5-20250929"
  },
  "channels": {
    "telegramEnabled": false,
    "feishuEnabled": false,
    "discordEnabled": false,
    "slackEnabled": false
  },
  "skills": {
    "total": 49,
    "firstSkill": "1password",
    "selectedConfig": "1password",
    "enabledEcho": true
  },
  "logs": {
    "serviceOk": true,
    "serviceActive": true,
    "tailLines": 20,
    "errorLines": 5
  },
  "update": {
    "ok": true,
    "currentTag": "2026.2.14",
    "latestTag": "2026.2.15",
    "warning": ""
  },
  "chat": {
    "sessions": 21,
    "sessionKey": "agent:main:session-1771231535668-5a3c1e4b",
    "historyBeforeMessages": 5,
    "runId": "ceccacd2-53f2-4738-a321-70332baa8493",
    "historyAfterMessages": 5,
    "abortResult": true
  }
}
```

## 结论

- 模型/渠道/Skills/日志/更新/智能对话关键链路全部可达并可执行；
- 配置写回、技能启停、对话发送与中止均未出现接口级异常；
- 当前可以进入 `7.3` Docker 场景稳定性验证。
</file>

<file path="plan/2026-02-16_ClawX源码调研/evidence/model-api-linkage-3.4-live.md">
# 3.4 运行态证据：API 模式下拉与 GPT/Claude/Gemini 联动

时间：2026-02-16

## 1) 页面交互校验（Chrome DevTools MCP）

目标页面：`http://127.0.0.1:18080/model`

### 1.1 自定义模式控件存在性

- `custom_api` 已是下拉框（含 `custom` 选项）
- `custom_default_model_id` 已是下拉框（含 `custom` 选项）

### 1.2 模型切换联动（AICodeCat）

执行脚本返回：

```json
{
  "ok": true,
  "afterClaude": {
    "providerId": "aicodecat-claude",
    "apiMode": "anthropic-messages",
    "baseUrl": "https://aicode.cat"
  },
  "afterGpt": {
    "providerId": "aicodecat-gpt",
    "apiMode": "openai-responses",
    "baseUrl": "https://aicode.cat/v1"
  },
  "afterGemini": {
    "providerId": "aicodecat-gemini",
    "apiMode": "google-generative-ai",
    "baseUrl": "https://aicode.cat/v1beta"
  }
}
```

### 1.3 API 模式切换联动（AICodeCat）

执行脚本返回：

```json
{
  "byClaudeApi": {
    "providerId": "aicodecat-claude",
    "apiMode": "anthropic-messages",
    "baseUrl": "https://aicode.cat"
  },
  "byGeminiApi": {
    "providerId": "aicodecat-gemini",
    "apiMode": "google-generative-ai",
    "baseUrl": "https://aicode.cat/v1beta"
  }
}
```

结论：
- 在 AICodeCat 提供商下，模型族与 API 模式互相驱动，并同步切换默认 URL。
- GPT/Claude/Gemini 三条路径已按预期联动。

## 2) 自动化验证

命令：

```powershell
node --check public/app.js
npm run test:unit
npm run test:regression
```

结果：
- `node --check` 通过
- `test:unit`：48/48 通过
- `test:regression`：3 通过，1 跳过

## 3) Docker 验证

命令：

```powershell
docker compose up -d --build panel
```

结果：
- `openclaw-panel:local` 构建成功
- `openclaw-panel` 重建并启动成功
</file>

<file path="plan/2026-02-16_ClawX源码调研/evidence/model-id-alignment-3.3-live.md">
# 3.3 运行态证据：默认模型列表与配置生成器模型 ID 对齐

时间：2026-02-16

## 1) 运行时页面校验（Chrome DevTools MCP）

目标页面：`http://127.0.0.1:18080/model`

执行脚本结果：

```json
{
  "cfgCount": 9,
  "templateCount": 8,
  "modelDefaultCount": 10,
  "sameAsTemplate": true,
  "firstCfg": [
    "gpt-5.2",
    "gpt-5.2-codex",
    "gpt-5.3-codex",
    "claude-opus-4-6",
    "claude-sonnet-4-5-20250929"
  ],
  "firstTemplate": [
    "gpt-5.2",
    "gpt-5.2-codex",
    "gpt-5.3-codex",
    "claude-opus-4-6",
    "claude-sonnet-4-5-20250929"
  ],
  "hasCustomOption": true
}
```

补充校验：

```json
{
  "presetIdsCount": 8,
  "defaultTextsCount": 10,
  "missingPresetIdsInDefault": []
}
```

结论：
- 配置生成器与模板高级参数的模型 ID 列表已同源一致；
- “设置当前默认模型”下拉包含全部预置模型 ID（并可额外显示当前环境自定义模型）。

## 2) 自动化验证

命令：

```powershell
node --check public/app.js
npm run test:unit
npm run test:regression
```

结果：
- `node --check` 通过
- `test:unit`：48/48 通过
- `test:regression`：3 通过，1 跳过

## 3) Docker 验证

命令：

```powershell
docker compose up -d --build panel
```

结果：
- `openclaw-panel:local` 构建成功
- `openclaw-panel` 重建并启动成功
</file>

<file path="plan/2026-02-16_ClawX源码调研/evidence/model-provider-dual-path-3.1-live.md">
# 3.1 运行态证据：模型与提供商双通道解耦

时间：2026-02-16

## 1) 静态结构校验

命令：

```powershell
Invoke-WebRequest -UseBasicParsing -Uri http://127.0.0.1:18080/model
```

结果：页面包含以下关键节点（全部命中）：

- `template_set_as_primary`
- `custom_set_as_primary`
- `model_provider_template_section`
- `model_default_section`

## 2) 语法与自动化验证

命令：

```powershell
node --check public/app.js
node --check public/config-generator.js
npm run test:unit
npm run test:regression
```

结果：

- `node --check` 全部通过
- `test:unit`：48/48 通过
- `test:regression`：3 通过，1 跳过（历史已存在）

## 3) Docker 运行态验证

命令：

```powershell
docker compose up -d --build panel
```

结果：

- `openclaw-panel:local` 构建成功
- `openclaw-panel` 容器重建并启动成功

## 4) 行为结论

- 路径 1（设置当前默认模型）与路径 2（新增提供商）已实现显式解耦：
  - 默认行为：新增提供商不会改动当前默认模型
  - 显式勾选“保存后设为当前默认模型”时才会切换 `primary`
</file>

<file path="plan/2026-02-16_ClawX源码调研/evidence/model-provider-mode-switch-3.2-live.md">
# 3.2 运行态证据：模型页基础模板/自定义模式切换

时间：2026-02-16

## 1) 页面结构校验

命令：

```powershell
Invoke-WebRequest -UseBasicParsing -Uri http://127.0.0.1:18080/model
```

关键节点命中：

- `model_provider_mode_section`
- `data-model-provider-mode="template"`
- `data-model-provider-mode="custom"`
- `data-model-provider-mode-panel="template"`
- `data-model-provider-mode-panel="custom"`
- `高级参数（通常不用改）`

## 2) 自动化验证

命令：

```powershell
node --check public/app.js
npm run test:unit
npm run test:regression
```

结果：

- `node --check` 通过
- `test:unit`：48/48 通过
- `test:regression`：3 通过，1 跳过

## 3) Docker 验证

命令：

```powershell
docker compose up -d --build panel
```

结果：

- `openclaw-panel:local` 构建成功
- `openclaw-panel` 重建并启动成功

## 4) 行为结论

- 路径 2 默认进入“基础配置（推荐）”，只暴露核心输入项（provider/baseUrl/apiKey）。
- 模板高级参数（API 模式/默认模型/是否切默认）已折叠，降低小白误操作概率。
- “自定义模式”仅在用户主动切换后展示。
</file>

<file path="plan/2026-02-16_ClawX源码调研/evidence/skills-boundary-live.json">
{
  "startedAt": "2026-02-16T05:41:20.454Z",
  "finishedAt": "2026-02-16T05:41:21.050Z",
  "wsUrl": "ws://127.0.0.1:18789/ws",
  "probeId": "skills-boundary-probe-1771220480454",
  "probeSkillKey": "__panel_probe_nonexistent_skill__",
  "clientDistFile": "client-B5KEYk4h.js",
  "hello": {
    "type": "hello-ok",
    "protocol": 3,
    "server": {
      "version": "dev",
      "host": "3fdf9e7221c0",
      "connId": "bc705ef2-85d9-41d2-97c8-2c3e38184ac3"
    },
    "features": {
      "methods": [
        "health",
        "logs.tail",
        "channels.status",
        "channels.logout",
        "status",
        "usage.status",
        "usage.cost",
        "tts.status",
        "tts.providers",
        "tts.enable",
        "tts.disable",
        "tts.convert",
        "tts.setProvider",
        "config.get",
        "config.set",
        "config.apply",
        "config.patch",
        "config.schema",
        "exec.approvals.get",
        "exec.approvals.set",
        "exec.approvals.node.get",
        "exec.approvals.node.set",
        "exec.approval.request",
        "exec.approval.waitDecision",
        "exec.approval.resolve",
        "wizard.start",
        "wizard.next",
        "wizard.cancel",
        "wizard.status",
        "talk.config",
        "talk.mode",
        "models.list",
        "agents.list",
        "agents.create",
        "agents.update",
        "agents.delete",
        "agents.files.list",
        "agents.files.get",
        "agents.files.set",
        "skills.status",
        "skills.bins",
        "skills.install",
        "skills.update",
        "update.run",
        "voicewake.get",
        "voicewake.set",
        "sessions.list",
        "sessions.preview",
        "sessions.patch",
        "sessions.reset",
        "sessions.delete",
        "sessions.compact",
        "last-heartbeat",
        "set-heartbeats",
        "wake",
        "node.pair.request",
        "node.pair.list",
        "node.pair.approve",
        "node.pair.reject",
        "node.pair.verify",
        "device.pair.list",
        "device.pair.approve",
        "device.pair.reject",
        "device.token.rotate",
        "device.token.revoke",
        "node.rename",
        "node.list",
        "node.describe",
        "node.invoke",
        "node.invoke.result",
        "node.event",
        "cron.list",
        "cron.status",
        "cron.add",
        "cron.update",
        "cron.remove",
        "cron.run",
        "cron.runs",
        "system-presence",
        "system-event",
        "send",
        "agent",
        "agent.identity.get",
        "agent.wait",
        "browser.request",
        "chat.history",
        "chat.abort",
        "chat.send"
      ],
      "events": [
        "connect.challenge",
        "agent",
        "chat",
        "presence",
        "tick",
        "talk.mode",
        "shutdown",
        "health",
        "heartbeat",
        "cron",
        "node.pair.requested",
        "node.pair.resolved",
        "node.invoke.request",
        "device.pair.requested",
        "device.pair.resolved",
        "voicewake.changed",
        "exec.approval.requested",
        "exec.approval.resolved"
      ]
    },
    "snapshot": {
      "presence": [
        {
          "host": "3fdf9e7221c0",
          "ip": "172.21.0.2",
          "version": "unknown",
          "platform": "linux 5.15.167.4-microsoft-standard-WSL2",
          "deviceFamily": "Linux",
          "modelIdentifier": "x64",
          "mode": "gateway",
          "reason": "self",
          "text": "Gateway: 3fdf9e7221c0 (172.21.0.2) · app unknown · mode gateway · reason self",
          "ts": 1771220480751
        }
      ],
      "health": {
        "ok": true,
        "ts": 1771220450336,
        "durationMs": 0,
        "channels": {},
        "channelOrder": [],
        "channelLabels": {},
        "heartbeatSeconds": 1800,
        "defaultAgentId": "main",
        "agents": [
          {
            "agentId": "main",
            "isDefault": true,
            "heartbeat": {
              "enabled": true,
              "every": "30m",
              "everyMs": 1800000,
              "prompt": "Read HEARTBEAT.md if it exists (workspace context). Follow it strictly. Do not infer or repeat old tasks from prior chats. If nothing needs attention, reply HEARTBEAT_OK.",
              "target": "last",
              "ackMaxChars": 300
            },
            "sessions": {
              "path": "/home/node/.openclaw/agents/main/sessions/sessions.json",
              "count": 13,
              "recent": [
                {
                  "key": "agent:main:panel-stream-probe-1771220207181",
                  "updatedAt": 1771220215209,
                  "age": 235126
                },
                {
                  "key": "agent:main:panel-stream-probe-1771220153828",
                  "updatedAt": 1771220168681,
                  "age": 281654
                },
                {
                  "key": "agent:main:panel-stream-abort-1771220040840",
                  "updatedAt": 1771220041435,
                  "age": 408900
                },
                {
                  "key": "agent:main:panel-stream-probe-config-error-1771220021125",
                  "updatedAt": 1771220024782,
                  "age": 425553
                },
                {
                  "key": "agent:main:panel-stream-probe-force-error-1771219989545",
                  "updatedAt": 1771219993304,
                  "age": 457031
                }
              ]
            }
          }
        ],
        "sessions": {
          "path": "/home/node/.openclaw/agents/main/sessions/sessions.json",
          "count": 13,
          "recent": [
            {
              "key": "agent:main:panel-stream-probe-1771220207181",
              "updatedAt": 1771220215209,
              "age": 235126
            },
            {
              "key": "agent:main:panel-stream-probe-1771220153828",
              "updatedAt": 1771220168681,
              "age": 281654
            },
            {
              "key": "agent:main:panel-stream-abort-1771220040840",
              "updatedAt": 1771220041435,
              "age": 408900
            },
            {
              "key": "agent:main:panel-stream-probe-config-error-1771220021125",
              "updatedAt": 1771220024782,
              "age": 425553
            },
            {
              "key": "agent:main:panel-stream-probe-force-error-1771219989545",
              "updatedAt": 1771219993304,
              "age": 457031
            }
          ]
        }
      },
      "stateVersion": {
        "presence": 1,
        "health": 834
      },
      "uptimeMs": 45949120,
      "configPath": "/home/node/.openclaw/openclaw.json",
      "stateDir": "/home/node/.openclaw",
      "sessionDefaults": {
        "defaultAgentId": "main",
        "mainKey": "main",
        "mainSessionKey": "agent:main:main",
        "scope": "per-sender"
      },
      "authMode": "token"
    },
    "canvasHostUrl": "http://127.0.0.1:18789",
    "auth": {
      "deviceToken": "uVkW2idRtbd2z2lBYyAF9QuM_Er9W79ib7TwWbqv0mA",
      "role": "operator",
      "scopes": [
        "operator.admin",
        "operator.approvals",
        "operator.pairing"
      ],
      "issuedAtMs": 1771219284921
    },
    "policy": {
      "maxPayload": 8388608,
      "maxBufferedBytes": 16777216,
      "tickIntervalMs": 30000
    }
  },
  "lastClose": null,
  "checks": {
    "statusBefore": {
      "total": 49,
      "firstSkillKeys": [
        "1password",
        "apple-notes",
        "apple-reminders",
        "bear-notes",
        "blogwatcher",
        "blucli",
        "bluebubbles",
        "camsnap",
        "clawhub",
        "coding-agent"
      ],
      "containsProbeSkillKey": false
    },
    "unknownAgentError": {
      "ok": true,
      "error": "unknown agent id \"__unknown_agent__\""
    },
    "updateUnknown": {
      "ok": true,
      "response": {
        "ok": true,
        "skillKey": "__panel_probe_nonexistent_skill__",
        "config": {
          "enabled": false
        }
      }
    },
    "statusAfter": {
      "total": 49,
      "containsProbeSkillKey": false
    },
    "installMissingError": {
      "ok": true,
      "error": "Skill not found: __panel_missing_skill__"
    },
    "binsError": {
      "ok": true,
      "error": "unauthorized role: operator"
    }
  },
  "rpcTrace": [
    {
      "at": "2026-02-16T05:41:20.845Z",
      "method": "skills.status",
      "ok": true,
      "latencyMs": 82,
      "params": {},
      "payload": {
        "workspaceDir": "/home/node/.openclaw/workspace",
        "managedSkillsDir": "/home/node/.openclaw/skills",
        "skills": [
          {
            "name": "1password",
            "description": "Set up and use 1Password CLI (op). Use when installing the CLI, enabling desktop app integration, signing in (single or multi-account), or reading/injecting/running secrets via op.",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/1password/SKILL.md",
            "baseDir": "/app/skills/1password",
            "skillKey": "1password",
            "emoji": "🔐",
            "homepage": "https://developer.1password.com/docs/cli/get-started/",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [
                "op"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "missing": {
              "bins": [
                "op"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "configChecks": [],
            "install": [
              {
                "id": "brew",
                "kind": "brew",
                "label": "Install 1Password CLI (brew)",
                "bins": [
                  "op"
                ]
              }
            ]
          },
          {
            "name": "apple-notes",
            "description": "Manage Apple Notes via the `memo` CLI on macOS (create, view, edit, delete, search, move, and export notes). Use when a user asks OpenClaw to add a note, list notes, search notes, or manage note folders.",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/apple-notes/SKILL.md",
            "baseDir": "/app/skills/apple-notes",
            "skillKey": "apple-notes",
            "emoji": "📝",
            "homepage": "https://github.com/antoniorodr/memo",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [
                "memo"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": [
                "darwin"
              ]
            },
            "missing": {
              "bins": [
                "memo"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": [
                "darwin"
              ]
            },
            "configChecks": [],
            "install": []
          },
          {
            "name": "apple-reminders",
            "description": "Manage Apple Reminders via the `remindctl` CLI on macOS (list, add, edit, complete, delete). Supports lists, date filters, and JSON/plain output.",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/apple-reminders/SKILL.md",
            "baseDir": "/app/skills/apple-reminders",
            "skillKey": "apple-reminders",
            "emoji": "⏰",
            "homepage": "https://github.com/steipete/remindctl",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [
                "remindctl"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": [
                "darwin"
              ]
            },
            "missing": {
              "bins": [
                "remindctl"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": [
                "darwin"
              ]
            },
            "configChecks": [],
            "install": []
          },
          {
            "name": "bear-notes",
            "description": "Create, search, and manage Bear notes via grizzly CLI.",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/bear-notes/SKILL.md",
            "baseDir": "/app/skills/bear-notes",
            "skillKey": "bear-notes",
            "emoji": "🐻",
            "homepage": "https://bear.app",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [
                "grizzly"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": [
                "darwin"
              ]
            },
            "missing": {
              "bins": [
                "grizzly"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": [
                "darwin"
              ]
            },
            "configChecks": [],
            "install": []
          },
          {
            "name": "blogwatcher",
            "description": "Monitor blogs and RSS/Atom feeds for updates using the blogwatcher CLI.",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/blogwatcher/SKILL.md",
            "baseDir": "/app/skills/blogwatcher",
            "skillKey": "blogwatcher",
            "emoji": "📰",
            "homepage": "https://github.com/Hyaxia/blogwatcher",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [
                "blogwatcher"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "missing": {
              "bins": [
                "blogwatcher"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "configChecks": [],
            "install": [
              {
                "id": "go",
                "kind": "go",
                "label": "Install blogwatcher (go)",
                "bins": [
                  "blogwatcher"
                ]
              }
            ]
          },
          {
            "name": "blucli",
            "description": "BluOS CLI (blu) for discovery, playback, grouping, and volume.",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/blucli/SKILL.md",
            "baseDir": "/app/skills/blucli",
            "skillKey": "blucli",
            "emoji": "🫐",
            "homepage": "https://blucli.sh",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [
                "blu"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "missing": {
              "bins": [
                "blu"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "configChecks": [],
            "install": [
              {
                "id": "go",
                "kind": "go",
                "label": "Install blucli (go)",
                "bins": [
                  "blu"
                ]
              }
            ]
          },
          {
            "name": "bluebubbles",
            "description": "Use when you need to send or manage iMessages via BlueBubbles (recommended iMessage integration). Calls go through the generic message tool with channel=\"bluebubbles\".",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/bluebubbles/SKILL.md",
            "baseDir": "/app/skills/bluebubbles",
            "skillKey": "bluebubbles",
            "emoji": "🫧",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [],
              "anyBins": [],
              "env": [],
              "config": [
                "channels.bluebubbles"
              ],
              "os": []
            },
            "missing": {
              "bins": [],
              "anyBins": [],
              "env": [],
              "config": [
                "channels.bluebubbles"
              ],
              "os": []
            },
            "configChecks": [
              {
                "path": "channels.bluebubbles",
                "satisfied": false
              }
            ],
            "install": []
          },
          {
            "name": "camsnap",
            "description": "Capture frames or clips from RTSP/ONVIF cameras.",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/camsnap/SKILL.md",
            "baseDir": "/app/skills/camsnap",
            "skillKey": "camsnap",
            "emoji": "📸",
            "homepage": "https://camsnap.ai",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [
                "camsnap"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "missing": {
              "bins": [
                "camsnap"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "configChecks": [],
            "install": [
              {
                "id": "brew",
                "kind": "brew",
                "label": "Install camsnap (brew)",
                "bins": [
                  "camsnap"
                ]
              }
            ]
          },
          {
            "name": "clawhub",
            "description": "Use the ClawHub CLI to search, install, update, and publish agent skills from clawhub.com. Use when you need to fetch new skills on the fly, sync installed skills to latest or a specific version, or publish new/updated skill folders with the npm-installed clawhub CLI.",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/clawhub/SKILL.md",
            "baseDir": "/app/skills/clawhub",
            "skillKey": "clawhub",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [
                "clawhub"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "missing": {
              "bins": [
                "clawhub"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "configChecks": [],
            "install": [
              {
                "id": "node",
                "kind": "node",
                "label": "Install clawhub (npm)",
                "bins": [
                  "clawhub"
                ]
              }
            ]
          },
          {
            "name": "coding-agent",
            "description": "Run Codex CLI, Claude Code, OpenCode, or Pi Coding Agent via background process for programmatic control.",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/coding-agent/SKILL.md",
            "baseDir": "/app/skills/coding-agent",
            "skillKey": "coding-agent",
            "emoji": "🧩",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [],
              "anyBins": [
                "claude",
                "codex",
                "opencode",
                "pi"
              ],
              "env": [],
              "config": [],
              "os": []
            },
            "missing": {
              "bins": [],
              "anyBins": [
                "claude",
                "codex",
                "opencode",
                "pi"
              ],
              "env": [],
              "config": [],
              "os": []
            },
            "configChecks": [],
            "install": []
          },
          {
            "name": "discord",
            "description": "Discord ops via the message tool (channel=discord).",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/discord/SKILL.md",
            "baseDir": "/app/skills/discord",
            "skillKey": "discord",
            "emoji": "🎮",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [],
              "anyBins": [],
              "env": [],
              "config": [
                "channels.discord.token"
              ],
              "os": []
            },
            "missing": {
              "bins": [],
              "anyBins": [],
              "env": [],
              "config": [
                "channels.discord.token"
              ],
              "os": []
            },
            "configChecks": [
              {
                "path": "channels.discord.token",
                "satisfied": false
              }
            ],
            "install": []
          },
          {
            "name": "eightctl",
            "description": "Control Eight Sleep pods (status, temperature, alarms, schedules).",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/eightctl/SKILL.md",
            "baseDir": "/app/skills/eightctl",
            "skillKey": "eightctl",
            "emoji": "🎛️",
            "homepage": "https://eightctl.sh",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [
                "eightctl"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "missing": {
              "bins": [
                "eightctl"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "configChecks": [],
            "install": [
              {
                "id": "go",
                "kind": "go",
                "label": "Install eightctl (go)",
                "bins": [
                  "eightctl"
                ]
              }
            ]
          },
          {
            "name": "gemini",
            "description": "Gemini CLI for one-shot Q&A, summaries, and generation.",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/gemini/SKILL.md",
            "baseDir": "/app/skills/gemini",
            "skillKey": "gemini",
            "emoji": "♊️",
            "homepage": "https://ai.google.dev/",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [
                "gemini"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "missing": {
              "bins": [
                "gemini"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "configChecks": [],
            "install": [
              {
                "id": "brew",
                "kind": "brew",
                "label": "Install Gemini CLI (brew)",
                "bins": [
                  "gemini"
                ]
              }
            ]
          },
          {
            "name": "gifgrep",
            "description": "Search GIF providers with CLI/TUI, download results, and extract stills/sheets.",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/gifgrep/SKILL.md",
            "baseDir": "/app/skills/gifgrep",
            "skillKey": "gifgrep",
            "emoji": "🧲",
            "homepage": "https://gifgrep.com",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [
                "gifgrep"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "missing": {
              "bins": [
                "gifgrep"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "configChecks": [],
            "install": [
              {
                "id": "brew",
                "kind": "brew",
                "label": "Install gifgrep (brew)",
                "bins": [
                  "gifgrep"
                ]
              }
            ]
          },
          {
            "name": "github",
            "description": "Interact with GitHub using the `gh` CLI. Use `gh issue`, `gh pr`, `gh run`, and `gh api` for issues, PRs, CI runs, and advanced queries.",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/github/SKILL.md",
            "baseDir": "/app/skills/github",
            "skillKey": "github",
            "emoji": "🐙",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [
                "gh"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "missing": {
              "bins": [
                "gh"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "configChecks": [],
            "install": [
              {
                "id": "brew",
                "kind": "brew",
                "label": "Install GitHub CLI (brew)",
                "bins": [
                  "gh"
                ]
              }
            ]
          },
          {
            "name": "gog",
            "description": "Google Workspace CLI for Gmail, Calendar, Drive, Contacts, Sheets, and Docs.",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/gog/SKILL.md",
            "baseDir": "/app/skills/gog",
            "skillKey": "gog",
            "emoji": "🎮",
            "homepage": "https://gogcli.sh",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [
                "gog"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "missing": {
              "bins": [
                "gog"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "configChecks": [],
            "install": [
              {
                "id": "brew",
                "kind": "brew",
                "label": "Install gog (brew)",
                "bins": [
                  "gog"
                ]
              }
            ]
          },
          {
            "name": "goplaces",
            "description": "Query Google Places API (New) via the goplaces CLI for text search, place details, resolve, and reviews. Use for human-friendly place lookup or JSON output for scripts.",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/goplaces/SKILL.md",
            "baseDir": "/app/skills/goplaces",
            "skillKey": "goplaces",
            "primaryEnv": "GOOGLE_PLACES_API_KEY",
            "emoji": "📍",
            "homepage": "https://github.com/steipete/goplaces",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [
                "goplaces"
              ],
              "anyBins": [],
              "env": [
                "GOOGLE_PLACES_API_KEY"
              ],
              "config": [],
              "os": []
            },
            "missing": {
              "bins": [
                "goplaces"
              ],
              "anyBins": [],
              "env": [
                "GOOGLE_PLACES_API_KEY"
              ],
              "config": [],
              "os": []
            },
            "configChecks": [],
            "install": [
              {
                "id": "brew",
                "kind": "brew",
                "label": "Install goplaces (brew)",
                "bins": [
                  "goplaces"
                ]
              }
            ]
          },
          {
            "name": "healthcheck",
            "description": "Host security hardening and risk-tolerance configuration for OpenClaw deployments. Use when a user asks for security audits, firewall/SSH/update hardening, risk posture, exposure review, OpenClaw cron scheduling for periodic checks, or version status checks on a machine running OpenClaw (laptop, workstation, Pi, VPS).",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/healthcheck/SKILL.md",
            "baseDir": "/app/skills/healthcheck",
            "skillKey": "healthcheck",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": true,
            "requirements": {
              "bins": [],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "missing": {
              "bins": [],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "configChecks": [],
            "install": []
          },
          {
            "name": "himalaya",
            "description": "CLI to manage emails via IMAP/SMTP. Use `himalaya` to list, read, write, reply, forward, search, and organize emails from the terminal. Supports multiple accounts and message composition with MML (MIME Meta Language).",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/himalaya/SKILL.md",
            "baseDir": "/app/skills/himalaya",
            "skillKey": "himalaya",
            "emoji": "📧",
            "homepage": "https://github.com/pimalaya/himalaya",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [
                "himalaya"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "missing": {
              "bins": [
                "himalaya"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "configChecks": [],
            "install": [
              {
                "id": "brew",
                "kind": "brew",
                "label": "Install Himalaya (brew)",
                "bins": [
                  "himalaya"
                ]
              }
            ]
          },
          {
            "name": "imsg",
            "description": "iMessage/SMS CLI for listing chats, history, watch, and sending.",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/imsg/SKILL.md",
            "baseDir": "/app/skills/imsg",
            "skillKey": "imsg",
            "emoji": "📨",
            "homepage": "https://imsg.to",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [
                "imsg"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": [
                "darwin"
              ]
            },
            "missing": {
              "bins": [
                "imsg"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": [
                "darwin"
              ]
            },
            "configChecks": [],
            "install": []
          },
          {
            "name": "mcporter",
            "description": "Use the mcporter CLI to list, configure, auth, and call MCP servers/tools directly (HTTP or stdio), including ad-hoc servers, config edits, and CLI/type generation.",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/mcporter/SKILL.md",
            "baseDir": "/app/skills/mcporter",
            "skillKey": "mcporter",
            "emoji": "📦",
            "homepage": "http://mcporter.dev",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [
                "mcporter"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "missing": {
              "bins": [
                "mcporter"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "configChecks": [],
            "install": [
              {
                "id": "node",
                "kind": "node",
                "label": "Install mcporter (npm)",
                "bins": [
                  "mcporter"
                ]
              }
            ]
          },
          {
            "name": "model-usage",
            "description": "Use CodexBar CLI local cost usage to summarize per-model usage for Codex or Claude, including the current (most recent) model or a full model breakdown. Trigger when asked for model-level usage/cost data from codexbar, or when you need a scriptable per-model summary from codexbar cost JSON.",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/model-usage/SKILL.md",
            "baseDir": "/app/skills/model-usage",
            "skillKey": "model-usage",
            "emoji": "📊",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [
                "codexbar"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": [
                "darwin"
              ]
            },
            "missing": {
              "bins": [
                "codexbar"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": [
                "darwin"
              ]
            },
            "configChecks": [],
            "install": []
          },
          {
            "name": "nano-banana-pro",
            "description": "Generate or edit images via Gemini 3 Pro Image (Nano Banana Pro).",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/nano-banana-pro/SKILL.md",
            "baseDir": "/app/skills/nano-banana-pro",
            "skillKey": "nano-banana-pro",
            "primaryEnv": "GEMINI_API_KEY",
            "emoji": "🍌",
            "homepage": "https://ai.google.dev/",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [
                "uv"
              ],
              "anyBins": [],
              "env": [
                "GEMINI_API_KEY"
              ],
              "config": [],
              "os": []
            },
            "missing": {
              "bins": [
                "uv"
              ],
              "anyBins": [],
              "env": [
                "GEMINI_API_KEY"
              ],
              "config": [],
              "os": []
            },
            "configChecks": [],
            "install": [
              {
                "id": "uv-brew",
                "kind": "brew",
                "label": "Install uv (brew)",
                "bins": [
                  "uv"
                ]
              }
            ]
          },
          {
            "name": "nano-pdf",
            "description": "Edit PDFs with natural-language instructions using the nano-pdf CLI.",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/nano-pdf/SKILL.md",
            "baseDir": "/app/skills/nano-pdf",
            "skillKey": "nano-pdf",
            "emoji": "📄",
            "homepage": "https://pypi.org/project/nano-pdf/",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [
                "nano-pdf"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "missing": {
              "bins": [
                "nano-pdf"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "configChecks": [],
            "install": [
              {
                "id": "uv",
                "kind": "uv",
                "label": "Install nano-pdf (uv)",
                "bins": [
                  "nano-pdf"
                ]
              }
            ]
          },
          {
            "name": "notion",
            "description": "Notion API for creating and managing pages, databases, and blocks.",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/notion/SKILL.md",
            "baseDir": "/app/skills/notion",
            "skillKey": "notion",
            "primaryEnv": "NOTION_API_KEY",
            "emoji": "📝",
            "homepage": "https://developers.notion.com",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [],
              "anyBins": [],
              "env": [
                "NOTION_API_KEY"
              ],
              "config": [],
              "os": []
            },
            "missing": {
              "bins": [],
              "anyBins": [],
              "env": [
                "NOTION_API_KEY"
              ],
              "config": [],
              "os": []
            },
            "configChecks": [],
            "install": []
          },
          {
            "name": "obsidian",
            "description": "Work with Obsidian vaults (plain Markdown notes) and automate via obsidian-cli.",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/obsidian/SKILL.md",
            "baseDir": "/app/skills/obsidian",
            "skillKey": "obsidian",
            "emoji": "💎",
            "homepage": "https://help.obsidian.md",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [
                "obsidian-cli"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "missing": {
              "bins": [
                "obsidian-cli"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "configChecks": [],
            "install": [
              {
                "id": "brew",
                "kind": "brew",
                "label": "Install obsidian-cli (brew)",
                "bins": [
                  "obsidian-cli"
                ]
              }
            ]
          },
          {
            "name": "openai-image-gen",
            "description": "Batch-generate images via OpenAI Images API. Random prompt sampler + `index.html` gallery.",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/openai-image-gen/SKILL.md",
            "baseDir": "/app/skills/openai-image-gen",
            "skillKey": "openai-image-gen",
            "primaryEnv": "OPENAI_API_KEY",
            "emoji": "🖼️",
            "homepage": "https://platform.openai.com/docs/api-reference/images",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [
                "python3"
              ],
              "anyBins": [],
              "env": [
                "OPENAI_API_KEY"
              ],
              "config": [],
              "os": []
            },
            "missing": {
              "bins": [],
              "anyBins": [],
              "env": [
                "OPENAI_API_KEY"
              ],
              "config": [],
              "os": []
            },
            "configChecks": [],
            "install": [
              {
                "id": "python-brew",
                "kind": "brew",
                "label": "Install Python (brew)",
                "bins": [
                  "python3"
                ]
              }
            ]
          },
          {
            "name": "openai-whisper",
            "description": "Local speech-to-text with the Whisper CLI (no API key).",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/openai-whisper/SKILL.md",
            "baseDir": "/app/skills/openai-whisper",
            "skillKey": "openai-whisper",
            "emoji": "🎙️",
            "homepage": "https://openai.com/research/whisper",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [
                "whisper"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "missing": {
              "bins": [
                "whisper"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "configChecks": [],
            "install": [
              {
                "id": "brew",
                "kind": "brew",
                "label": "Install OpenAI Whisper (brew)",
                "bins": [
                  "whisper"
                ]
              }
            ]
          },
          {
            "name": "openai-whisper-api",
            "description": "Transcribe audio via OpenAI Audio Transcriptions API (Whisper).",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/openai-whisper-api/SKILL.md",
            "baseDir": "/app/skills/openai-whisper-api",
            "skillKey": "openai-whisper-api",
            "primaryEnv": "OPENAI_API_KEY",
            "emoji": "☁️",
            "homepage": "https://platform.openai.com/docs/guides/speech-to-text",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [
                "curl"
              ],
              "anyBins": [],
              "env": [
                "OPENAI_API_KEY"
              ],
              "config": [],
              "os": []
            },
            "missing": {
              "bins": [],
              "anyBins": [],
              "env": [
                "OPENAI_API_KEY"
              ],
              "config": [],
              "os": []
            },
            "configChecks": [],
            "install": []
          },
          {
            "name": "openhue",
            "description": "Control Philips Hue lights/scenes via the OpenHue CLI.",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/openhue/SKILL.md",
            "baseDir": "/app/skills/openhue",
            "skillKey": "openhue",
            "emoji": "💡",
            "homepage": "https://www.openhue.io/cli",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [
                "openhue"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "missing": {
              "bins": [
                "openhue"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "configChecks": [],
            "install": [
              {
                "id": "brew",
                "kind": "brew",
                "label": "Install OpenHue CLI (brew)",
                "bins": [
                  "openhue"
                ]
              }
            ]
          },
          {
            "name": "oracle",
            "description": "Best practices for using the oracle CLI (prompt + file bundling, engines, sessions, and file attachment patterns).",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/oracle/SKILL.md",
            "baseDir": "/app/skills/oracle",
            "skillKey": "oracle",
            "emoji": "🧿",
            "homepage": "https://askoracle.dev",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [
                "oracle"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "missing": {
              "bins": [
                "oracle"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "configChecks": [],
            "install": [
              {
                "id": "node",
                "kind": "node",
                "label": "Install @steipete/oracle (npm)",
                "bins": [
                  "oracle"
                ]
              }
            ]
          },
          {
            "name": "ordercli",
            "description": "Foodora-only CLI for checking past orders and active order status (Deliveroo WIP).",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/ordercli/SKILL.md",
            "baseDir": "/app/skills/ordercli",
            "skillKey": "ordercli",
            "emoji": "🛵",
            "homepage": "https://ordercli.sh",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [
                "ordercli"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "missing": {
              "bins": [
                "ordercli"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "configChecks": [],
            "install": [
              {
                "id": "brew",
                "kind": "brew",
                "label": "Install ordercli (brew)",
                "bins": [
                  "ordercli"
                ]
              }
            ]
          },
          {
            "name": "peekaboo",
            "description": "Capture and automate macOS UI with the Peekaboo CLI.",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/peekaboo/SKILL.md",
            "baseDir": "/app/skills/peekaboo",
            "skillKey": "peekaboo",
            "emoji": "👀",
            "homepage": "https://peekaboo.boo",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [
                "peekaboo"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": [
                "darwin"
              ]
            },
            "missing": {
              "bins": [
                "peekaboo"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": [
                "darwin"
              ]
            },
            "configChecks": [],
            "install": []
          },
          {
            "name": "sag",
            "description": "ElevenLabs text-to-speech with mac-style say UX.",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/sag/SKILL.md",
            "baseDir": "/app/skills/sag",
            "skillKey": "sag",
            "primaryEnv": "ELEVENLABS_API_KEY",
            "emoji": "🗣️",
            "homepage": "https://sag.sh",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [
                "sag"
              ],
              "anyBins": [],
              "env": [
                "ELEVENLABS_API_KEY"
              ],
              "config": [],
              "os": []
            },
            "missing": {
              "bins": [
                "sag"
              ],
              "anyBins": [],
              "env": [
                "ELEVENLABS_API_KEY"
              ],
              "config": [],
              "os": []
            },
            "configChecks": [],
            "install": [
              {
                "id": "brew",
                "kind": "brew",
                "label": "Install sag (brew)",
                "bins": [
                  "sag"
                ]
              }
            ]
          },
          {
            "name": "session-logs",
            "description": "Search and analyze your own session logs (older/parent conversations) using jq.",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/session-logs/SKILL.md",
            "baseDir": "/app/skills/session-logs",
            "skillKey": "session-logs",
            "emoji": "📜",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [
                "jq",
                "rg"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "missing": {
              "bins": [
                "jq",
                "rg"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "configChecks": [],
            "install": []
          },
          {
            "name": "sherpa-onnx-tts",
            "description": "Local text-to-speech via sherpa-onnx (offline, no cloud)",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/sherpa-onnx-tts/SKILL.md",
            "baseDir": "/app/skills/sherpa-onnx-tts",
            "skillKey": "sherpa-onnx-tts",
            "emoji": "🗣️",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [],
              "anyBins": [],
              "env": [
                "SHERPA_ONNX_RUNTIME_DIR",
                "SHERPA_ONNX_MODEL_DIR"
              ],
              "config": [],
              "os": [
                "darwin",
                "linux",
                "win32"
              ]
            },
            "missing": {
              "bins": [],
              "anyBins": [],
              "env": [
                "SHERPA_ONNX_RUNTIME_DIR",
                "SHERPA_ONNX_MODEL_DIR"
              ],
              "config": [],
              "os": []
            },
            "configChecks": [],
            "install": [
              {
                "id": "download-runtime-linux-x64",
                "kind": "download",
                "label": "Download sherpa-onnx runtime (Linux x64)",
                "bins": []
              },
              {
                "id": "download-model-lessac",
                "kind": "download",
                "label": "Download Piper en_US lessac (high)",
                "bins": []
              }
            ]
          },
          {
            "name": "skill-creator",
            "description": "Create or update AgentSkills. Use when designing, structuring, or packaging skills with scripts, references, and assets.",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/skill-creator/SKILL.md",
            "baseDir": "/app/skills/skill-creator",
            "skillKey": "skill-creator",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": true,
            "requirements": {
              "bins": [],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "missing": {
              "bins": [],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "configChecks": [],
            "install": []
          },
          {
            "name": "slack",
            "description": "Use when you need to control Slack from OpenClaw via the slack tool, including reacting to messages or pinning/unpinning items in Slack channels or DMs.",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/slack/SKILL.md",
            "baseDir": "/app/skills/slack",
            "skillKey": "slack",
            "emoji": "💬",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": true,
            "requirements": {
              "bins": [],
              "anyBins": [],
              "env": [],
              "config": [
                "channels.slack"
              ],
              "os": []
            },
            "missing": {
              "bins": [],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "configChecks": [
              {
                "path": "channels.slack",
                "satisfied": true
              }
            ],
            "install": []
          },
          {
            "name": "songsee",
            "description": "Generate spectrograms and feature-panel visualizations from audio with the songsee CLI.",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/songsee/SKILL.md",
            "baseDir": "/app/skills/songsee",
            "skillKey": "songsee",
            "emoji": "🌊",
            "homepage": "https://github.com/steipete/songsee",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [
                "songsee"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "missing": {
              "bins": [
                "songsee"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "configChecks": [],
            "install": [
              {
                "id": "brew",
                "kind": "brew",
                "label": "Install songsee (brew)",
                "bins": [
                  "songsee"
                ]
              }
            ]
          },
          {
            "name": "sonoscli",
            "description": "Control Sonos speakers (discover/status/play/volume/group).",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/sonoscli/SKILL.md",
            "baseDir": "/app/skills/sonoscli",
            "skillKey": "sonoscli",
            "emoji": "🔊",
            "homepage": "https://sonoscli.sh",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [
                "sonos"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "missing": {
              "bins": [
                "sonos"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "configChecks": [],
            "install": [
              {
                "id": "go",
                "kind": "go",
                "label": "Install sonoscli (go)",
                "bins": [
                  "sonos"
                ]
              }
            ]
          },
          {
            "name": "spotify-player",
            "description": "Terminal Spotify playback/search via spogo (preferred) or spotify_player.",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/spotify-player/SKILL.md",
            "baseDir": "/app/skills/spotify-player",
            "skillKey": "spotify-player",
            "emoji": "🎵",
            "homepage": "https://www.spotify.com",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [],
              "anyBins": [
                "spogo",
                "spotify_player"
              ],
              "env": [],
              "config": [],
              "os": []
            },
            "missing": {
              "bins": [],
              "anyBins": [
                "spogo",
                "spotify_player"
              ],
              "env": [],
              "config": [],
              "os": []
            },
            "configChecks": [],
            "install": [
              {
                "id": "brew",
                "kind": "brew",
                "label": "Install spogo (brew)",
                "bins": [
                  "spogo"
                ]
              }
            ]
          },
          {
            "name": "summarize",
            "description": "Summarize or extract text/transcripts from URLs, podcasts, and local files (great fallback for “transcribe this YouTube/video”).",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/summarize/SKILL.md",
            "baseDir": "/app/skills/summarize",
            "skillKey": "summarize",
            "emoji": "🧾",
            "homepage": "https://summarize.sh",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [
                "summarize"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "missing": {
              "bins": [
                "summarize"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "configChecks": [],
            "install": [
              {
                "id": "brew",
                "kind": "brew",
                "label": "Install summarize (brew)",
                "bins": [
                  "summarize"
                ]
              }
            ]
          },
          {
            "name": "things-mac",
            "description": "Manage Things 3 via the `things` CLI on macOS (add/update projects+todos via URL scheme; read/search/list from the local Things database). Use when a user asks OpenClaw to add a task to Things, list inbox/today/upcoming, search tasks, or inspect projects/areas/tags.",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/things-mac/SKILL.md",
            "baseDir": "/app/skills/things-mac",
            "skillKey": "things-mac",
            "emoji": "✅",
            "homepage": "https://github.com/ossianhempel/things3-cli",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [
                "things"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": [
                "darwin"
              ]
            },
            "missing": {
              "bins": [
                "things"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": [
                "darwin"
              ]
            },
            "configChecks": [],
            "install": []
          },
          {
            "name": "tmux",
            "description": "Remote-control tmux sessions for interactive CLIs by sending keystrokes and scraping pane output.",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/tmux/SKILL.md",
            "baseDir": "/app/skills/tmux",
            "skillKey": "tmux",
            "emoji": "🧵",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [
                "tmux"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": [
                "darwin",
                "linux"
              ]
            },
            "missing": {
              "bins": [
                "tmux"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "configChecks": [],
            "install": []
          },
          {
            "name": "trello",
            "description": "Manage Trello boards, lists, and cards via the Trello REST API.",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/trello/SKILL.md",
            "baseDir": "/app/skills/trello",
            "skillKey": "trello",
            "emoji": "📋",
            "homepage": "https://developer.atlassian.com/cloud/trello/rest/",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [
                "jq"
              ],
              "anyBins": [],
              "env": [
                "TRELLO_API_KEY",
                "TRELLO_TOKEN"
              ],
              "config": [],
              "os": []
            },
            "missing": {
              "bins": [
                "jq"
              ],
              "anyBins": [],
              "env": [
                "TRELLO_API_KEY",
                "TRELLO_TOKEN"
              ],
              "config": [],
              "os": []
            },
            "configChecks": [],
            "install": []
          },
          {
            "name": "video-frames",
            "description": "Extract frames or short clips from videos using ffmpeg.",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/video-frames/SKILL.md",
            "baseDir": "/app/skills/video-frames",
            "skillKey": "video-frames",
            "emoji": "🎞️",
            "homepage": "https://ffmpeg.org",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [
                "ffmpeg"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "missing": {
              "bins": [
                "ffmpeg"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "configChecks": [],
            "install": [
              {
                "id": "brew",
                "kind": "brew",
                "label": "Install ffmpeg (brew)",
                "bins": [
                  "ffmpeg"
                ]
              }
            ]
          },
          {
            "name": "voice-call",
            "description": "Start voice calls via the OpenClaw voice-call plugin.",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/voice-call/SKILL.md",
            "baseDir": "/app/skills/voice-call",
            "skillKey": "voice-call",
            "emoji": "📞",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [],
              "anyBins": [],
              "env": [],
              "config": [
                "plugins.entries.voice-call.enabled"
              ],
              "os": []
            },
            "missing": {
              "bins": [],
              "anyBins": [],
              "env": [],
              "config": [
                "plugins.entries.voice-call.enabled"
              ],
              "os": []
            },
            "configChecks": [
              {
                "path": "plugins.entries.voice-call.enabled",
                "satisfied": false
              }
            ],
            "install": []
          },
          {
            "name": "wacli",
            "description": "Send WhatsApp messages to other people or search/sync WhatsApp history via the wacli CLI (not for normal user chats).",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/wacli/SKILL.md",
            "baseDir": "/app/skills/wacli",
            "skillKey": "wacli",
            "emoji": "📱",
            "homepage": "https://wacli.sh",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [
                "wacli"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "missing": {
              "bins": [
                "wacli"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "configChecks": [],
            "install": [
              {
                "id": "brew",
                "kind": "brew",
                "label": "Install wacli (brew)",
                "bins": [
                  "wacli"
                ]
              }
            ]
          },
          {
            "name": "weather",
            "description": "Get current weather and forecasts (no API key required).",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/weather/SKILL.md",
            "baseDir": "/app/skills/weather",
            "skillKey": "weather",
            "emoji": "🌤️",
            "homepage": "https://wttr.in/:help",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": true,
            "requirements": {
              "bins": [
                "curl"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "missing": {
              "bins": [],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "configChecks": [],
            "install": []
          }
        ]
      }
    },
    {
      "at": "2026-02-16T05:41:20.854Z",
      "method": "skills.status",
      "ok": false,
      "latencyMs": 9,
      "params": {
        "agentId": "__unknown_agent__"
      },
      "error": "unknown agent id \"__unknown_agent__\""
    },
    {
      "at": "2026-02-16T05:41:20.956Z",
      "method": "skills.update",
      "ok": true,
      "latencyMs": 102,
      "params": {
        "skillKey": "__panel_probe_nonexistent_skill__",
        "enabled": false
      },
      "payload": {
        "ok": true,
        "skillKey": "__panel_probe_nonexistent_skill__",
        "config": {
          "enabled": false
        }
      }
    },
    {
      "at": "2026-02-16T05:41:21.009Z",
      "method": "skills.status",
      "ok": true,
      "latencyMs": 53,
      "params": {},
      "payload": {
        "workspaceDir": "/home/node/.openclaw/workspace",
        "managedSkillsDir": "/home/node/.openclaw/skills",
        "skills": [
          {
            "name": "1password",
            "description": "Set up and use 1Password CLI (op). Use when installing the CLI, enabling desktop app integration, signing in (single or multi-account), or reading/injecting/running secrets via op.",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/1password/SKILL.md",
            "baseDir": "/app/skills/1password",
            "skillKey": "1password",
            "emoji": "🔐",
            "homepage": "https://developer.1password.com/docs/cli/get-started/",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [
                "op"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "missing": {
              "bins": [
                "op"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "configChecks": [],
            "install": [
              {
                "id": "brew",
                "kind": "brew",
                "label": "Install 1Password CLI (brew)",
                "bins": [
                  "op"
                ]
              }
            ]
          },
          {
            "name": "apple-notes",
            "description": "Manage Apple Notes via the `memo` CLI on macOS (create, view, edit, delete, search, move, and export notes). Use when a user asks OpenClaw to add a note, list notes, search notes, or manage note folders.",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/apple-notes/SKILL.md",
            "baseDir": "/app/skills/apple-notes",
            "skillKey": "apple-notes",
            "emoji": "📝",
            "homepage": "https://github.com/antoniorodr/memo",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [
                "memo"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": [
                "darwin"
              ]
            },
            "missing": {
              "bins": [
                "memo"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": [
                "darwin"
              ]
            },
            "configChecks": [],
            "install": []
          },
          {
            "name": "apple-reminders",
            "description": "Manage Apple Reminders via the `remindctl` CLI on macOS (list, add, edit, complete, delete). Supports lists, date filters, and JSON/plain output.",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/apple-reminders/SKILL.md",
            "baseDir": "/app/skills/apple-reminders",
            "skillKey": "apple-reminders",
            "emoji": "⏰",
            "homepage": "https://github.com/steipete/remindctl",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [
                "remindctl"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": [
                "darwin"
              ]
            },
            "missing": {
              "bins": [
                "remindctl"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": [
                "darwin"
              ]
            },
            "configChecks": [],
            "install": []
          },
          {
            "name": "bear-notes",
            "description": "Create, search, and manage Bear notes via grizzly CLI.",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/bear-notes/SKILL.md",
            "baseDir": "/app/skills/bear-notes",
            "skillKey": "bear-notes",
            "emoji": "🐻",
            "homepage": "https://bear.app",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [
                "grizzly"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": [
                "darwin"
              ]
            },
            "missing": {
              "bins": [
                "grizzly"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": [
                "darwin"
              ]
            },
            "configChecks": [],
            "install": []
          },
          {
            "name": "blogwatcher",
            "description": "Monitor blogs and RSS/Atom feeds for updates using the blogwatcher CLI.",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/blogwatcher/SKILL.md",
            "baseDir": "/app/skills/blogwatcher",
            "skillKey": "blogwatcher",
            "emoji": "📰",
            "homepage": "https://github.com/Hyaxia/blogwatcher",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [
                "blogwatcher"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "missing": {
              "bins": [
                "blogwatcher"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "configChecks": [],
            "install": [
              {
                "id": "go",
                "kind": "go",
                "label": "Install blogwatcher (go)",
                "bins": [
                  "blogwatcher"
                ]
              }
            ]
          },
          {
            "name": "blucli",
            "description": "BluOS CLI (blu) for discovery, playback, grouping, and volume.",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/blucli/SKILL.md",
            "baseDir": "/app/skills/blucli",
            "skillKey": "blucli",
            "emoji": "🫐",
            "homepage": "https://blucli.sh",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [
                "blu"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "missing": {
              "bins": [
                "blu"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "configChecks": [],
            "install": [
              {
                "id": "go",
                "kind": "go",
                "label": "Install blucli (go)",
                "bins": [
                  "blu"
                ]
              }
            ]
          },
          {
            "name": "bluebubbles",
            "description": "Use when you need to send or manage iMessages via BlueBubbles (recommended iMessage integration). Calls go through the generic message tool with channel=\"bluebubbles\".",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/bluebubbles/SKILL.md",
            "baseDir": "/app/skills/bluebubbles",
            "skillKey": "bluebubbles",
            "emoji": "🫧",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [],
              "anyBins": [],
              "env": [],
              "config": [
                "channels.bluebubbles"
              ],
              "os": []
            },
            "missing": {
              "bins": [],
              "anyBins": [],
              "env": [],
              "config": [
                "channels.bluebubbles"
              ],
              "os": []
            },
            "configChecks": [
              {
                "path": "channels.bluebubbles",
                "satisfied": false
              }
            ],
            "install": []
          },
          {
            "name": "camsnap",
            "description": "Capture frames or clips from RTSP/ONVIF cameras.",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/camsnap/SKILL.md",
            "baseDir": "/app/skills/camsnap",
            "skillKey": "camsnap",
            "emoji": "📸",
            "homepage": "https://camsnap.ai",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [
                "camsnap"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "missing": {
              "bins": [
                "camsnap"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "configChecks": [],
            "install": [
              {
                "id": "brew",
                "kind": "brew",
                "label": "Install camsnap (brew)",
                "bins": [
                  "camsnap"
                ]
              }
            ]
          },
          {
            "name": "clawhub",
            "description": "Use the ClawHub CLI to search, install, update, and publish agent skills from clawhub.com. Use when you need to fetch new skills on the fly, sync installed skills to latest or a specific version, or publish new/updated skill folders with the npm-installed clawhub CLI.",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/clawhub/SKILL.md",
            "baseDir": "/app/skills/clawhub",
            "skillKey": "clawhub",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [
                "clawhub"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "missing": {
              "bins": [
                "clawhub"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "configChecks": [],
            "install": [
              {
                "id": "node",
                "kind": "node",
                "label": "Install clawhub (npm)",
                "bins": [
                  "clawhub"
                ]
              }
            ]
          },
          {
            "name": "coding-agent",
            "description": "Run Codex CLI, Claude Code, OpenCode, or Pi Coding Agent via background process for programmatic control.",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/coding-agent/SKILL.md",
            "baseDir": "/app/skills/coding-agent",
            "skillKey": "coding-agent",
            "emoji": "🧩",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [],
              "anyBins": [
                "claude",
                "codex",
                "opencode",
                "pi"
              ],
              "env": [],
              "config": [],
              "os": []
            },
            "missing": {
              "bins": [],
              "anyBins": [
                "claude",
                "codex",
                "opencode",
                "pi"
              ],
              "env": [],
              "config": [],
              "os": []
            },
            "configChecks": [],
            "install": []
          },
          {
            "name": "discord",
            "description": "Discord ops via the message tool (channel=discord).",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/discord/SKILL.md",
            "baseDir": "/app/skills/discord",
            "skillKey": "discord",
            "emoji": "🎮",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [],
              "anyBins": [],
              "env": [],
              "config": [
                "channels.discord.token"
              ],
              "os": []
            },
            "missing": {
              "bins": [],
              "anyBins": [],
              "env": [],
              "config": [
                "channels.discord.token"
              ],
              "os": []
            },
            "configChecks": [
              {
                "path": "channels.discord.token",
                "satisfied": false
              }
            ],
            "install": []
          },
          {
            "name": "eightctl",
            "description": "Control Eight Sleep pods (status, temperature, alarms, schedules).",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/eightctl/SKILL.md",
            "baseDir": "/app/skills/eightctl",
            "skillKey": "eightctl",
            "emoji": "🎛️",
            "homepage": "https://eightctl.sh",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [
                "eightctl"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "missing": {
              "bins": [
                "eightctl"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "configChecks": [],
            "install": [
              {
                "id": "go",
                "kind": "go",
                "label": "Install eightctl (go)",
                "bins": [
                  "eightctl"
                ]
              }
            ]
          },
          {
            "name": "gemini",
            "description": "Gemini CLI for one-shot Q&A, summaries, and generation.",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/gemini/SKILL.md",
            "baseDir": "/app/skills/gemini",
            "skillKey": "gemini",
            "emoji": "♊️",
            "homepage": "https://ai.google.dev/",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [
                "gemini"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "missing": {
              "bins": [
                "gemini"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "configChecks": [],
            "install": [
              {
                "id": "brew",
                "kind": "brew",
                "label": "Install Gemini CLI (brew)",
                "bins": [
                  "gemini"
                ]
              }
            ]
          },
          {
            "name": "gifgrep",
            "description": "Search GIF providers with CLI/TUI, download results, and extract stills/sheets.",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/gifgrep/SKILL.md",
            "baseDir": "/app/skills/gifgrep",
            "skillKey": "gifgrep",
            "emoji": "🧲",
            "homepage": "https://gifgrep.com",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [
                "gifgrep"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "missing": {
              "bins": [
                "gifgrep"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "configChecks": [],
            "install": [
              {
                "id": "brew",
                "kind": "brew",
                "label": "Install gifgrep (brew)",
                "bins": [
                  "gifgrep"
                ]
              }
            ]
          },
          {
            "name": "github",
            "description": "Interact with GitHub using the `gh` CLI. Use `gh issue`, `gh pr`, `gh run`, and `gh api` for issues, PRs, CI runs, and advanced queries.",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/github/SKILL.md",
            "baseDir": "/app/skills/github",
            "skillKey": "github",
            "emoji": "🐙",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [
                "gh"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "missing": {
              "bins": [
                "gh"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "configChecks": [],
            "install": [
              {
                "id": "brew",
                "kind": "brew",
                "label": "Install GitHub CLI (brew)",
                "bins": [
                  "gh"
                ]
              }
            ]
          },
          {
            "name": "gog",
            "description": "Google Workspace CLI for Gmail, Calendar, Drive, Contacts, Sheets, and Docs.",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/gog/SKILL.md",
            "baseDir": "/app/skills/gog",
            "skillKey": "gog",
            "emoji": "🎮",
            "homepage": "https://gogcli.sh",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [
                "gog"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "missing": {
              "bins": [
                "gog"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "configChecks": [],
            "install": [
              {
                "id": "brew",
                "kind": "brew",
                "label": "Install gog (brew)",
                "bins": [
                  "gog"
                ]
              }
            ]
          },
          {
            "name": "goplaces",
            "description": "Query Google Places API (New) via the goplaces CLI for text search, place details, resolve, and reviews. Use for human-friendly place lookup or JSON output for scripts.",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/goplaces/SKILL.md",
            "baseDir": "/app/skills/goplaces",
            "skillKey": "goplaces",
            "primaryEnv": "GOOGLE_PLACES_API_KEY",
            "emoji": "📍",
            "homepage": "https://github.com/steipete/goplaces",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [
                "goplaces"
              ],
              "anyBins": [],
              "env": [
                "GOOGLE_PLACES_API_KEY"
              ],
              "config": [],
              "os": []
            },
            "missing": {
              "bins": [
                "goplaces"
              ],
              "anyBins": [],
              "env": [
                "GOOGLE_PLACES_API_KEY"
              ],
              "config": [],
              "os": []
            },
            "configChecks": [],
            "install": [
              {
                "id": "brew",
                "kind": "brew",
                "label": "Install goplaces (brew)",
                "bins": [
                  "goplaces"
                ]
              }
            ]
          },
          {
            "name": "healthcheck",
            "description": "Host security hardening and risk-tolerance configuration for OpenClaw deployments. Use when a user asks for security audits, firewall/SSH/update hardening, risk posture, exposure review, OpenClaw cron scheduling for periodic checks, or version status checks on a machine running OpenClaw (laptop, workstation, Pi, VPS).",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/healthcheck/SKILL.md",
            "baseDir": "/app/skills/healthcheck",
            "skillKey": "healthcheck",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": true,
            "requirements": {
              "bins": [],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "missing": {
              "bins": [],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "configChecks": [],
            "install": []
          },
          {
            "name": "himalaya",
            "description": "CLI to manage emails via IMAP/SMTP. Use `himalaya` to list, read, write, reply, forward, search, and organize emails from the terminal. Supports multiple accounts and message composition with MML (MIME Meta Language).",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/himalaya/SKILL.md",
            "baseDir": "/app/skills/himalaya",
            "skillKey": "himalaya",
            "emoji": "📧",
            "homepage": "https://github.com/pimalaya/himalaya",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [
                "himalaya"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "missing": {
              "bins": [
                "himalaya"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "configChecks": [],
            "install": [
              {
                "id": "brew",
                "kind": "brew",
                "label": "Install Himalaya (brew)",
                "bins": [
                  "himalaya"
                ]
              }
            ]
          },
          {
            "name": "imsg",
            "description": "iMessage/SMS CLI for listing chats, history, watch, and sending.",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/imsg/SKILL.md",
            "baseDir": "/app/skills/imsg",
            "skillKey": "imsg",
            "emoji": "📨",
            "homepage": "https://imsg.to",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [
                "imsg"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": [
                "darwin"
              ]
            },
            "missing": {
              "bins": [
                "imsg"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": [
                "darwin"
              ]
            },
            "configChecks": [],
            "install": []
          },
          {
            "name": "mcporter",
            "description": "Use the mcporter CLI to list, configure, auth, and call MCP servers/tools directly (HTTP or stdio), including ad-hoc servers, config edits, and CLI/type generation.",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/mcporter/SKILL.md",
            "baseDir": "/app/skills/mcporter",
            "skillKey": "mcporter",
            "emoji": "📦",
            "homepage": "http://mcporter.dev",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [
                "mcporter"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "missing": {
              "bins": [
                "mcporter"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "configChecks": [],
            "install": [
              {
                "id": "node",
                "kind": "node",
                "label": "Install mcporter (npm)",
                "bins": [
                  "mcporter"
                ]
              }
            ]
          },
          {
            "name": "model-usage",
            "description": "Use CodexBar CLI local cost usage to summarize per-model usage for Codex or Claude, including the current (most recent) model or a full model breakdown. Trigger when asked for model-level usage/cost data from codexbar, or when you need a scriptable per-model summary from codexbar cost JSON.",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/model-usage/SKILL.md",
            "baseDir": "/app/skills/model-usage",
            "skillKey": "model-usage",
            "emoji": "📊",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [
                "codexbar"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": [
                "darwin"
              ]
            },
            "missing": {
              "bins": [
                "codexbar"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": [
                "darwin"
              ]
            },
            "configChecks": [],
            "install": []
          },
          {
            "name": "nano-banana-pro",
            "description": "Generate or edit images via Gemini 3 Pro Image (Nano Banana Pro).",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/nano-banana-pro/SKILL.md",
            "baseDir": "/app/skills/nano-banana-pro",
            "skillKey": "nano-banana-pro",
            "primaryEnv": "GEMINI_API_KEY",
            "emoji": "🍌",
            "homepage": "https://ai.google.dev/",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [
                "uv"
              ],
              "anyBins": [],
              "env": [
                "GEMINI_API_KEY"
              ],
              "config": [],
              "os": []
            },
            "missing": {
              "bins": [
                "uv"
              ],
              "anyBins": [],
              "env": [
                "GEMINI_API_KEY"
              ],
              "config": [],
              "os": []
            },
            "configChecks": [],
            "install": [
              {
                "id": "uv-brew",
                "kind": "brew",
                "label": "Install uv (brew)",
                "bins": [
                  "uv"
                ]
              }
            ]
          },
          {
            "name": "nano-pdf",
            "description": "Edit PDFs with natural-language instructions using the nano-pdf CLI.",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/nano-pdf/SKILL.md",
            "baseDir": "/app/skills/nano-pdf",
            "skillKey": "nano-pdf",
            "emoji": "📄",
            "homepage": "https://pypi.org/project/nano-pdf/",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [
                "nano-pdf"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "missing": {
              "bins": [
                "nano-pdf"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "configChecks": [],
            "install": [
              {
                "id": "uv",
                "kind": "uv",
                "label": "Install nano-pdf (uv)",
                "bins": [
                  "nano-pdf"
                ]
              }
            ]
          },
          {
            "name": "notion",
            "description": "Notion API for creating and managing pages, databases, and blocks.",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/notion/SKILL.md",
            "baseDir": "/app/skills/notion",
            "skillKey": "notion",
            "primaryEnv": "NOTION_API_KEY",
            "emoji": "📝",
            "homepage": "https://developers.notion.com",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [],
              "anyBins": [],
              "env": [
                "NOTION_API_KEY"
              ],
              "config": [],
              "os": []
            },
            "missing": {
              "bins": [],
              "anyBins": [],
              "env": [
                "NOTION_API_KEY"
              ],
              "config": [],
              "os": []
            },
            "configChecks": [],
            "install": []
          },
          {
            "name": "obsidian",
            "description": "Work with Obsidian vaults (plain Markdown notes) and automate via obsidian-cli.",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/obsidian/SKILL.md",
            "baseDir": "/app/skills/obsidian",
            "skillKey": "obsidian",
            "emoji": "💎",
            "homepage": "https://help.obsidian.md",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [
                "obsidian-cli"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "missing": {
              "bins": [
                "obsidian-cli"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "configChecks": [],
            "install": [
              {
                "id": "brew",
                "kind": "brew",
                "label": "Install obsidian-cli (brew)",
                "bins": [
                  "obsidian-cli"
                ]
              }
            ]
          },
          {
            "name": "openai-image-gen",
            "description": "Batch-generate images via OpenAI Images API. Random prompt sampler + `index.html` gallery.",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/openai-image-gen/SKILL.md",
            "baseDir": "/app/skills/openai-image-gen",
            "skillKey": "openai-image-gen",
            "primaryEnv": "OPENAI_API_KEY",
            "emoji": "🖼️",
            "homepage": "https://platform.openai.com/docs/api-reference/images",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [
                "python3"
              ],
              "anyBins": [],
              "env": [
                "OPENAI_API_KEY"
              ],
              "config": [],
              "os": []
            },
            "missing": {
              "bins": [],
              "anyBins": [],
              "env": [
                "OPENAI_API_KEY"
              ],
              "config": [],
              "os": []
            },
            "configChecks": [],
            "install": [
              {
                "id": "python-brew",
                "kind": "brew",
                "label": "Install Python (brew)",
                "bins": [
                  "python3"
                ]
              }
            ]
          },
          {
            "name": "openai-whisper",
            "description": "Local speech-to-text with the Whisper CLI (no API key).",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/openai-whisper/SKILL.md",
            "baseDir": "/app/skills/openai-whisper",
            "skillKey": "openai-whisper",
            "emoji": "🎙️",
            "homepage": "https://openai.com/research/whisper",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [
                "whisper"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "missing": {
              "bins": [
                "whisper"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "configChecks": [],
            "install": [
              {
                "id": "brew",
                "kind": "brew",
                "label": "Install OpenAI Whisper (brew)",
                "bins": [
                  "whisper"
                ]
              }
            ]
          },
          {
            "name": "openai-whisper-api",
            "description": "Transcribe audio via OpenAI Audio Transcriptions API (Whisper).",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/openai-whisper-api/SKILL.md",
            "baseDir": "/app/skills/openai-whisper-api",
            "skillKey": "openai-whisper-api",
            "primaryEnv": "OPENAI_API_KEY",
            "emoji": "☁️",
            "homepage": "https://platform.openai.com/docs/guides/speech-to-text",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [
                "curl"
              ],
              "anyBins": [],
              "env": [
                "OPENAI_API_KEY"
              ],
              "config": [],
              "os": []
            },
            "missing": {
              "bins": [],
              "anyBins": [],
              "env": [
                "OPENAI_API_KEY"
              ],
              "config": [],
              "os": []
            },
            "configChecks": [],
            "install": []
          },
          {
            "name": "openhue",
            "description": "Control Philips Hue lights/scenes via the OpenHue CLI.",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/openhue/SKILL.md",
            "baseDir": "/app/skills/openhue",
            "skillKey": "openhue",
            "emoji": "💡",
            "homepage": "https://www.openhue.io/cli",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [
                "openhue"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "missing": {
              "bins": [
                "openhue"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "configChecks": [],
            "install": [
              {
                "id": "brew",
                "kind": "brew",
                "label": "Install OpenHue CLI (brew)",
                "bins": [
                  "openhue"
                ]
              }
            ]
          },
          {
            "name": "oracle",
            "description": "Best practices for using the oracle CLI (prompt + file bundling, engines, sessions, and file attachment patterns).",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/oracle/SKILL.md",
            "baseDir": "/app/skills/oracle",
            "skillKey": "oracle",
            "emoji": "🧿",
            "homepage": "https://askoracle.dev",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [
                "oracle"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "missing": {
              "bins": [
                "oracle"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "configChecks": [],
            "install": [
              {
                "id": "node",
                "kind": "node",
                "label": "Install @steipete/oracle (npm)",
                "bins": [
                  "oracle"
                ]
              }
            ]
          },
          {
            "name": "ordercli",
            "description": "Foodora-only CLI for checking past orders and active order status (Deliveroo WIP).",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/ordercli/SKILL.md",
            "baseDir": "/app/skills/ordercli",
            "skillKey": "ordercli",
            "emoji": "🛵",
            "homepage": "https://ordercli.sh",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [
                "ordercli"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "missing": {
              "bins": [
                "ordercli"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "configChecks": [],
            "install": [
              {
                "id": "brew",
                "kind": "brew",
                "label": "Install ordercli (brew)",
                "bins": [
                  "ordercli"
                ]
              }
            ]
          },
          {
            "name": "peekaboo",
            "description": "Capture and automate macOS UI with the Peekaboo CLI.",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/peekaboo/SKILL.md",
            "baseDir": "/app/skills/peekaboo",
            "skillKey": "peekaboo",
            "emoji": "👀",
            "homepage": "https://peekaboo.boo",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [
                "peekaboo"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": [
                "darwin"
              ]
            },
            "missing": {
              "bins": [
                "peekaboo"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": [
                "darwin"
              ]
            },
            "configChecks": [],
            "install": []
          },
          {
            "name": "sag",
            "description": "ElevenLabs text-to-speech with mac-style say UX.",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/sag/SKILL.md",
            "baseDir": "/app/skills/sag",
            "skillKey": "sag",
            "primaryEnv": "ELEVENLABS_API_KEY",
            "emoji": "🗣️",
            "homepage": "https://sag.sh",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [
                "sag"
              ],
              "anyBins": [],
              "env": [
                "ELEVENLABS_API_KEY"
              ],
              "config": [],
              "os": []
            },
            "missing": {
              "bins": [
                "sag"
              ],
              "anyBins": [],
              "env": [
                "ELEVENLABS_API_KEY"
              ],
              "config": [],
              "os": []
            },
            "configChecks": [],
            "install": [
              {
                "id": "brew",
                "kind": "brew",
                "label": "Install sag (brew)",
                "bins": [
                  "sag"
                ]
              }
            ]
          },
          {
            "name": "session-logs",
            "description": "Search and analyze your own session logs (older/parent conversations) using jq.",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/session-logs/SKILL.md",
            "baseDir": "/app/skills/session-logs",
            "skillKey": "session-logs",
            "emoji": "📜",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [
                "jq",
                "rg"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "missing": {
              "bins": [
                "jq",
                "rg"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "configChecks": [],
            "install": []
          },
          {
            "name": "sherpa-onnx-tts",
            "description": "Local text-to-speech via sherpa-onnx (offline, no cloud)",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/sherpa-onnx-tts/SKILL.md",
            "baseDir": "/app/skills/sherpa-onnx-tts",
            "skillKey": "sherpa-onnx-tts",
            "emoji": "🗣️",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [],
              "anyBins": [],
              "env": [
                "SHERPA_ONNX_RUNTIME_DIR",
                "SHERPA_ONNX_MODEL_DIR"
              ],
              "config": [],
              "os": [
                "darwin",
                "linux",
                "win32"
              ]
            },
            "missing": {
              "bins": [],
              "anyBins": [],
              "env": [
                "SHERPA_ONNX_RUNTIME_DIR",
                "SHERPA_ONNX_MODEL_DIR"
              ],
              "config": [],
              "os": []
            },
            "configChecks": [],
            "install": [
              {
                "id": "download-runtime-linux-x64",
                "kind": "download",
                "label": "Download sherpa-onnx runtime (Linux x64)",
                "bins": []
              },
              {
                "id": "download-model-lessac",
                "kind": "download",
                "label": "Download Piper en_US lessac (high)",
                "bins": []
              }
            ]
          },
          {
            "name": "skill-creator",
            "description": "Create or update AgentSkills. Use when designing, structuring, or packaging skills with scripts, references, and assets.",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/skill-creator/SKILL.md",
            "baseDir": "/app/skills/skill-creator",
            "skillKey": "skill-creator",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": true,
            "requirements": {
              "bins": [],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "missing": {
              "bins": [],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "configChecks": [],
            "install": []
          },
          {
            "name": "slack",
            "description": "Use when you need to control Slack from OpenClaw via the slack tool, including reacting to messages or pinning/unpinning items in Slack channels or DMs.",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/slack/SKILL.md",
            "baseDir": "/app/skills/slack",
            "skillKey": "slack",
            "emoji": "💬",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": true,
            "requirements": {
              "bins": [],
              "anyBins": [],
              "env": [],
              "config": [
                "channels.slack"
              ],
              "os": []
            },
            "missing": {
              "bins": [],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "configChecks": [
              {
                "path": "channels.slack",
                "satisfied": true
              }
            ],
            "install": []
          },
          {
            "name": "songsee",
            "description": "Generate spectrograms and feature-panel visualizations from audio with the songsee CLI.",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/songsee/SKILL.md",
            "baseDir": "/app/skills/songsee",
            "skillKey": "songsee",
            "emoji": "🌊",
            "homepage": "https://github.com/steipete/songsee",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [
                "songsee"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "missing": {
              "bins": [
                "songsee"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "configChecks": [],
            "install": [
              {
                "id": "brew",
                "kind": "brew",
                "label": "Install songsee (brew)",
                "bins": [
                  "songsee"
                ]
              }
            ]
          },
          {
            "name": "sonoscli",
            "description": "Control Sonos speakers (discover/status/play/volume/group).",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/sonoscli/SKILL.md",
            "baseDir": "/app/skills/sonoscli",
            "skillKey": "sonoscli",
            "emoji": "🔊",
            "homepage": "https://sonoscli.sh",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [
                "sonos"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "missing": {
              "bins": [
                "sonos"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "configChecks": [],
            "install": [
              {
                "id": "go",
                "kind": "go",
                "label": "Install sonoscli (go)",
                "bins": [
                  "sonos"
                ]
              }
            ]
          },
          {
            "name": "spotify-player",
            "description": "Terminal Spotify playback/search via spogo (preferred) or spotify_player.",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/spotify-player/SKILL.md",
            "baseDir": "/app/skills/spotify-player",
            "skillKey": "spotify-player",
            "emoji": "🎵",
            "homepage": "https://www.spotify.com",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [],
              "anyBins": [
                "spogo",
                "spotify_player"
              ],
              "env": [],
              "config": [],
              "os": []
            },
            "missing": {
              "bins": [],
              "anyBins": [
                "spogo",
                "spotify_player"
              ],
              "env": [],
              "config": [],
              "os": []
            },
            "configChecks": [],
            "install": [
              {
                "id": "brew",
                "kind": "brew",
                "label": "Install spogo (brew)",
                "bins": [
                  "spogo"
                ]
              }
            ]
          },
          {
            "name": "summarize",
            "description": "Summarize or extract text/transcripts from URLs, podcasts, and local files (great fallback for “transcribe this YouTube/video”).",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/summarize/SKILL.md",
            "baseDir": "/app/skills/summarize",
            "skillKey": "summarize",
            "emoji": "🧾",
            "homepage": "https://summarize.sh",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [
                "summarize"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "missing": {
              "bins": [
                "summarize"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "configChecks": [],
            "install": [
              {
                "id": "brew",
                "kind": "brew",
                "label": "Install summarize (brew)",
                "bins": [
                  "summarize"
                ]
              }
            ]
          },
          {
            "name": "things-mac",
            "description": "Manage Things 3 via the `things` CLI on macOS (add/update projects+todos via URL scheme; read/search/list from the local Things database). Use when a user asks OpenClaw to add a task to Things, list inbox/today/upcoming, search tasks, or inspect projects/areas/tags.",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/things-mac/SKILL.md",
            "baseDir": "/app/skills/things-mac",
            "skillKey": "things-mac",
            "emoji": "✅",
            "homepage": "https://github.com/ossianhempel/things3-cli",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [
                "things"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": [
                "darwin"
              ]
            },
            "missing": {
              "bins": [
                "things"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": [
                "darwin"
              ]
            },
            "configChecks": [],
            "install": []
          },
          {
            "name": "tmux",
            "description": "Remote-control tmux sessions for interactive CLIs by sending keystrokes and scraping pane output.",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/tmux/SKILL.md",
            "baseDir": "/app/skills/tmux",
            "skillKey": "tmux",
            "emoji": "🧵",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [
                "tmux"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": [
                "darwin",
                "linux"
              ]
            },
            "missing": {
              "bins": [
                "tmux"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "configChecks": [],
            "install": []
          },
          {
            "name": "trello",
            "description": "Manage Trello boards, lists, and cards via the Trello REST API.",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/trello/SKILL.md",
            "baseDir": "/app/skills/trello",
            "skillKey": "trello",
            "emoji": "📋",
            "homepage": "https://developer.atlassian.com/cloud/trello/rest/",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [
                "jq"
              ],
              "anyBins": [],
              "env": [
                "TRELLO_API_KEY",
                "TRELLO_TOKEN"
              ],
              "config": [],
              "os": []
            },
            "missing": {
              "bins": [
                "jq"
              ],
              "anyBins": [],
              "env": [
                "TRELLO_API_KEY",
                "TRELLO_TOKEN"
              ],
              "config": [],
              "os": []
            },
            "configChecks": [],
            "install": []
          },
          {
            "name": "video-frames",
            "description": "Extract frames or short clips from videos using ffmpeg.",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/video-frames/SKILL.md",
            "baseDir": "/app/skills/video-frames",
            "skillKey": "video-frames",
            "emoji": "🎞️",
            "homepage": "https://ffmpeg.org",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [
                "ffmpeg"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "missing": {
              "bins": [
                "ffmpeg"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "configChecks": [],
            "install": [
              {
                "id": "brew",
                "kind": "brew",
                "label": "Install ffmpeg (brew)",
                "bins": [
                  "ffmpeg"
                ]
              }
            ]
          },
          {
            "name": "voice-call",
            "description": "Start voice calls via the OpenClaw voice-call plugin.",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/voice-call/SKILL.md",
            "baseDir": "/app/skills/voice-call",
            "skillKey": "voice-call",
            "emoji": "📞",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [],
              "anyBins": [],
              "env": [],
              "config": [
                "plugins.entries.voice-call.enabled"
              ],
              "os": []
            },
            "missing": {
              "bins": [],
              "anyBins": [],
              "env": [],
              "config": [
                "plugins.entries.voice-call.enabled"
              ],
              "os": []
            },
            "configChecks": [
              {
                "path": "plugins.entries.voice-call.enabled",
                "satisfied": false
              }
            ],
            "install": []
          },
          {
            "name": "wacli",
            "description": "Send WhatsApp messages to other people or search/sync WhatsApp history via the wacli CLI (not for normal user chats).",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/wacli/SKILL.md",
            "baseDir": "/app/skills/wacli",
            "skillKey": "wacli",
            "emoji": "📱",
            "homepage": "https://wacli.sh",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": false,
            "requirements": {
              "bins": [
                "wacli"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "missing": {
              "bins": [
                "wacli"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "configChecks": [],
            "install": [
              {
                "id": "brew",
                "kind": "brew",
                "label": "Install wacli (brew)",
                "bins": [
                  "wacli"
                ]
              }
            ]
          },
          {
            "name": "weather",
            "description": "Get current weather and forecasts (no API key required).",
            "source": "openclaw-bundled",
            "bundled": true,
            "filePath": "/app/skills/weather/SKILL.md",
            "baseDir": "/app/skills/weather",
            "skillKey": "weather",
            "emoji": "🌤️",
            "homepage": "https://wttr.in/:help",
            "always": false,
            "disabled": false,
            "blockedByAllowlist": false,
            "eligible": true,
            "requirements": {
              "bins": [
                "curl"
              ],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "missing": {
              "bins": [],
              "anyBins": [],
              "env": [],
              "config": [],
              "os": []
            },
            "configChecks": [],
            "install": []
          }
        ]
      }
    },
    {
      "at": "2026-02-16T05:41:21.045Z",
      "method": "skills.install",
      "ok": false,
      "latencyMs": 36,
      "params": {
        "name": "__panel_missing_skill__",
        "installId": "missing"
      },
      "error": "Skill not found: __panel_missing_skill__"
    },
    {
      "at": "2026-02-16T05:41:21.050Z",
      "method": "skills.bins",
      "ok": false,
      "latencyMs": 5,
      "params": {},
      "error": "unauthorized role: operator"
    }
  ],
  "stats": {
    "rpcTotal": 6,
    "rpcFailed": 3
  },
  "observations": [
    "skills.status 返回的是可识别技能列表；probe skillKey 不在列表中。",
    "skills.update 对 probe skillKey 返回成功（即使该 key 不在 skills.status）。",
    "skills.install 缺失技能名会失败并返回错误。",
    "skills.bins 对 operator 角色默认拒绝（unauthorized role）。"
  ]
}
</file>

<file path="plan/2026-02-16_ClawX源码调研/evidence/skills-boundary-probe-live.mjs">
import fs from "node:fs/promises";
import path from "node:path";
import { pathToFileURL } from "node:url";

const DIST_DIR = "/app/dist";
const WS_URL = process.env.OPENCLAW_GATEWAY_WS_URL || "ws://127.0.0.1:18789/ws";
const CONNECT_TIMEOUT_MS = 12_000;
const PROBE_SKILL_KEY = "__panel_probe_nonexistent_skill__";

function nowIso() {
  return new Date().toISOString();
}

function asErrorMessage(error) {
  if (error instanceof Error) {
    return error.message;
  }
  return String(error);
}

async function loadGatewayClientClass() {
  const files = await fs.readdir(DIST_DIR);
  const candidates = files
    .filter((name) => name.startsWith("client-") && name.endsWith(".js"))
    .sort();

  for (const fileName of candidates) {
    const modulePath = pathToFileURL(path.join(DIST_DIR, fileName)).href;
    const mod = await import(modulePath);
    const GatewayClient = Object.values(mod).find(
      (value) => typeof value === "function" && value.name === "GatewayClient",
    );
    if (GatewayClient) {
      return { GatewayClient, fileName };
    }
  }

  throw new Error("GatewayClient not found in /app/dist/client-*.js");
}

async function main() {
  const startedAt = nowIso();
  const probeId = `skills-boundary-probe-${Date.now()}`;
  const runtime = await loadGatewayClientClass();
  const GatewayClient = runtime.GatewayClient;

  let readyResolve;
  let readyReject;
  const readyPromise = new Promise((resolve, reject) => {
    readyResolve = resolve;
    readyReject = reject;
  });

  const events = [];
  const rpcTrace = [];
  let lastClose = null;

  const client = new GatewayClient({
    url: WS_URL,
    clientName: "cli",
    mode: "cli",
    instanceId: `${probeId}-client`,
    clientDisplayName: "skills-boundary-probe",
    clientVersion: "probe",
    onEvent: (evt) => {
      if (!evt || typeof evt !== "object") {
        return;
      }
      events.push({
        at: nowIso(),
        event: evt.event,
      });
    },
    onHelloOk: (hello) => {
      readyResolve(hello);
    },
    onConnectError: (error) => {
      readyReject(error instanceof Error ? error : new Error(String(error)));
    },
    onClose: (code, reason) => {
      lastClose = { code, reason };
    },
  });

  const request = async (method, params) => {
    const startedMs = Date.now();
    try {
      const payload = await client.request(method, params);
      rpcTrace.push({
        at: nowIso(),
        method,
        ok: true,
        latencyMs: Date.now() - startedMs,
        params,
        payload,
      });
      return payload;
    } catch (error) {
      const message = asErrorMessage(error);
      rpcTrace.push({
        at: nowIso(),
        method,
        ok: false,
        latencyMs: Date.now() - startedMs,
        params,
        error: message,
      });
      throw new Error(message);
    }
  };

  const checks = {
    statusBefore: null,
    unknownAgentError: null,
    updateUnknown: null,
    statusAfter: null,
    installMissingError: null,
    binsError: null,
  };

  try {
    client.start();

    const connectTimer = setTimeout(() => {
      readyReject(new Error(`connect timeout after ${CONNECT_TIMEOUT_MS}ms`));
    }, CONNECT_TIMEOUT_MS);
    const hello = await readyPromise;
    clearTimeout(connectTimer);

    const statusBefore = await request("skills.status", {});
    const skillsBefore = Array.isArray(statusBefore.skills) ? statusBefore.skills : [];
    checks.statusBefore = {
      total: skillsBefore.length,
      firstSkillKeys: skillsBefore.slice(0, 10).map((item) => item.skillKey),
      containsProbeSkillKey: skillsBefore.some((item) => item.skillKey === PROBE_SKILL_KEY),
    };

    try {
      await request("skills.status", { agentId: "__unknown_agent__" });
      checks.unknownAgentError = {
        ok: false,
        error: "unexpected success",
      };
    } catch (error) {
      checks.unknownAgentError = {
        ok: true,
        error: asErrorMessage(error),
      };
    }

    const updateUnknown = await request("skills.update", {
      skillKey: PROBE_SKILL_KEY,
      enabled: false,
    });
    checks.updateUnknown = {
      ok: true,
      response: updateUnknown,
    };

    const statusAfter = await request("skills.status", {});
    const skillsAfter = Array.isArray(statusAfter.skills) ? statusAfter.skills : [];
    checks.statusAfter = {
      total: skillsAfter.length,
      containsProbeSkillKey: skillsAfter.some((item) => item.skillKey === PROBE_SKILL_KEY),
    };

    try {
      await request("skills.install", {
        name: "__panel_missing_skill__",
        installId: "missing",
      });
      checks.installMissingError = {
        ok: false,
        error: "unexpected success",
      };
    } catch (error) {
      checks.installMissingError = {
        ok: true,
        error: asErrorMessage(error),
      };
    }

    try {
      await request("skills.bins", {});
      checks.binsError = {
        ok: false,
        error: "unexpected success",
      };
    } catch (error) {
      checks.binsError = {
        ok: true,
        error: asErrorMessage(error),
      };
    }

    const finishedAt = nowIso();
    const result = {
      startedAt,
      finishedAt,
      wsUrl: WS_URL,
      probeId,
      probeSkillKey: PROBE_SKILL_KEY,
      clientDistFile: runtime.fileName,
      hello,
      lastClose,
      checks,
      rpcTrace,
      stats: {
        rpcTotal: rpcTrace.length,
        rpcFailed: rpcTrace.filter((item) => !item.ok).length,
      },
      observations: [
        "skills.status 返回的是可识别技能列表；probe skillKey 不在列表中。",
        "skills.update 对 probe skillKey 返回成功（即使该 key 不在 skills.status）。",
        "skills.install 缺失技能名会失败并返回错误。",
        "skills.bins 对 operator 角色默认拒绝（unauthorized role）。",
      ],
    };

    process.stdout.write(`${JSON.stringify(result, null, 2)}\n`);
  } finally {
    client.stop();
  }
}

await main();
</file>

<file path="plan/2026-02-16_ClawX源码调研/evidence/skills-config-writeback-5.3-live.md">
# 5.3 运行态证据：Skills 配置写回与校验回滚

时间：2026-02-16

## 1) API 写回链路验证（真实容器）

目标接口：`PUT /api/skills/:skillKey/config`
验证对象：`healthcheck`

执行步骤：
1. 写入补丁：`enabled=true` + `env.PANEL_WRITEBACK_SMOKE=1`
2. 清理补丁：`env.PANEL_WRITEBACK_SMOKE=""`（删除该键）
3. 读取最终配置确认回收

结果（节选）：

```json
{
  "set": {
    "ok": true,
    "result": {
      "skillKey": "healthcheck",
      "config": {
        "enabled": true,
        "hasApiKey": false,
        "env": {
          "PANEL_WRITEBACK_SMOKE": "*"
        }
      }
    }
  },
  "clear": {
    "ok": true,
    "result": {
      "skillKey": "healthcheck",
      "config": {
        "enabled": true,
        "hasApiKey": false,
        "env": {}
      }
    }
  },
  "final": {
    "ok": true,
    "result": {
      "skillKey": "healthcheck",
      "enabled": true,
      "hasApiKey": false,
      "env": {}
    }
  }
}
```

结论：
- 写入后读取校验成功；
- `KEY=` 删除逻辑生效；
- 最终状态已回收到无临时 env 键。

## 2) 前端页面可见性验证（Chrome DevTools MCP）

目标页面：`http://127.0.0.1:18080/skills`

快照命中：
- `Skill 配置写回` 卡片存在
- 字段存在：`启用状态` / `API Key（留空不改）` / `清除当前 API Key` / `环境变量补丁`
- 操作按钮存在：`保存 Skill 配置`

结论：
- Skills 页已具备可视化写回入口，不再只能“查看配置”。

## 3) 自动化验证

命令：

```powershell
node --check public/app.js
node --check src/server.js
npm run test:unit
npm run test:regression
```

结果：
- `node --check` 全部通过
- `test:unit`：51/51 通过（新增 `prepareSkillConfigUpdate` 覆盖）
- `test:regression`：3 通过，1 跳过

## 4) Docker 验证

命令：

```powershell
docker compose up -d --build panel
```

结果：
- `openclaw-panel:local` 构建成功
- `openclaw-panel` 容器重建并启动成功
</file>

<file path="plan/2026-02-16_ClawX源码调研/evidence/skills-list-status-5.1-live.md">
# 5.1 运行态证据：Skills 列表与状态展示

时间：2026-02-16

## 1) 运行态页面校验（Chrome DevTools MCP）

目标页面：`http://127.0.0.1:18080/skills`

快照关键项：

- 页面说明文案包含：`查看技能状态、说明、最近更新时间`
- Skill 列表项包含：
  - `key: ... | source: ... | bundled: ... | 最近更新: ...`
  - `说明：...`

示例（快照摘录）：

- `key: feishu-doc | source: openclaw-extra | bundled: 否 | 最近更新: 无`
- `说明：Feishu document read/write operations...`

结论：
- Skills 列表已覆盖“名称/启用状态/说明/最近更新时间”四类核心信息。
- 对无更新时间的技能，页面显示 `最近更新: 无`，避免空值歧义。

## 2) 自动化验证

命令：

```powershell
node --check public/app.js
npm run test:unit
npm run test:regression
```

结果：
- `node --check` 通过
- `test:unit`：48/48 通过（含 skills-service 归一化断言）
- `test:regression`：3 通过，1 跳过

## 3) Docker 验证

命令：

```powershell
docker compose up -d --build panel
```

结果：
- `openclaw-panel:local` 构建成功
- `openclaw-panel` 重建并启动成功
</file>

<file path="plan/2026-02-16_ClawX源码调研/evidence/skills-service-live.json">
{
  "toggleEndpoint": "/api/skills/__unknown_skill__/enabled",
  "configSkillKey": "skill-creator",
  "statusOk": true,
  "testedAt": "2026-02-16 15:15:47 +08:00",
  "configOk": true,
  "statusEndpoint": "/api/skills/status",
  "unknownToggleOk": false,
  "unknownToggleMessage": "未知技能：__unknown_skill__",
  "skillsTotal": 53,
  "configEndpoint": "/api/skills/skill-creator/config"
}
</file>

<file path="plan/2026-02-16_ClawX源码调研/evidence/skills-toggle-confirm-5.2-live.md">
# 5.2 运行态证据：Skills 启停二次确认

时间：2026-02-16

## 1) 运行态确认弹窗校验（Chrome DevTools MCP）

目标页面：`http://127.0.0.1:18080/skills`

执行脚本返回：

```json
{
  "ok": true,
  "confirmMessage": "你正在禁用 Skill「feishu-doc」。\n这可能影响已有工作流，确认继续吗？",
  "skillToggleRequestSent": false,
  "confirmShown": true
}
```

结论：
- 点击高风险动作（禁用已启用 Skill）会先弹二次确认。
- 用户取消后不会发送启停请求（`/api/skills/:skillKey/enabled` 未触发）。

## 2) 自动化验证

命令：

```powershell
node --check public/app.js
npm run test:unit
npm run test:regression
```

结果：
- `node --check` 通过
- `test:unit`：48/48 通过
- `test:regression`：3 通过，1 跳过

## 3) Docker 验证

命令：

```powershell
docker compose up -d --build panel
```

结果：
- `openclaw-panel:local` 构建成功
- `openclaw-panel` 重建并启动成功
</file>

<file path="plan/2026-02-16_ClawX源码调研/evidence/test-automation-7.1-live.md">
# 7.1 运行态证据：自动化测试收口

时间：2026-02-16

## 执行命令

```powershell
node --check public/app.js
node --check src/server.js
npm run test:unit
npm run test:regression
npm run test
```

## 结果

- 语法检查：
  - `public/app.js` 通过
  - `src/server.js` 通过
- 单元测试：`51/51` 通过
- 回归测试：`3` 通过，`1` 跳过（`docker-rollback keeps .env unchanged when target image pull fails`）
- 聚合测试命令 `npm run test` 通过（等价执行 `test:unit + test:regression`）

## 结论

- 当前主线改造在自动化层面通过；
- 可进入 `7.2` 手工关键路径回放。
</file>

<file path="plan/2026-02-17_配置核心与前端主脚本拆分/技术设计.md">
# 技术设计

## 背景与约束
- 当前架构：Fastify + 原生 HTML/CSS/JS，前端无构建链。
- 部署约束：生产为 Linux Docker，外部访问为“母机公网 IP + 端口”；容器间通信走内网。
- 兼容约束：拆分后对外行为必须等价，避免“结构改造带来功能变化”。

## 目标
1. 将 `src/openclaw-config.js` 从“单文件多职责”改为“模块化单职责”。
2. 将 `public/app.js` 从“超级控制器”改为“核心层 + 页面层”。
3. 拆分后保持接口契约、用户交互和配置语义不变。

## 不做（Non-Goals）
- 不新增业务功能。
- 不调整页面路由与导航信息结构。
- 不改变现有配置文件字段定义。

## 一、`src/openclaw-config.js` 拆分方案

### 1) 目标目录
```text
src/openclaw-config/
├── schema.js          # zod schema 与类型约束
├── helpers.js         # 纯函数工具（解析、归一化、脱敏辅助）
├── extract.js         # OpenClaw config -> panel settings
├── apply.js           # panel settings -> OpenClaw config
└── storage.js         # load/save + 原子写入
src/openclaw-config.js # 兼容门面，保持旧导出
```

### 2) 依赖方向（硬约束）
- `extract.js` / `apply.js` 可依赖 `schema.js` 与 `helpers.js`。
- `storage.js` 不依赖 `extract.js` / `apply.js`。
- `src/openclaw-config.js` 只做 re-export，不放业务逻辑。
- 禁止循环依赖。

### 3) 对外契约（保持不变）
继续从 `src/openclaw-config.js` 导出：
- `loadOpenClawConfig`
- `extractSettings`
- `applySettings`
- `saveOpenClawConfig`
- `openClawSettingsSchema`

## 二、`public/app.js` 拆分方案

### 1) 目标目录
```text
public/js/
├── core/
│   ├── dom.js                # 通用 DOM 读写工具
│   ├── message-center.js     # 全局提示、时间线提示
│   ├── theme.js              # 主题切换
│   ├── runtime-state.js      # 全局状态容器（只放共享状态）
│   └── bootstrap.js          # 按页面装载 init
├── shared/
│   ├── model-utils.js        # 模型 ref/模式/URL 联动纯函数
│   └── channel-utils.js      # 渠道字段归一化纯函数
└── pages/
    ├── dashboard-page.js
    ├── model-page.js
    ├── channels-page.js
    ├── telegram-page.js
    ├── feishu-page.js
    ├── discord-page.js
    ├── slack-page.js
    ├── skills-page.js
    ├── chat-page.js
    ├── service-page.js
    ├── update-page.js
    ├── logs-page.js
    └── config-generator-page.js
public/app.js                 # 最终仅保留入口与注册表
```

### 2) 拆分原则
- 每个页面模块只处理本页 DOM 与交互。
- 跨页面共享逻辑下沉到 `core` 或 `shared`，禁止页面间互相 import。
- 事件绑定必须“按页激活”，没有对应 DOM 时不得执行。
- 保留 `public/app.js` 作为稳定入口，避免改动所有 HTML script 引用。

### 3) 页面初始化契约
每个页面模块统一导出：
- `initXxxPage(context)`
- 可选 `destroyXxxPage()`（后续如果需要页面缓存/热切换）

`context` 至少包含：
- `requestJson`（来自 `app-api.js`）
- `api`（带统一错误包装）
- `setMessage`
- 必要共享状态 getter/setter

## 三、测试策略与门禁

### 1) 拆分前基线（防回归）
- 固化基线：
  - 现有 `npm test` 结果；
  - 关键 API 手工回放步骤；
  - 关键页面行为清单（保存配置、模型切换、服务启停、更新检查、聊天发送）。
- 先记录，再拆分，避免“没有基线就无法判断回归”。

### 2) 后端拆分测试
- 单元：`test/unit/openclaw-config.test.js` 扩展以下断言：
  1. `extractSettings` 对高级 Telegram 字段输出不变；
  2. `applySettings` 对 JSON 字段/secret 保留策略不变；
  3. `load/save` 读写与备份行为不变。
- 回归：跑全量 `npm test`。

### 3) 前端拆分测试
- 自动化：保持现有回归测试全通过。
- 手工 smoke（Docker 运行态，必须复现）：
  1. `/dashboard`：刷新、模型快速切换；
  2. `/model`：默认模型保存、新增提供商（基础模式）；
  3. `/channels/telegram`：基础引导保存并启用、验证码配对；
  4. `/service`：启动/停止后状态自动刷新；
  5. `/update`：自动检查、手动升级入口；
  6. `/chat-console`：会话切换、发送、流式输出。

### 4) Linux 一致性验证
- 在 Linux Docker 至少执行一次与 Windows 同口径回放。
- 验证项必须包含端口/地址展示：前端外部地址必须为“公网 IP + 端口”。

## 四、结构合理性保障
- 单文件治理阈值：
  - `openclaw-config` 任一模块建议 < 300 行；
  - 页面模块建议 < 500 行，超过即继续拆子模块。
- 单向依赖：`core/shared -> pages`，禁止反向依赖。
- 稳定门面：旧导入路径不变，降低改造面。
- 评审清单：每步检查“职责是否单一、是否可替换、是否可单测”。

## 五、功能等价保障
- 保持 API、配置字段、按钮行为、提示文案语义不变（除明确修 bug 场景）。
- 每阶段提交后立即跑测试 + Docker 重建，不允许“攒到最后统一验证”。
- 每个阶段都留可回退 commit 点，故障时可秒回滚。

## 六、执行顺序
1. 建立拆分基线与测试门禁。
2. 先拆 `src/openclaw-config.js`（后端可测、风险可控）。
3. 再拆 `public/app.js`（先两页试点，再全量页面）。
4. 全量回归 + Linux 复验 + 文档更新。
</file>

<file path="plan/2026-02-17_配置核心与前端主脚本拆分/任务清单.md">
# 任务清单

## 1. 文档与基线阶段
- [x] 1.1 完成提案、技术设计、任务清单落盘 | 验收：`plan/2026-02-17_配置核心与前端主脚本拆分/` 文档齐全
- [x] 1.2 建立拆分前基线（测试结果 + 关键手工回放清单） | 验收：形成基线记录并可复用
- [x] 1.3 明确 Linux 一致性回放口径 | 验收：与 Windows 回放步骤一一对应

## 2. 后端配置核心拆分阶段（`src/openclaw-config.js`）
- [x] 2.1 拆出 `schema.js` 与 `helpers.js` | 验收：schema 导出与纯函数单测通过
- [x] 2.2 拆出 `extract.js` | 验收：`extractSettings` 行为与拆分前一致
- [x] 2.3 拆出 `apply.js` | 验收：`applySettings` 行为与拆分前一致
- [x] 2.4 拆出 `storage.js` + 保留门面 `src/openclaw-config.js` | 验收：现有 import 路径无需修改即可运行
- [x] 2.5 补齐/更新单测 | 验收：`npm run test:unit` 通过

## 3. 前端主脚本拆分阶段（`public/app.js`）
- [x] 3.1 提取 `core`（message/theme/runtime/bootstrap） | 验收：全页面可加载，无全局报错
- [x] 3.2 拆分 Dashboard + Model 页面模块（试点） | 验收：两页关键交互功能等价
- [x] 3.3 拆分 Channels 与 Telegram/Feishu/Discord/Slack 页面模块 | 验收：渠道保存、测试、引导流程正常
- [x] 3.4 拆分 Skills + Chat 页面模块 | 验收：技能启停/写回、聊天流式与会话操作正常
- [x] 3.5 拆分 Service + Update + Logs + Config Generator 页面模块 | 验收：服务控制、更新、日志、配置生成器均正常
- [x] 3.6 收敛 `public/app.js` 为轻入口 | 验收：入口文件仅负责注册与初始化调度

## 4. 验证与发布门禁阶段
- [x] 4.1 全量自动化测试 | 验收：`npm test` 通过
- [x] 4.2 Docker 重建与 9 页手工回放 | 验收：`docker compose up -d --build panel` 后关键流程通过
- [x] 4.3 Linux 回归复验 | 验收：Linux Docker 流程回放通过并记录差异

## 5. 收尾阶段
- [x] 5.1 同步更新主线任务文档状态 | 验收：`plan/2026-02-16_ClawX源码调研/任务清单.md` 补充引用
- [x] 5.2 如无外部行为变更，在任务汇报明确“纯结构改造” | 验收：规格变更是否需要落盘有书面结论
- [ ] 5.3 归档（待用户验收后） | 验收：目录与证据完整

## 经验记录
### 步骤 1.1 完成记录
- 实际情况：已完成本任务三份规划文档落盘，明确“先后端再前端、先试点再全量”的执行路径。
- 遇到问题：仓库已有大量业务功能，拆分若不分阶段容易出现定位困难；已在任务清单中强制阶段提交与阶段验证。
- 技术债：尚未建立拆分前的测试基线记录（1.2），这是下一步必须先补的门禁。

### 步骤 1.2 / 1.3 完成记录
- 实际情况：已完成拆分前基线验证：`npm test` 全通过（1 条既有 skip）、`docker compose up -d --build panel` 成功、11 个核心 API/页面探针全部 200。
- 遇到问题：无阻断问题；构建日志出现孤儿容器提示，不影响本任务拆分改造。
- 技术债：Linux 实地回放尚未执行，仅完成一致性回放口径定义；需在 4.3 阶段补实测证据。

### 步骤 2.1 ~ 2.5 完成记录
- 实际情况：`src/openclaw-config.js` 已拆分为 `schema/helpers/extract/apply/storage` 五个子模块，原文件保留兼容门面导出。
- 遇到问题：无行为层阻断问题；拆分后所有既有导入路径保持不变，避免影响服务层引用。
- 技术债：`openclaw-config` 拆分已完成，下一步主要风险转移到 `public/app.js` 的页面级拆分。

### 步骤 3.1 ~ 3.6 完成记录
- 实际情况：`public/app.js` 已收敛为入口调度，核心逻辑拆分为 `core + pages` 模块，覆盖 Dashboard/Model/Channels/Skills/Chat/Service/Update/Logs/Config Generator 全部页面路径。
- 遇到问题：拆分初版在 Dashboard 页面出现 `toNonNegativeInt` 未导入导致浏览器运行时报错；已补导入并完成浏览器控制台复验。
- 技术债：当前模块拆分已形成清晰边界；后续若继续增长，建议把 `system-page.js` 再按“渠道/服务/更新/日志”细拆。

### 步骤 4.1 ~ 4.3 完成记录
- 实际情况：已完成 `npm test`、Docker 重建、关键路由可达性探针、浏览器控制台检查和 Linux 容器内 API 回放。
- 遇到问题：Linux 容器回放初次使用了错误端口（8080）；校正为容器内实际监听端口 `18080` 后验证通过。
- 技术债：4.3 目前基于 Linux 容器回放完成；后续如需严格生产宿主验证，可在真实 Linux 主机补做一次同口径手工页面回放。

### 步骤 5.1 / 5.2 完成记录
- 实际情况：已将拆分进展同步回主线任务文档 `plan/2026-02-16_ClawX源码调研/任务清单.md`，形成跨任务可追溯记录。
- 结论：本轮属于“纯结构治理 + 缺陷修复（导入缺失）”，未引入新的外部 API 契约变化；无需新增规格变更文档，已在任务汇报中保留书面结论。
</file>

<file path="plan/2026-02-17_配置核心与前端主脚本拆分/提案.md">
# 配置核心与前端主脚本拆分

创建时间：2026-02-17 05:20:00

## 为什么做
- `src/openclaw-config.js` 当前约 856 行，同时承担 schema、配置提取、配置写回、文件读写四类职责，回归风险高。
- `public/app.js` 当前约 3770 行，承担 9 个页面的逻辑与全局状态，改动任何页面都可能误伤其它页面。
- 现有产品面向小白用户，功能要稳；继续单文件膨胀会直接拉高线上故障概率和迭代成本。

## 改什么
- 对 `src/openclaw-config.js` 做“有边界拆分”，保持对外 API 不变。
- 对 `public/app.js` 做“按核心能力 + 按页面职责拆分”，保留现有路由与用户可见行为。
- 补齐拆分后的回归测试与 Docker 运行态验证，确保 Linux 生产可用。

## 影响范围
- 后端：`src/openclaw-config.js`、新增 `src/openclaw-config/*` 子模块、`src/server.js` 及引用方（仅导入路径/导出兼容层）。
- 前端：`public/app.js`、新增 `public/js/core/*`、`public/js/pages/*`。
- 测试：`test/unit/openclaw-config.test.js`、必要时新增前端关键路径 smoke 校验脚本。
- 风险等级：L2（跨模块结构改造，涉及配置写入与多页面交互主干）。

## 不做什么（边界）
- 不改变任何现有 API 契约（字段名、路由、响应结构保持一致）。
- 不引入 React/Vue/Vite 等新构建体系。
- 不改 OpenClaw/龙虾 Bot 核心源码。
- 不在本任务内做额外产品功能扩展，只做结构治理与等价迁移。

## 验证（存在风险时必填）
- 自动化：`npm run test:unit`、`npm run test:regression`、`npm test` 全通过。
- 语法检查：拆分后所有新文件执行 `node --check`。
- 运行态：`docker compose up -d --build panel` 后，9 个页面关键操作通过。
- Linux 一致性门禁：至少补 1 轮 Linux Docker 回放记录（配置保存、模型切换、渠道保存、服务控制、更新检查）。

## 回滚（存在风险时必填）
- 回滚触发条件：
  1. 配置写回出现字段丢失/误写；
  2. 页面交互行为与拆分前不一致；
  3. Docker 运行态出现稳定性回归。
- 回滚步骤：
  1. 以阶段提交为单位回退到上一个稳定 commit；
  2. 保留本次失败证据（日志/步骤/输入）并回写任务清单；
  3. 调整拆分边界后从最近通过阶段重进。
</file>

<file path="plan/2026-02-17_配置核心与前端主脚本拆分/evidence/1.2_1.3_拆分前基线与一致性口径.md">
# 1.2 / 1.3 拆分前基线与一致性口径

记录时间：2026-02-17 04:45（UTC+8）

## 一、自动化基线

执行命令：

```bash
npm test
```

结果：
- `test:unit`：58/58 通过。
- `test:regression`：3 通过，1 跳过（已知 skip：`docker-rollback keeps .env unchanged when target image pull fails`）。
- 无失败用例。

## 二、Docker 运行态基线

执行命令：

```bash
docker compose up -d --build panel
```

结果：
- `openclaw-panel` 重建并启动成功。
- `openclaw-gateway` 保持运行。

## 三、页面/API 可达性探针

执行命令（PowerShell）：

```powershell
$targets = @(
  'http://127.0.0.1:18080/api/health',
  'http://127.0.0.1:18080/dashboard',
  'http://127.0.0.1:18080/model',
  'http://127.0.0.1:18080/channels',
  'http://127.0.0.1:18080/channels/telegram',
  'http://127.0.0.1:18080/skills',
  'http://127.0.0.1:18080/chat-console',
  'http://127.0.0.1:18080/service',
  'http://127.0.0.1:18080/update',
  'http://127.0.0.1:18080/logs',
  'http://127.0.0.1:18080/config-generator'
)
foreach ($u in $targets) {
  $r = Invoke-WebRequest -Uri $u -UseBasicParsing -TimeoutSec 10
  "OK $($r.StatusCode) $u"
}
```

结果：
- 以上 11 个目标全部返回 `200`。

## 四、Linux 一致性回放口径（1.3）

### 回放维度
1. 配置保存：`/model` 与 `/channels/telegram`。
2. 运行控制：`/service` 启停与状态刷新。
3. 更新能力：`/update` 自动检查 + 手动触发升级流程。
4. 聊天能力：`/chat-console` 会话切换 + 发送 + 流式输出。
5. 地址展示：外部地址和 Webhook 展示必须为“公网 IP + 端口”。

### 判定标准
- 与 Windows Docker 基线行为一致（同样步骤、同样结果语义）。
- 无“仅 Windows 有效”的脚本路径、权限、网络依赖。
- 容器间通信仅走内网，不依赖公网映射端口。

### 备注
- 本文只定义口径，不替代 4.3 的 Linux 实地回放。4.3 必须在 Linux 环境补证据。
</file>

<file path="plan/2026-02-17_配置核心与前端主脚本拆分/evidence/2.x_openclaw-config拆分验证.md">
# 2.x openclaw-config 拆分验证

记录时间：2026-02-17 04:50（UTC+8）

## 拆分结果

原文件：
- `src/openclaw-config.js`（856 行，单文件多职责）

拆分后：
- `src/openclaw-config/schema.js`
- `src/openclaw-config/helpers.js`
- `src/openclaw-config/extract.js`
- `src/openclaw-config/apply.js`
- `src/openclaw-config/storage.js`
- `src/openclaw-config.js`（兼容门面，仅 re-export）

## 兼容性确认

- 保持 `src/openclaw-config.js` 原导出名不变：
  - `loadOpenClawConfig`
  - `extractSettings`
  - `applySettings`
  - `saveOpenClawConfig`
  - `openClawSettingsSchema`
- 现有引用点（`src/server.js`、`src/dashboard-service.js`、`src/skills-service.js`、`src/smoke-check.js`）无需改导入路径。

## 验证命令与结果

1. 语法检查：

```bash
node --check src/openclaw-config.js
node --check src/openclaw-config/schema.js
node --check src/openclaw-config/helpers.js
node --check src/openclaw-config/extract.js
node --check src/openclaw-config/apply.js
node --check src/openclaw-config/storage.js
```

结果：全部通过。

2. 单元测试：

```bash
npm run test:unit
```

结果：58/58 通过。

3. 全量测试：

```bash
npm test
```

结果：通过（回归 1 条既有 skip）。

4. Docker 运行态：

```bash
docker compose up -d --build panel
```

结果：重建成功，`/api/health` 返回 200。
</file>

<file path="plan/2026-02-17_配置核心与前端主脚本拆分/evidence/3.x_4.x_appjs拆分与回归验证.md">
# 3.x / 4.x app.js 拆分与回归验证

记录时间：2026-02-17 05:10（UTC+8）

## 一、拆分结果

### 入口文件收敛
- `public/app.js` 从超大脚本收敛为“初始化入口 + 事件绑定调度”。

### 新增模块
- `public/js/core/panel-core.js`
- `public/js/pages/config-generator-page.js`
- `public/js/pages/model-dashboard-page.js`
- `public/js/pages/skills-page.js`
- `public/js/pages/chat-page.js`
- `public/js/pages/system-page.js`

## 二、语法与自动化验证

### 语法检查

```bash
node --check public/app.js
node --check public/js/core/panel-core.js
node --check public/js/pages/config-generator-page.js
node --check public/js/pages/model-dashboard-page.js
node --check public/js/pages/skills-page.js
node --check public/js/pages/chat-page.js
node --check public/js/pages/system-page.js
```

结果：全部通过。

### 自动化测试

```bash
npm test
```

结果：通过（`test:unit` 58/58 通过；`test:regression` 3 通过 + 1 既有 skip）。

## 三、Docker 回归验证

执行命令：

```bash
docker compose up -d --build panel
```

结果：
- 构建成功；
- `openclaw-panel` 启动成功。

HTTP 探针结果（11 项）：
- `/api/health`
- `/dashboard`
- `/model`
- `/channels`
- `/channels/telegram`
- `/skills`
- `/chat-console`
- `/service`
- `/update`
- `/logs`
- `/config-generator`

以上全部返回 `200`。

## 四、浏览器控制台验证（关键页面）

已检查页面：
- `/dashboard`
- `/model`
- `/channels/telegram`
- `/skills`
- `/chat-console`
- `/service`
- `/update`
- `/logs`
- `/config-generator`
- `/channels`

结果：
- 无 JS runtime error；
- 存在少量 DOM 提示级警告（例如 password 字段未在 form 内），非本次拆分引入的功能阻断问题。

## 五、Linux 一致性回放（容器内）

在 Linux 容器 `openclaw-panel` 内执行 API 回放：
- `GET /api/health` -> 200
- `GET /api/panel-config` -> 200
- `GET /api/settings` -> 200
- `GET /api/dashboard/summary` -> 200
- `POST /api/service/status` -> 200
- `GET /api/update/check` -> 200
- `GET /api/chat/sessions` -> 200
- `GET /api/skills/status` -> 200

结论：
- 拆分后主流程在 Linux 容器内保持可用；
- 与 Windows Docker 基线行为一致（同语义返回）。
</file>

<file path="plan/2026-02-17_Telegram启用失败根因修复/规格变更/OpenClaw面板.md">
# OpenClaw面板 - 变更

## 修改需求

### 需求：可视化配置中心

面板必须支持以字段化方式编辑 OpenClaw 关键配置，至少覆盖 API、Base URL、模型、Telegram、飞书、Discord、Slack 等常用字段。

#### 场景：字段化编辑
- 当 用户进入配置中心并修改关键字段
- 那么 系统必须进行输入校验并写入配置文件

#### 场景：敏感字段保护
- 当 用户查看已保存的 API Key 或 Secret
- 那么 面板必须默认掩码显示，不直接明文回显

#### 场景：字段校验
- 当 用户提交配置
- 那么 系统必须执行必填、URL 格式、模型名非空等基础校验

#### 场景：OpenClaw 官方字段映射
- 当 用户修改模型与渠道配置
- 那么 系统必须映射到官方字段：`models.providers.*`、`agents.defaults.model.primary`、`channels.telegram.*`、`channels.feishu.*`、`channels.discord.*`、`channels.slack.*`

#### 场景：Telegram 快速接入可视输入
- 当 用户在 Telegram 基础配置第 1 步输入 Bot Token
- 那么 输入框应默认明文可见，便于粘贴核对；而已保存密钥的回显仍保持掩码值

### 需求：运行参数可配置

面板必须支持监听地址、端口、OpenClaw 配置路径、服务名、容器名、日志来源、运行时模式等运行参数可配置。

#### 场景：模板适配
- 当 面板部署到不同模板机
- 那么 运维人员必须可通过配置修改运行参数而无需改代码

#### 场景：Docker CLI 入口兼容
- 当 运行时模式为 Docker 且容器中不存在 `openclaw` 可执行入口
- 那么 系统必须自动回退到可用入口（如 `node /app/openclaw.mjs`）继续执行启用/配置命令
</file>

<file path="plan/2026-02-17_Telegram启用失败根因修复/任务清单.md">
# 任务清单

## 1. 准备阶段
- [x] 1.1 阅读现有规格与相关实现（Telegram 页面 + onboarding 命令链） | 验收：完成复现路径和根因证据记录
- [x] 1.2 确认本次任务边界与风险级别 | 验收：确认为 L1 可回滚局部修复

## 2. 实现阶段
- [x] 2.1 改造 Docker CLI 调用为可回退入口 | 验收：`openclaw` 缺失时自动切到 `node /app/openclaw.mjs`
- [x] 2.2 Telegram setup 流程复用已解析 CLI 入口 | 验收：三步执行不重复触发入口探测失败
- [x] 2.3 Telegram Bot Token 输入框改为默认明文可见 | 验收：`/channels/telegram` 首步输入框显示为文本输入
- [x] 2.4 更新/新增单测覆盖回退链路 | 验收：存在失败->回退->成功的断言

## 3. 验证阶段
- [x] 3.1 单测通过 | 验收：`node --test test/unit/channel-onboarding.test.js` 通过
- [x] 3.2 Docker 手工回放通过 | 验收：`runOpenClawCli` 在真实容器中自动回退到 `node /app/openclaw.mjs` 并成功执行 `plugins list`

## 4. 收尾阶段
- [x] 4.1 更新任务文档勾选状态与经验记录 | 验收：清单与实际一致
- [x] 4.2 规格变更与任务汇报同步 | 验收：文档可追溯本次行为变化

## 经验记录
### 步骤 1.1 / 1.2 完成记录
- 实际情况：已定位根因为 `src/channel-onboarding.js` 在 Docker 模式写死 `openclaw` 可执行入口，与当前 `ghcr.io/openclaw/openclaw:2026.2.14` 容器不一致。
- 证据：容器内 `which openclaw` 为空；`node /app/openclaw.mjs plugins enable telegram` 可执行成功。
- 技术债：CLI 入口兼容策略此前未抽象，导致镜像实现变更后直接故障。

### 步骤 2.1 ~ 2.4 完成记录
- 实际情况：已在 `runOpenClawCli` 增加 Docker CLI 入口回退机制（`openclaw` -> `node /app/openclaw.mjs`），并在 setup 三步内复用成功入口，避免重复失败。
- 实际情况补充：回退检测覆盖 `stdout/stderr/message`，兼容 OCI 报错被写入 `stdout` 的场景。
- 实际情况补充：Telegram Bot Token 输入框已改为默认明文可见（新页面与兼容旧入口同步）。
- 技术债：当前回退策略固定两种入口；若后续镜像入口再变化，建议在 panel 配置层增加显式 CLI 入口可配置项。

### 步骤 3.1 / 3.2 完成记录
- 自动化验证：`node --test test/unit/channel-onboarding.test.js` 通过（5/5）。
- Docker 手工验证：在真实容器执行 `runOpenClawCli(..., ['plugins','list'])`，已自动回退并成功，命令显示为 `docker exec openclaw-gateway node /app/openclaw.mjs plugins list`。
- 风险说明：尚未在重建后的 panel 容器上做端到端页面点击回放，本轮以单测 + 真实容器命令链路验证替代。
</file>

<file path="plan/2026-02-17_Telegram启用失败根因修复/提案.md">
# Telegram 启用失败根因修复

创建时间：2026-02-17 15:58:00

## 为什么做
- 用户在 `/channels/telegram` 页面执行“保存并启用”失败，核心报错为：`docker exec openclaw-gateway openclaw ...` 中 `openclaw` 可执行文件不存在。
- 当前实现把 Docker 模式 CLI 入口写死为 `openclaw`，与实际镜像（仅提供 `node` + `/app/openclaw.mjs`）不兼容，属于运行时入口假设错误。
- Telegram Bot Token 输入框为 `password`，用户输入后默认点点显示，不符合当前接入流程的可操作性预期。

## 改什么
- 后端：为 Docker 模式 OpenClaw CLI 调用增加“入口自动回退”能力，优先 `openclaw`，失败后自动改用 `node /app/openclaw.mjs`。
- 后端：在 Telegram 基础配置流程内复用已探测到的 CLI 入口，避免每一步重复失败重试。
- 前端：Telegram 基础配置的 Bot Token 输入框改为默认明文可见（`type="text"`）。
- 测试：补充单测覆盖 Docker CLI 回退链路，防止后续回归。

## 影响范围
- 涉及模块：`src/channel-onboarding.js`、`test/unit/channel-onboarding.test.js`、`public/pages/channels-telegram.html`（兼容入口 `public/index.html` 同步）。
- 风险等级：L1（局部行为修复，影响 Telegram onboarding 与 CLI 调用封装）。

## 不做什么（边界）
- 不修改 OpenClaw 网关容器镜像内容。
- 不改动 Telegram 配置字段结构与后端接口契约。
- 不改动其他渠道（Feishu/Discord/Slack）的字段掩码策略。

## 验证（存在风险时必填）
- 自动化：`node --test test/unit/channel-onboarding.test.js`
- 手工：在当前 Docker 运行环境复测 Telegram setup 链路，确认不再出现 `exec: "openclaw": executable file not found`。

## 回滚（存在风险时必填）
- 回滚触发条件：
  1. Telegram setup/pairing 命令执行行为异常；
  2. 命令脱敏输出出现明文泄漏；
  3. 输入框改动引发前端保存流程异常。
- 回滚步骤：
  1. 回退 `src/channel-onboarding.js` 与 `public/pages/channels-telegram.html`/`public/index.html` 到改动前版本；
  2. 重新执行单测与手工流程确认恢复。
</file>

<file path="plan/2026-02-18_更新与模型配置回归修复/任务清单.md">
# 任务清单

## 1. 准备阶段
- [x] 1.1 阅读评审问题与相关代码定位
- [x] 1.2 确认无不可逆操作与发布阻断风险

## 2. 实现阶段
- [x] 2.1 修复 helper sleep 执行方式 | 验收：轮询间隔逻辑代码可读且不再调用 docker 伪 sleep
- [x] 2.2 修复 existing 模型 ID 切换后字段同步 | 验收：切换 ID 时 name/context/max 同步刷新
- [x] 2.3 修复 template 模型 ID 切换后名称残留 | 验收：切换 ID 后默认名称与 ID 匹配
- [x] 2.4 修复更新请求抛错时进度条不收口 | 验收：异常路径下 progress 进入失败完成态
- [x] 2.5 加固更新链路容错与回滚 | 验收：失效 token 可回退查询；apply helper 带旧镜像回滚计划

## 3. 验证阶段
- [x] 3.1 node --check 通过
- [x] 3.2 npm run test:unit 通过
- [x] 3.3 API 烟雾验证通过（check/upgrade 异常路径）
- [ ] 3.4 手工回放关键路径

## 4. 收尾阶段
- [x] 4.1 汇总修复结果与风险
- [ ] 4.2 按需提交代码

## 经验记录
### 步骤 2 完成记录
- 实际情况：4 个回归点均已修复，并补充了更新链路两项可靠性加固（GHCR 无 token 回退 + apply 失败回滚预案）。
- 遇到问题：浏览器 MCP 当前会话被占用，未完成 UI 手工回放，需本地页面自测补充。
- 技术债：缺少前端交互自动化测试（模型页字段同步与更新异常进度收口）；缺少端到端更新流程自动化测试（check/pull/apply/reconnect）
</file>

<file path="plan/2026-02-18_更新与模型配置回归修复/提案.md">
# 更新与模型配置回归修复

创建时间：2026-02-18 00:00:00

## 为什么做
- 评审已确认 4 个可复现回归：更新应用流程在慢机误失败、模型 ID 切换后字段串值、模板模型名滞留、更新异常时进度条不收口。
- 这些问题会直接造成错误写配置或错误引导用户，属于必须立即修复的功能性缺陷。

## 改什么
- 修复 `src/docker-update.js` helper 脚本的 sleep 实现，确保轮询间隔真实等待。
- 加固 `src/docker-update.js` 更新链路可靠性：
  - GHCR 查询遇到 401/403 时，支持匿名 token 回退，避免失效 token 导致检查更新整体失效。
  - 控制台 `apply` 走 helper 重建时，增加失败回滚计划（回退旧镜像）并优先使用旧镜像启动 helper。
- 修复 `public/js/pages/model-dashboard-page.js`：
  - 选择已有供应商模型 ID 变化时，刷新模型名称/上下文/最大输出。
  - 模板路径切换模型 ID 时，正确刷新默认模型名，避免旧名残留。
- 修复 `public/js/pages/system-page.js`：当更新请求抛异常时，强制结束进度 ticker 并标记失败。

## 影响范围
- 涉及模块：Docker 更新执行、模型配置前端页、系统更新前端页
- 涉及接口：无新增接口；修复现有交互行为
- 风险等级：L1

## 不做什么（边界）
- 不改动现有更新 API 协议和返回结构。
- 不引入新的模型配置字段或页面结构重构。
- 不调整版本发布流程。

## 验证（存在风险时必填）
- `node --check` 校验变更文件语法。
- `npm run test:unit` 回归单元测试。
- API 烟雾验证：`/api/update/check`、`/api/update/upgrade` 异常路径可返回明确错误。
- 手工回放：切换模型 ID 后观察字段是否同步；触发更新异常确认进度条收口。

## 回滚（存在风险时必填）
- 回滚触发条件：修复后出现更新流程阻断或模型保存异常。
- 回滚步骤：回退本次三个文件改动并重启面板容器。
</file>

<file path="plan/2026-02-18_会话纪要与SSH隧道接入稳定化/会话纪要.md">
# 会话纪要（日记）

记录时间：2026-02-18 17:55:20  
记录范围：本轮关于 Bot 交付、模板机网络、SSH 隧道与 Gateway 鉴权的排查与决策

## 1. 背景
- 交付目标从“公网直连 URL 直接访问”调整为“优先 SSH 隧道访问”，降低公网暴露风险。
- 用户关注点集中在三块：
  - VM_READY 输出是否可直接操作。
  - 模板机与新开小机行为差异。
  - 长期稳定连接方式（不希望隧道自动掉线）。

## 2. 关键时间线（摘要）
1. Bot 端完成 VM_READY 输出增强：新增 SSH 隧道命令与本地访问地址字段，相关代码已提交并推送。
2. 新开小机出现 `gateway token missing` 等提示，经排查确认并非“模板无 token”，而是浏览器侧未带 token。
3. 模板机升级 `openclaw-panel:0.1.2` 初次失败，定位到模板机公网出站不通（DNS/443 超时）。
4. 对比 VM100 与 VM101 后确认关键差异：VM100 网卡配置含 `firewall=1`，VM101 无该标记。
5. 回滚 VM100 网卡 `firewall=1` 后，模板机 DNS 与 443 出站恢复，镜像拉取成功，panel 升级到 `0.1.2`。
6. SSH 隧道长连需求明确：单次 `ssh -N` 不满足长期在线，后续按“心跳 + 自动重连 + 密钥登录”推进。

## 3. 当前已确认状态
- 模板机 `openclaw-panel` 运行版本：`ghcr.io/bianshumeng/openclaw-panel:0.1.2`。
- 模板机公网出站：已恢复（DNS 可解析，TCP 443 可连）。
- 公网直连策略：日本中转链路已搁置，持续使用“母机公网 IP + 端口”。
- 隧道接入策略：默认推荐 SSH 隧道；密码登录仅临时可用，长期方案应切换为密钥登录。

## 4. 争议点结论
- “是不是网页鉴权改坏了网络”：
  - 结论：网页鉴权不是直接根因。
  - 根因链路：网络策略收紧 + 模板机网卡特殊配置叠加，导致该机器出站异常。
- “为什么第一次能拉镜像，后来不行”：
  - 结论：首次拉取发生在网络收紧前；后续链路变化后触发问题。

## 5. 下一步开发入口
- 目标：把“SSH 密钥下发 + 隧道长连”变成标准交付能力，减少人工操作与掉线影响。
- 待执行事项：
  - 定义密钥交付模型（安全边界、存储边界、回收机制）。
  - Bot 回包增加跨平台密钥接入指令模板。
  - 连接文案统一为“先建隧道、后访问本地地址”的单一路径。
</file>

<file path="plan/2026-02-18_会话纪要与SSH隧道接入稳定化/任务清单.md">
# 任务清单

## 1. 准备阶段
- [x] 1.1 扫描现有 `plan/` 文档结构与命名风格
- [x] 1.2 确认会话持久层文件存在情况（本仓库无 `CLAUDE.md/progress.txt/lessons.md`）

## 2. 会话归档阶段
- [x] 2.1 新建任务目录并落盘提案文档 | 验收：`提案.md` 可读
- [x] 2.2 编写会话纪要（日记） | 验收：含时间线、证据、结论、动作、当前状态
- [x] 2.3 敏感信息脱敏 | 验收：纪要不含明文密码/token/私钥

## 3. 验证阶段
- [x] 3.1 文档结构检查通过
- [x] 3.2 关键结论与当前机器状态一致（模板机出网恢复、panel=0.1.2）

## 4. 下一步开发（起始清单）
- [ ] 4.1 明确密钥下发方案边界（用户自生成 vs 平台代发） | 验收：方案确认
- [ ] 4.2 设计 Bot 输出改造（VM_READY 增加密钥接入指导） | 验收：字段草案
- [ ] 4.3 设计长连隧道接入文案（Windows/macOS/Linux） | 验收：统一模板
- [ ] 4.4 开始代码实施（待你确认后执行） | 验收：提交可测改动

## 经验记录
### 步骤 2 完成记录
- 实际情况：本轮已把高频争议点（公网出站、模板机网络差异、隧道长连）集中归档。
- 遇到问题：排查过程中存在“同一链路多处观测结果冲突”，通过对比 VM100/VM101 配置差异收敛。
- 技术债：尚未完成 SSH 密钥下发自动化，当前长期连接仍依赖人工密码输入。
</file>

<file path="plan/2026-02-18_会话纪要与SSH隧道接入稳定化/提案.md">
# 会话纪要与 SSH 隧道接入稳定化

创建时间：2026-02-18 17:55:20

## 为什么做
- 本轮对话跨越 Bot 编排、模板机网络、Gateway 鉴权、SSH 隧道接入，结论多次迭代，若不落盘容易再次误解。
- 已出现“同一问题在不同环节重复排查”的现象，需要把根因和已执行动作固化成可追溯记录。
- 下一步要推进“密钥登录 + 长连隧道”，必须先有统一上下文。

## 改什么
- 在 `plan/` 新增会话日记，按时间线记录关键事件、证据、结论与回滚动作。
- 固化当前已确认状态：
  - 模板机公网出站异常根因与修复动作（去除 `firewall=1`）。
  - 模板机控制台镜像已升级到 `ghcr.io/bianshumeng/openclaw-panel:0.1.2`。
  - SSH 隧道长连策略与风险边界（密码登录仅临时，长期建议密钥）。
- 建立下一步开发入口：SSH 密钥下发与连接体验优化。

## 影响范围
- 涉及模块：仅文档（`plan/`）
- 涉及代码：无
- 风险等级：L1（可回滚）

## 不做什么（边界）
- 本次不修改运行中服务配置，不触发容器重启。
- 本次不直接改 Bot 代码逻辑（只完成纪要与开发入口整理）。
- 本次不记录明文敏感信息（密码、token、私钥）。

## 验证
- 文档路径存在且可读。
- 纪要内容包含“现象 -> 证据 -> 结论 -> 动作 -> 当前状态”完整链路。

## 回滚
- 回滚触发条件：纪要内容与事实不一致或误导后续执行。
- 回滚步骤：删除本任务目录或修订对应段落并补充修订记录。
</file>

<file path="plan/2026-02-19_管理面密钥化与非Docker迁移/规格变更/OpenClaw面板.md">
# OpenClaw面板 - 变更

## 新增需求

### 需求：管理面 SSH 密钥化基线

管理面 SSH 必须默认仅支持密钥登录，禁止密码登录。

#### 场景：小鸡首启安全基线
- 当 新小鸡完成首启初始化
- 那么 系统必须确保 SSH 仅密钥登录且密码登录被拒绝

#### 场景：密钥接入
- 当 用户拿到 Bot 下发的 SSH 私钥文件
- 那么 用户必须可直接使用密钥命令登录，不需要额外改服务器认证方式

#### 场景：业务端口保护边界
- 当 系统收紧管理面 SSH 策略
- 那么 不得影响客户业务端口池（约 50 端口）的对外使用

---

### 需求：管理 Web 双 Token 鉴权

管理 Web 页面必须通过双 Token 鉴权（`panel_token`、`gateway_token`），不再依赖网页账号密码交互流程。

#### 场景：连接流程简化
- 当 用户通过 SSH 隧道访问面板或 Gateway 页面
- 那么 用户应通过携带 token 的链接直接进入，不需要再手工粘贴 token 或输入网页账号密码

#### 场景：交付输出最小化
- 当 Bot 发送 `VM_READY`
- 那么 仅允许输出 SSH 连接脚本与本地隧道访问地址（`127.0.0.1`），不得输出管理 Web 公网地址或公网端口字段

#### 场景：双 Token 分离
- 当 系统初始化管理面鉴权
- 那么 控制台必须使用 `panel_token`，OpenClaw UI 必须使用 `gateway_token`，两者不得共用同一 token

#### 场景：硬门禁
- 当 用户访问“可视化龙虾配置页面”且请求未携带 `panel_token` 或携带错误 `panel_token`
- 那么 控制台服务端必须直接返回 `401/403`，不得进入空白页面等待手工补 token

#### 场景：OpenClaw 自带 UI 交互保留
- 当 用户访问 OpenClaw 自带 UI
- 那么 保持其原生 token 输入/连接交互，不强改为控制台同款 `401/403` 直拒绝流程

#### 场景：鉴权一致性
- 当 用户访问 OpenClaw 自带 UI 与可视化控制台
- 那么 两者必须采用 token 鉴权体系，但允许交互方式不同（控制台硬门禁、OpenClaw UI 原生交互）

---

### 需求：每台小鸡独立双 Token

每台新建小鸡必须生成两枚独立 token（`panel_token`、`gateway_token`），不得继承模板机 token。

#### 场景：首启 token 生成
- 当 小鸡从模板克隆并启动
- 那么 系统必须生成该小鸡独立 `panel_token` 与 `gateway_token` 并写入运行配置

#### 场景：交付回传
- 当 Bot 发送 `VM_READY`
- 那么 Bot 必须明文回传该小鸡 `panel_token` 与 `gateway_token`

#### 场景：URL 直接可用
- 当 Bot 输出 `VM_READY`
- 那么 输出的 `local_panel_url` 必须预拼接 `panel_token`，`local_gateway_url` 必须预拼接 `gateway_token`，用户复制后可直接访问

#### 场景：唯一性校验
- 当 连续创建两台小鸡
- 那么 两台小鸡的 `panel_token` 与 `gateway_token` 均必须不同

---

### 需求：模板版本门禁

模板必须具备版本标识，新小鸡克隆后必须执行版本一致性校验。

#### 场景：模板更新
- 当 运维更新模板内容
- 那么 必须同步更新模板版本标识文件

#### 场景：克隆后校验
- 当 新小鸡完成首启
- 那么 系统必须校验其模板版本与预期一致，不一致即阻断成功交付

---

### 需求：客户小鸡迁移可回滚

从 Docker 版迁移到直装版时，必须先备份、后迁移、可回滚。

#### 场景：迁移前备份
- 当 对任意客户小鸡执行迁移
- 那么 必须先完成全量备份与校验（manifest + hash）

#### 场景：迁移失败回滚
- 当 迁移后关键能力异常（Gateway、Telegram、配置写入不可用）
- 那么 系统必须按预案回滚到迁移前状态

#### 场景：迁移后验收
- 当 迁移完成
- 那么 必须验证配置、渠道、日志、会话与关键业务能力可用

---

### 需求：控制台内置迁移动作

控制台必须提供“无需 SSH 手工敲命令”的迁移与维护入口。

#### 场景：可视化迁移
- 当 运维在控制台发起迁移
- 那么 系统必须在页面中展示步骤、进度、结果与回滚选项

#### 场景：路径适配
- 当 控制台运行在非 Docker 直装模式
- 那么 所有后台读写路径与服务控制逻辑必须适配宿主机环境

---

### 需求：更新功能对齐官方直装更新机制

控制台“版本更新”能力必须从 Docker 镜像更新链路迁移为 OpenClaw 官方直装更新链路。

#### 场景：安装方式识别
- 当 用户在更新页面执行“检查更新”
- 那么 系统必须先识别当前安装方式（`global` 或 `source`），并给出对应更新策略

#### 场景：global 安装更新
- 当 安装方式为 `global`（npm/pnpm）
- 那么 系统必须走包管理器更新（`npm i -g openclaw@latest` 或 `pnpm add -g openclaw@latest`），并在更新后执行 `openclaw doctor`、`openclaw gateway restart`、`openclaw health`

#### 场景：source 安装更新
- 当 安装方式为 `source`（git checkout）
- 那么 系统应优先执行 `openclaw update`（或同等安全流程），并在工作区不干净时阻断更新并提示用户先清理

#### 场景：回滚策略
- 当 更新后出现问题
- 那么 系统必须支持按安装方式执行回滚：`global` 回滚到指定版本；`source` 按 commit/date pin 回滚

#### 场景：弃用镜像更新入口
- 当 运行环境已完成去 Docker 化
- 那么 更新页面不得再展示“拉取镜像/应用容器更新/镜像回滚”等 Docker 专属操作

## 修改需求

### 需求：服务生命周期控制

原文：

> 面板必须支持对 OpenClaw 运行实例执行启动、停止、重启、状态查询，且兼容 `systemd` 与 `docker` 两种运行时。  
>  
> #### 场景：可视化启停  
> - 当 用户点击服务控制按钮  
> - 那么 系统必须返回明确的成功或失败结果及错误原因  
>  
> #### 场景：运行时切换  
> - 当 目标环境采用 Docker 部署  
> - 那么 系统必须通过容器名执行状态查询与启停控制，而不是依赖 systemd

修改后：

> 面板必须支持对 OpenClaw 运行实例执行启动、停止、重启、状态查询，以“非 Docker 直装运行时”为主路径，Docker 仅作为迁移过渡兼容路径。  
>  
> #### 场景：可视化启停  
> - 当 用户点击服务控制按钮  
> - 那么 系统必须返回明确的成功或失败结果及错误原因  
>  
> #### 场景：运行时主路径  
> - 当 目标环境已完成迁移  
> - 那么 系统必须通过宿主机服务控制（systemd/本地进程）执行状态查询与启停  
>  
> #### 场景：迁移期兼容  
> - 当 目标环境仍处于 Docker 迁移期  
> - 那么 系统应保持兼容控制能力，并在迁移完成后回收 Docker 兼容分支

## 配置契约变更（最小表）
| 字段 | 类型 | 必需 | 约束 | 兼容性说明 | 备注 |
|------|------|------|------|-----------|------|
| `gateway.auth.mode` | string | 是 | 固定 `token` | 账号密码登录流程废弃 | 管理 Web 鉴权模式 |
| `gateway.auth.token` | string | 是 | 每机唯一、高熵随机（`gateway_token`） | 模板共享 token 不再允许 | OpenClaw UI 鉴权 |
| `panel.auth.token` | string | 是 | 每机唯一、高熵随机（`panel_token`） | 新增 | 控制台鉴权 |
| `template.version` | string | 是 | 与模板版本文件一致 | 新增门禁校验 | 不一致阻断交付 |
| `vm_ready.ssh_connect_command` | string | 是 | 仅密钥登录命令 | 新增输出字段 | 用户连接入口 |
| `vm_ready.panel_token` | string | 是 | 明文回传 | 新增输出字段 | 控制台 token |
| `vm_ready.gateway_token` | string | 是 | 明文回传 | 新增输出字段 | OpenClaw UI token |
| `vm_ready.local_panel_url` | string | 是 | `127.0.0.1` 本地映射地址，需携带 `panel_token` | 新增/重构 | 控制台本地访问 |
| `vm_ready.local_gateway_url` | string | 是 | `127.0.0.1` 本地映射地址，需携带 `gateway_token` | 新增/重构 | OpenClaw UI 本地访问 |
| `vm_ready.panel_public_url` | string | 否 | 不允许输出 | 废弃 | 管理面公网地址移除 |
| `vm_ready.gateway_public_url` | string | 否 | 不允许输出 | 废弃 | 管理面公网地址移除 |
| `update.install_method` | string | 是 | `global` / `source` | 新增 | 更新策略选择依据 |
| `update.strategy` | string | 是 | `package-manager` / `openclaw-update` | 新增 | 前后端统一语义 |
| `update.docker_mode` | boolean | 是 | 固定 `false`（迁移完成后） | 旧字段降级 | 禁止再走镜像更新 |
</file>

<file path="plan/2026-02-19_管理面密钥化与非Docker迁移/技术设计.md">
# 技术设计

## 背景与约束
- 背景事实
  - 母机曾出现 `e1000e ... Detected Hardware Unit Hang`，触发时段伴随大量公网 SSH 扫描与爆破流量。
  - 当前小鸡交付链路里存在“模板共享 token”“模板更新后克隆旧状态”“Docker 运行路径权限不一致”等问题。
  - 用户已明确目标：保留业务端口能力，收紧管理面安全，简化连接体验，推进非 Docker 直装。
- 硬约束
  - 每台小鸡业务端口池（约 50 端口）必须保留。
  - SSH 改为仅密钥登录，禁用密码登录。
  - Web 鉴权统一为 Gateway Token，不再使用网页账号密码流程。
  - 新小鸡必须生成两枚独立 token（`panel_token`、`gateway_token`），并在 `VM_READY` 明文回传。
  - `VM_READY` 仅允许输出 SSH 连接脚本与本地隧道地址，不允许输出管理 Web 的公网地址字段。
  - 端口分配逻辑保持不变：`SSH=port_start`、`管理面板=port_start+1`、`Bot UI=port_start+2`，每台新机按 50 端口块后移。
  - 模板必须有版本标识，克隆后校验不通过即阻断交付。
  - 迁移任务必须“先备份、可校验、可回滚”。

## 目标
1. 把管理面安全模型从“多入口+弱一致”改为“密钥 + Token + 门禁 + 限速”。
2. 把小鸡交付从“模板猜测生效”改为“版本可验证交付”。
3. 把 OpenClaw 与控制台运行模型从 Docker 主路径迁移到直装主路径，同时保留迁移期可回滚。
4. 保持用户侧体验：无需 SSH 手工配置即可完成常见操作。

## 不做（Non-Goals）
- 不关闭客户业务端口池。
- 不强制所有用户改为命令行/TUI 运维。
- 不在本阶段重写 OpenClaw 核心业务逻辑。
- 不承诺一次迁移覆盖全部存量客户机，先走“101 演练 -> 小范围灰度 -> 批量迁移”。

## 复杂任务自我反思（5 问）
1. 核心能力是什么：安全收敛 + 可验证交付 + 非 Docker 迁移。
2. 最低安全基线是什么：SSH 密钥化、token 唯一化、管理面限速、可回滚。
3. 不可接受的破坏是什么：业务端口误伤、数据丢失、无法回滚。
4. 主要风险和替代方案是什么：
   - 风险：迁移后权限/路径错配导致功能失效。
   - 替代：先保留 Docker 双轨，逐台迁移验证后再收敛。
5. 关键假设如何验证：
   - 假设：模板版本门禁能阻断旧状态交付。
   - 验证：模拟旧快照克隆，必须命中阻断。

## 技术决策
| 决策点 | 选择 | 原因 | 放弃方案 |
|--------|------|------|----------|
| 管理面访问模型 | SSH 隧道 + Gateway Token | 兼顾安全和可用性，减少公网直接暴露 | 继续公网账号密码直连 |
| SSH 认证 | 仅密钥登录，禁密码 | 直接切断撞库入口，降低扫描成本收益比 | 密码+密钥并存 |
| Web 鉴权 | 统一 Gateway Token | 避免双鉴权模型漂移，减少人工输入 | 保留账号密码表单 |
| Token 生成 | 每台小鸡独立生成 | 避免模板共享 token 横向风险 | 模板固定 token |
| 模板治理 | 版本文件 + 克隆后门禁 | 避免“更新未生效”黑箱 | 继续人工口头确认 |
| 迁移路径 | 先 101 演练，再灰度 | 降低不可逆风险 | 直接全量切换 |
| 控制台运行方式 | 非 Docker 直装主路径 | 符合“少容器权限摩擦”目标 | 继续 Docker 主路径 |

## 架构与流程改造

### 一、管理面与业务面分层
- 管理面（收紧）
  - 母机 SSH / PVE 管理接口 / 小鸡管理 SSH / 小鸡管理 Web（OpenClaw UI、控制台）
  - 策略：密钥登录、限速、封禁、仅隧道访问（不提供公网直连入口）
- 业务面（保留）
  - 客户自定义服务端口池（约 50 端口）
  - 策略：按需开放，不受管理面限速策略影响

### 二、SSH 密钥化与网络层策略
- SSH 改造要求
  - `PasswordAuthentication no`
  - `PubkeyAuthentication yes`
  - `PermitRootLogin prohibit-password`（允许 root 密钥登录，禁止 root 密码登录）
- 管理面限速建议（仅管理面端口）
  - 每 IP 每分钟新建连接上限，超出丢弃（已确认采用）
  - 白名单机制 + 一键解封命令
- 关键原则
  - 扫描流量不会消失，但应尽早在网络层拒绝，减少应用层与驱动层压力。

### 二点五、存量小鸡切换影响与门禁
- 对已开小鸡的实际影响
  - 改造后，密码登录会失效；只有已写入公钥的客户端可登录。
  - 管理 Web 不再提供公网直连字段，改为“SSH 隧道 + 本地 URL + token”。
- 强制门禁
  - 对任意存量小鸡，必须先完成“公钥可登录验证”，再执行 `PasswordAuthentication no`。
  - 门禁未通过时禁止执行禁密动作，避免把存量机器锁死。
- 交付要求
  - 每台存量小鸡完成改造后，必须产出一条“可复制连接脚本 + 本地隧道 URL”验收记录。

### 三、Gateway Token 统一鉴权（双 Token）
- 生成时机
  - 小鸡首启初始化阶段（克隆并启动后）
- 生成规则
  - 使用高熵随机（例如 32 字节以上）分别生成 `panel_token` 与 `gateway_token`
- 写入目标
  - OpenClaw UI 对接 `gateway_token`
  - 可视化控制台对接 `panel_token`
  - 两者不得共用同一 token
- 交付输出
  - `VM_READY` 明文回传 `panel_token`、`gateway_token`
  - 两个隧道 URL 直接携带对应 token（按当前 OpenClaw 版本支持的参数格式）
  - 仅返回本地访问地址（`127.0.0.1` 映射），不返回管理 Web 公网地址
  - 可视化控制台：未携带 `panel_token` 或 token 错误时，服务端直接 `401/403` 拒绝（不进入空壳页面）
  - OpenClaw 自带 UI：保持原生 token 输入/连接交互，不强改为控制台同款拦截流程
- 回归场景
  - `token missing`
  - `token mismatch`
  - `missing scope: operator.read`

#### `VM_READY` 输出示例（草案）
```text
[VM_READY] vm-xxxx(101)
ssh_connect_command: ssh -i ~/.ssh/<key> root@<host> -p <port_start>
panel_token: <panel_token>
gateway_token: <gateway_token>
local_panel_url: http://127.0.0.1:<local_panel_port>/?token=<panel_token>
local_gateway_url: http://127.0.0.1:<local_gateway_port>/?token=<gateway_token>
template_version: <template.version>
```
说明：
- 不得出现 `panel_public_url` / `gateway_public_url`。
- 控制台与 OpenClaw UI 的 token 必须分离，禁止复用。

### 四、模板版本治理（防旧版本克隆）
- 模板侧
  - 固定版本标识文件：`/etc/openclaw-template-version`
  - 每次模板更新必须递增版本并记录发布说明
- 编排侧
  - 克隆后通过 guest agent 读取版本标识
  - 与预期版本不一致则阻断交付，不发送成功态 `VM_READY`
- 交付侧
  - `VM_READY` 附带模板版本信息，便于追溯

### 五、客户小鸡迁移（Docker -> 直装）
- 迁移对象
  - 先在自用测试小鸡 vmid=101 演练
  - 验证通过后再迁移客户小鸡
- 备份范围（必须）
  - OpenClaw 配置、渠道配置、模型配置、token、identity、credentials、sessions、logs、用户附加文件
- 迁移步骤（高层）
  1. 备份与校验（tar + hash + manifest）
  2. 停止 Docker 服务并冻结写入
  3. 安装直装版 OpenClaw（systemd 或等价服务）
  4. 恢复配置与数据，修正路径与权限
  5. 启动服务并做链路验证
  6. 保留回滚包与回滚脚本
- 回滚原则
  - 任一关键链路失败（Gateway、Telegram、控制台、配置写入）立即回滚。

### 六、控制台（本仓库）非 Docker 改造
- 部署层改造
  - 将控制台运行从 Docker 主路径改为宿主机直装主路径。
- 后端路径改造
  - 原有容器路径读写改为宿主机路径读写。
  - 保留兼容适配层，仅作为迁移期过渡。
- 服务控制改造
  - 原 `docker` 控制指令改为 `systemd/本地进程` 控制。
- 更新逻辑改造
  - 旧逻辑：扫描 Docker 镜像发布（`/api/update/*` + `docker-update.js`）。
  - 新逻辑：对齐官方安装/更新文档，按安装方式分流升级：
    - `global`：包管理器升级（npm/pnpm 全局安装）
    - `source`：`openclaw update` / source pin 流程
  - 迁移完成后移除“拉镜像/应用镜像/镜像回滚”入口与后端路径。
- 交互改造
  - 将“脚本能力”封装到控制台操作，避免用户必须 SSH 手工执行。

### 七、官方安装与更新对齐策略（新增）
- 官方安装入口（直装）
  - `curl -fsSL https://openclaw.ai/install.sh | bash`
  - 可选：`--no-onboard`
- 官方更新基线
  - 更新后必须执行：`openclaw doctor`、`openclaw gateway restart`、`openclaw health`
  - `source` 安装优先用 `openclaw update`
  - `source` 回滚按 commit/date pin；`global` 回滚按版本号安装
- 面板更新页改造要求
  - 页面需先展示安装方式探测结果（`global` / `source`）
  - 仅展示与当前安装方式匹配的操作按钮
  - 不再展示 Docker 专属文案（镜像、容器、compose）

## 配置与输出契约变更（最小表）
| 字段 | 类型 | 必需 | 约束 | 兼容性说明 | 备注 |
|------|------|------|------|-----------|------|
| `openclaw.gateway.auth.mode` | string | 是 | 固定 `token` | 旧账号密码流程废弃 | 管理 Web 鉴权模式 |
| `openclaw.gateway.auth.token` | string | 是 | 高熵随机、每机唯一（`gateway_token`） | 模板固定 token 不再允许 | OpenClaw UI 使用 |
| `panel.auth.token` | string | 是 | 高熵随机、每机唯一（`panel_token`） | 新增 | 可视化控制台使用 |
| `vm_ready.ssh_connect_command` | string | 是 | 仅密钥登录命令 | 新增输出字段 | 用户连接入口 |
| `vm_ready.panel_token` | string | 是 | 明文回传 | 新增字段 | 控制台 token |
| `vm_ready.gateway_token` | string | 是 | 明文回传 | 新增字段 | OpenClaw UI token |
| `vm_ready.local_panel_url` | string | 是 | `127.0.0.1` 本地映射地址，URL 内携带 `panel_token` | 新增/重构 | 控制台本地访问地址 |
| `vm_ready.local_gateway_url` | string | 是 | `127.0.0.1` 本地映射地址，URL 内携带 `gateway_token` | 新增/重构 | OpenClaw UI 本地访问地址 |
| `vm_ready.panel_public_url` | string | 否 | 不允许输出 | 废弃 | 管理面公网地址移除 |
| `vm_ready.gateway_public_url` | string | 否 | 不允许输出 | 废弃 | 管理面公网地址移除 |
| `update.install_method` | string | 是 | `global` / `source` | 新增 | 更新策略分流 |
| `update.strategy` | string | 是 | `package-manager` / `openclaw-update` | 新增 | 前后端操作模式 |
| `update.docker_mode` | boolean | 是 | `false`（迁移完成后） | 旧模式降级 | Docker 更新入口回收 |
| `template.version` | string | 是 | 语义化或日期版本 | 新增门禁字段 | 克隆后校验 |

## 风险与缓解
| 风险 | 缓解措施 |
|------|----------|
| 迁移导致配置丢失 | 先备份 + hash 校验 + manifest + 回滚演练 |
| 迁移导致权限异常 | 固化目录权限模板与启动后自检/自愈 |
| 管理面限速误伤 | 只限管理面端口 + 白名单 + 一键解封 |
| 旧模板继续被克隆 | 强制版本门禁，不匹配直接阻断 |
| 双运行时过渡复杂 | 设置明确回收节点，迁移完成后移除兼容层 |

## 迁移/回滚方案
- 迁移步骤
  1. 在 vmid=101 完成备份、直装迁移、验证。
  2. 固化迁移脚本与校验脚本。
  3. 小范围灰度到 1~2 台客户机。
  4. 批量迁移并逐台验收。
- 回滚步骤
  1. 停止直装服务。
  2. 恢复 Docker 编排与镜像标签。
  3. 从备份恢复数据目录。
  4. 启动 Docker 服务并回归验证。
- 验证方式
  - 功能验证：UI、Telegram、Gateway、日志、更新、配置写入。
  - 安全验证：SSH 密钥化、token 唯一性、限速命中。
  - 兼容验证：业务端口连通不受影响。

## 验证计划（最小可复现）
1. 安全验证
  - SSH 密码登录失败、密钥登录成功。
  - 管理面限速命中，业务端口不受影响。
2. Token 验证
  - 连续新建两台小鸡，`panel_token` 与 `gateway_token` 均必须不同。
  - `VM_READY` 回传的两个 token 均与配置文件一致。
  - `VM_READY` 不返回 `IP:port` 形式的管理 Web 公网地址。
  - `VM_READY` 返回的两个本地 URL 均可直接访问管理页面（无需手工拼 token）。
  - 可视化控制台未带 `panel_token` 或 token 错误时返回 `401/403`，且不进入空壳页面。
  - OpenClaw 自带 UI 保持原生 token 输入/连接交互，验证其兼容性不回归。
3. 模板验证
  - 模拟旧模板版本，必须被门禁阻断。
4. 迁移验证
  - 101 小鸡迁移前后核心能力等价。
  - 回滚路径实测可用。

## 联网对照依据（官方资料）
- Linux e1000e 文档：<https://www.kernel.org/doc/html/v4.20/networking/e1000e.html>
- e1000e 讨论（TSO 相关）：<https://patchwork.ozlabs.org/project/netdev/patch/1623942.pXzBnfQ100@rocinante.m.i2n/>
- Intel wired-lan 邮件线程：<https://lists.osuosl.org/pipermail/intel-wired-lan/Week-of-Mon-20190513/016087.html>
- OpenClaw Gateway 文档：<https://docs.openclaw.ai/gateway/remote>
- OpenClaw Control UI 文档：<https://docs.openclaw.ai/web/control-ui>
</file>

<file path="plan/2026-02-19_管理面密钥化与非Docker迁移/任务清单.md">
# 任务清单（目标锚定版）

## 0. 背景、想法与真实意图（防偏离锚点）

### 0.1 背景事实
- 已发生公网扫描/爆破流量，管理面暴露导致稳定性与安全风险上升。
- 现有流程里存在“模板更新后新机仍可能继承旧状态”的交付不确定性。
- 用户实际体验存在摩擦：连接链路步骤多、容易在 token/鉴权环节误操作。
- 你已明确：业务端口必须保留，不接受“一刀切封网”。

### 0.2 你的想法（执行方向）
- 管理面安全要收紧（密钥、token、限速），业务面可用性不能被牺牲。
- 鉴权流程要简化，但不能裸奔。
- 模板交付必须可验证，不能靠“我以为更新了”。
- 部署体系要从 Docker 主路径逐步迁移到直装主路径，并可回滚。

### 0.3 最终目标（必须达成）
- G1：每台小鸡保留约 50 个业务端口可用。
- G2：管理面 SSH 仅密钥登录，禁用密码登录。
- G3：管理 Web 统一 Gateway Token 鉴权，减少手工输入。
- G4：每台新小鸡生成两枚独立 Token（`panel_token`、`gateway_token`），`VM_READY` 明文回传并可直接使用。
- G4.1：`VM_READY` 仅输出 SSH 连接脚本与本地隧道访问地址，不输出管理 Web 公网地址字段。
- G5：模板版本可验证，克隆后门禁阻断旧版本交付。
- G6：完成“先备份、后迁移、可回滚”的 Docker -> 直装迁移路径。
- G7：可视化控制台适配直装路径，用户尽量不需要手敲 SSH/TUI。

## 1. 不允许偏离的硬约束
- [x] C1 保留业务端口池（约 50 端口），不做全封公网。
- [x] C2 限速/封禁仅针对管理面端口，不误伤业务端口。
- [x] C3 迁移前必须完整备份并可校验，未备份不得删旧运行时。
- [x] C4 鉴权简化不等于取消鉴权，必须保留 token 安全边界。
- [x] C5 版本不一致必须阻断成功交付，不允许“带病上线”。
- [x] C6 保持端口分配规律不变（`SSH=port_start`、`+1/+2` 为管理 Web）；仅移除管理 Web 公网输出，不改 50 端口块策略。

## 2. 任务与目标对齐矩阵（防“只做任务不达目标”）

| 任务组 | 对齐目标 | 通过标准 |
|---|---|---|
| 管理面 SSH 改造 | G2, G1 | 密码登录失败、密钥登录成功；业务端口抽测通过 |
| 管理面限速与封禁 | G1, G2 | 管理端口命中限速；业务端口无误伤 |
| Token 唯一化与回传 | G3, G4 | 连续两台小鸡两枚 token 均不同；`VM_READY` 两枚 token 与运行态一致 |
| VM_READY 输出收敛 | G4.1 | 只含 SSH/本地隧道地址；不含管理 Web 公网地址字段 |
| 模板版本门禁 | G5 | 旧版本克隆被阻断；成功机版本可追溯 |
| 101 迁移演练 | G6 | 迁移后核心功能可用；回滚可执行 |
| 控制台直装改造 | G7, G6 | 无 Docker 仍可运维；更新链路可用 |

## 3. 实施顺序清单（按你确认的优先级）

## 3.0 优先主线（先后顺序固定）
1. 先做去 Docker 化（先在 101 小鸡，且直接在虚拟机环境部署，不做本地假演练）。
2. 101 验证通过后，把迁移流程固化成标准流程。
3. 按固化流程批量重复到已开小鸡用户。

## 3.1 阶段 A：去 Docker 化优先（101 先行，强制门禁）
- [x] A1 锁定 101 作为唯一试点，并确认“直装部署”为目标运行态（非本地部署）  
  验收：试点范围与窗口落盘并确认  
  对齐：G6, G7
- [x] A2 全量备份与校验（配置、凭据、会话、日志、用户附加数据）  
  验收：备份包 + hash + manifest 完整  
  对齐：G6
- [ ] A3 停止并清理 Docker 版（仅备份成功后）  
  验收：旧服务可控下线，未发生数据损失  
  对齐：G6
- [x] A4 安装直装版并恢复数据  
  验收：核心链路可用（Gateway/Telegram/配置读写）  
  对齐：G6
- [ ] A5 回滚演练（恢复 Docker 版）  
  验收：回滚步骤可重复执行  
  对齐：G6

## 3.2 阶段 B：101 通过后流程固化（形成可复制标准）
- [x] B1 固化迁移 SOP（前置检查、执行步骤、验收步骤、回滚步骤）  
  验收：SOP 文档可直接用于第二台小鸡  
  对齐：G6
- [x] B2 固化控制台侧直装运维能力（路径、服务控制、更新逻辑）  
  验收：无 Docker 条件下可运行，启停/状态/更新可用  
  对齐：G7, G6
- [ ] B3 固化输出契约（`VM_READY` 仅输出 SSH + 两个本地隧道 URL，且 URL 已预拼接各自 token）  
  验收：不再出现管理 Web 公网地址字段；用户复制链接可直接访问；控制台无 token 返回 `401/403`，OpenClaw UI 交互保持原生  
  对齐：G3, G4, G4.1
- [ ] B4 固化安全与一致性门禁（SSH 密钥化、token 唯一化、模板版本门禁）  
  验收：门禁清单可执行并能阻断不合规交付  
  对齐：G2, G4, G5

## 3.3 阶段 C：批量迁移已开小鸡（按批次复制执行）
- [ ] C1 形成存量小鸡批次计划（批次规模、时间窗、回滚负责人）  
  验收：批次计划可审计  
  对齐：G6
- [ ] C2 按 SOP 逐台迁移（每台先备份再迁移）  
  验收：每台都有备份证据、迁移结果、回滚点  
  对齐：G6
- [ ] C3 每批完成后做联调验证（管理面 + 业务端口）  
  验收：管理面符合隧道+token策略，业务端口不受影响  
  对齐：G1, G2, G3
- [ ] C4 批次问题复盘与规则更新  
  验收：问题模式与防复发规则已追加  
  对齐：G1~G7

## 3.4 阶段 D：平台能力改造与收尾（并行开发，批量前必须完成门禁项）
- [ ] D1 SSH 仅密钥 + 管理面限速封禁落地（不触碰业务端口池）  
  验收：密码登录失败、密钥登录成功；业务端口抽测通过  
  对齐：G1, G2
- [ ] D2 双 Token 体系改造（每机唯一、回传一致、错误场景可回归）  
  验收：连续新建两台小鸡两枚 token 均不同；`VM_READY` 回传 token 与运行态一致  
  对齐：G3, G4
- [ ] D3 模板版本门禁改造（版本文件 + 克隆后校验 + 交付追溯）  
  验收：旧模板可被阻断；`VM_READY` 可见版本信息  
  对齐：G5
- [ ] D4 规格合并与归档  
  验收：`plan/规格/` 更新完成，任务归档  
  对齐：G1~G7

## 4. 经验记录（持续追加）
### 4.1 当前阶段结论
- 已确认“简单任务罗列”容易偏离真实意图，本清单改为“目标锚定 + 步骤对齐 + 验收证据”结构。
- 已明确本任务的核心不是“仅修一个报错”，而是“安全、交付一致性、迁移可回滚”的系统改造。
- 已完成 101 去 Docker 化首轮闭环（备份、直装、数据迁移、联调）与控制台直装改造。
- A3 当前为“停旧 Docker 运行态但未做最终清理”，保留快速回滚能力；待回滚演练与门禁通过后再清理。

### 4.2 继续执行纪律
- 每完成一个步骤，必须追加：实际结果、偏差、风险、回滚点。
- 如发现与目标冲突，必须先停步并回到“0.3 最终目标”重新对齐。
</file>

<file path="plan/2026-02-19_管理面密钥化与非Docker迁移/提案.md">
# 管理面密钥化与非 Docker 迁移

创建时间：2026-02-19 18:40:00

## 为什么做
- 2026-02-19 已发生母机公网 SSH 持续扫描与爆破流量，母机出现 `e1000e ... Detected Hardware Unit Hang`，最终 SSH 全断并人工重启恢复。该问题暴露出“管理面暴露过宽 + 密码面攻击面过大”的结构风险。
- 当前交付链路存在两类长期风险：
  - 安全风险：SSH 密码登录与模板共享 Gateway Token，导致撞库面和横向风险过高。
  - 交付风险：模板更新后，新克隆小鸡仍可能拿到旧状态（快照/克隆源不一致），导致“已更新但未生效”。
- 当前用户操作链路存在明显摩擦：SSH 隧道建立后仍需手工输入 Web 账号密码，且经常出现 token 粘贴错误。
- 业务目标已明确：保留客户业务端口开放能力，但把管理面安全收敛为“密钥 + Token + 版本门禁 + 可回滚迁移”。
- 今晚需推进重大策略变更：OpenClaw Bot 与控制台逐步从 Docker 运行转为服务器直装运行（含客户数据完整迁移）。

## 改什么
- 管理面安全基线收敛
  - SSH：仅密钥登录，禁用密码登录。
  - 限速：仅对管理面端口做连接限速与封禁策略，不影响客户业务端口。
  - 鉴权：管理 Web 统一使用 Gateway Token，不再走“网页账号密码”交互。
- Gateway Token 体系重构
  - 每台新小鸡开机后生成两枚独立 token（`panel_token`、`gateway_token`）。
  - Bot 在 `VM_READY` 中明文回传这两枚 token。
  - Bot 输出两个本地隧道 URL，并分别预拼接对应 token，减少手工粘贴与 `token missing` 误操作。
  - `VM_READY` 仅输出 SSH 连接脚本与隧道后的本地访问地址（`127.0.0.1`），不再暴露管理 Web 的公网地址与公网端口字段。
- 模板版本治理
  - 模板更新必须写入版本标识文件。
  - 克隆后强制版本校验，不匹配时阻断交付并报错。
- 客户小鸡迁移任务（Docker -> 直装）
  - 先在自用测试小鸡（vmid=101）做全量迁移演练。
  - 完整备份用户数据（配置、凭据、会话、日志、插件/扩展数据等）。
  - 清理 Docker 版 OpenClaw 后，安装新版直装运行，并恢复数据。
  - 提供一键回滚到 Docker 版的操作预案。
- 可视化控制台改造
  - 控制台改为服务器直装运行，不再依赖 Docker 运行态。
  - 将现有“Docker 交互路径/命令”改为“宿主机路径/服务控制”。
  - 将“镜像仓库升级逻辑”改为“官方代码/发包升级逻辑”。
  - 保持用户侧“无需 SSH 手工操作”的原则，把必要脚本能力内置到控制台操作流程中。
- 存量小鸡切换策略
  - 先补齐密钥再关闭 SSH 密码；未补齐密钥的小鸡不得直接执行禁密。
  - 对存量用户同步“新连接方式”说明：仅提供 SSH 脚本 + 本地隧道 URL（携带 token）。

## 破坏性变更（必须明确）
- SSH 密码登录将被禁用：历史只会密码登录的路径会失效，需统一改用密钥。
- 运行时从 Docker 向直装迁移：服务控制命令、日志路径、升级入口会变化。
- Web 鉴权从账号密码转为 Gateway Token：旧登录入口文案和流程将调整。

## 影响范围
- 仓库与模块：
  - `E:/AAA__ZhuoMian/大盘鸡/pve-vm-bot`：小鸡创建编排、`VM_READY` 输出、模板版本门禁、迁移编排、运维命令。
  - `E:/AAA__ZhuoMian/龙虾傻瓜化`：可视化控制台部署方式、服务控制适配层、更新逻辑、迁移向导页面。
  - 线上模板与小鸡运行环境：`sshd`、Gateway 配置、系统服务、数据目录权限。
- 风险等级：L2（跨模块 + 运行时迁移 + 安全策略变更）

## 不做什么（边界）
- 不关闭客户业务端口池（每台小鸡约 50 个业务端口继续保留）。
- 不修改现有端口分配规律：`SSH=port_start`、`面板=port_start+1`、`Bot UI=port_start+2`；每台新机按 50 端口块后移。
- 不把所有运维动作强制回退为“用户手工 SSH + TUI”；控制台仍是默认主入口。
- 不在未完成备份校验前直接删除客户生产数据。
- 不以“先上线再补文档”的方式推进，必须先文档化再执行迁移。

## 验证（存在风险时必填）
- 安全基线验证
  - SSH 密码登录失败，密钥登录成功。
  - 管理面限速生效且不影响业务端口连通。
- Token 验证
  - 新小鸡两枚 token 均与模板 token 不同（唯一性）。
  - `VM_READY` 回传 `panel_token`、`gateway_token` 与小鸡配置文件一致。
  - `VM_READY` 不包含管理 Web 公网地址字段，且仅返回本地隧道地址。
  - 直接使用 Bot 回传本地隧道 URL 可进入页面；公网 `IP:port` 管理地址不可直连。
  - 可视化控制台未携带 `panel_token` 或 token 错误时，页面必须直接 `401/403` 拒绝，不得进入“空壳页面”。
  - OpenClaw 自带 UI 保持原生 token 输入交互，不强改其页面流程。
- 模板版本验证
  - 新小鸡版本标识必须等于模板预期版本，不一致时阻断。
- 迁移验证
  - 迁移前后配置、渠道、技能、历史会话、用户数据可用。
  - 回滚演练至少完成一次。

## 回滚（存在风险时必填）
- 回滚触发条件
  - 迁移后核心流程不可用（Gateway 不通、Telegram 失联、关键配置丢失）。
  - 发现影响客户业务端口可用性。
- 回滚步骤
  - 使用迁移前完整备份恢复配置与数据目录。
  - 恢复 Docker 版编排与镜像，回退服务控制入口。
  - 恢复旧鉴权路径（仅应急，回滚后需重新整改）。
- 回滚证据
  - 回滚前后版本、配置哈希、关键接口可用性对比记录。

## 联网对照依据（官方资料）
- Linux e1000e 驱动文档：<https://www.kernel.org/doc/html/v4.20/networking/e1000e.html>
- e1000e 与 TSO 相关上游讨论：<https://patchwork.ozlabs.org/project/netdev/patch/1623942.pXzBnfQ100@rocinante.m.i2n/>
- Intel wired-lan 邮件列表讨论：<https://lists.osuosl.org/pipermail/intel-wired-lan/Week-of-Mon-20190513/016087.html>
- OpenClaw Gateway 远程与 Control UI 文档：<https://docs.openclaw.ai/gateway/remote> 、<https://docs.openclaw.ai/web/control-ui>
</file>

<file path="plan/2026-02-24_网关配对自愈与重启按钮/规格变更/OpenClaw面板.md">
# OpenClaw面板 - 变更

## 新增需求

### 需求：网关配对自愈操作

面板必须支持读取并批准 Gateway 的 pending 设备配对请求，帮助用户在 `pairing required` 场景下无需命令行即可恢复连接。

#### 场景：一键批准待处理配对
- **当** 用户在仪表盘点击“批准待处理配对”
- **那么** 系统必须读取 pending 请求并依次执行批准，返回批准数量与失败详情

#### 场景：无 pending 的空操作
- **当** 当前没有待批准配对请求
- **那么** 系统必须返回“无需处理”的成功结果，不报错

### 需求：仪表盘网关快速重启动作

面板必须在仪表盘提供“重启网关服务”入口，调用既有服务控制链路并反馈执行结果。

#### 场景：一键重启网关
- **当** 用户在仪表盘点击“重启网关服务”
- **那么** 系统必须触发网关重启并反馈成功或失败原因
</file>

<file path="plan/2026-02-24_网关配对自愈与重启按钮/任务清单.md">
# 任务清单

## 1. 准备阶段
- [x] 1.1 阅读现有规格 `plan/规格/OpenClaw面板.md`
- [x] 1.2 确认 `plan/` 目录下没有冲突的进行中任务

## 2. 实现阶段
- [x] 2.1 线上采证并止血（101 pending 设备配对审批） | 验收：`openclaw devices list` 从 Pending 变为 Paired
- [x] 2.2 新增后端配对自愈能力（读取 pending + 批准） | 验收：接口返回 approvedCount，失败时返回可读错误
- [x] 2.3 仪表盘新增“批准待处理配对”按钮并接入新接口 | 验收：前端可触发并展示审批结果
- [x] 2.4 仪表盘新增“重启网关服务”按钮并接入现有重启链路 | 验收：前端可触发并展示重启结果

## 3. 验证阶段
- [x] 3.1 单元测试通过（覆盖配对审批成功/失败/空 pending）
- [x] 3.2 集成测试通过（接口到页面动作链路可执行）
- [x] 3.3 场景验收通过（对照规格变更场景）

## 4. 收尾阶段
- [x] 4.1 更新规格文档（合并变更到 `plan/规格/`）
- [ ] 4.2 归档本次任务（移动到 `plan/归档/`）

## 经验记录

### 步骤 2.1 完成记录
- 实际情况：服务未挂，核心故障是设备处于 pending 未批准。
- 遇到问题：用户误以为“重生 token 就能恢复”，实际要先审批配对请求。
- 技术债：面板缺“pending 配对审批”入口，导致同类问题会重复人工登录处理。

### 步骤 2.2 完成记录
- 实际情况：后端通过 `openclaw devices list --json` + `openclaw devices approve <requestId>` 已形成可复用闭环。
- 遇到问题：`devices list` 需解析 JSON，且要兼容 docker CLI 回退场景。
- 技术债：目前审批为串行执行，若后续 pending 很多可评估批处理与并发上限。

### 步骤 2.3 完成记录
- 实际情况：仪表盘已新增“批准待处理配对”按钮，并展示 pending/approved/failed 结果。
- 遇到问题：原页面只存在 Token 状态提示，需新增独立网关运维状态提示避免信息冲突。
- 技术债：当前仅在仪表盘提供入口，后续可在“服务控制”页增加同能力。

### 步骤 2.4 完成记录
- 实际情况：仪表盘已新增“重启网关服务”按钮，复用 `/api/service/restart` 现有链路。
- 遇到问题：`openclaw gateway restart` 在 root 执行会遇到 user scope bus 限制，因此不走该命令。
- 技术债：可后续补充“重启后自动健康检查”联动，减少用户二次点击验证。

### 步骤 3.1 完成记录
- 实际情况：新增 `approvePendingGatewayPairings` 的三条单测（成功/空 pending/部分失败），全部通过。
- 遇到问题：需要兼容 docker CLI 回退时的输出结构，因此在 CLI 结果中补了 `stdout/stderr/message` 字段。
- 技术债：后续可补“pending 缺 requestId”的专门异常单测。

### 步骤 3.2 完成记录
- 实际情况：执行 `npm run test`（unit + regression）全绿，跨模块链路未回归。
- 遇到问题：无。
- 技术债：无新增高优先级项。

### 步骤 3.3 完成记录
- 实际情况：按 BDD 场景核对通过：有 pending 可审批、无 pending 空操作、网关重启可触发并回显结果。
- 实际情况补充：本地启动面板后，通过浏览器快照确认仪表盘出现“批准待处理配对/重启网关服务”按钮，并验证失败态提示可见。
- 遇到问题：现场故障与旧案例相似但根因不同，已新增 101 案例并更新总目录。
- 技术债：可在后续加入“审批后自动刷新配对列表与健康状态”的组合动作。

### 步骤 4.1 完成记录
- 实际情况：已将规格变更合并到 `plan/规格/OpenClaw面板.md` 主文档。
- 遇到问题：无。
- 技术债：4.2 归档尚未执行，待你确认本次交付无追加修改后再归档。
</file>

<file path="plan/2026-02-24_网关配对自愈与重启按钮/提案.md">
# 网关配对自愈与重启按钮

创建时间：2026-02-24 20:53:57

## 为什么做

客户小鸡升级 OpenClaw 后出现 `pairing required`，当前面板只有“自动写 Token”，缺少“配对审批”和“网关重启”闭环动作，导致用户必须进命令行人工处理。

## 改什么

- 在后端新增“读取并批准 pending 配对请求”的能力，优先走最小修复路径。
- 在仪表盘新增“批准待处理配对”按钮，直接恢复 Web 控制端连接。
- 在仪表盘新增“重启网关服务”按钮，复用现有服务控制链路。
- 补充对应单元测试与回归验证。

## 影响范围

- 涉及模块：`src/server.js`、`src/channel-onboarding.js`、`public/pages/dashboard.html`、`public/js/pages/model-dashboard-page.js`、`public/styles.css`、`test/unit/channel-onboarding.test.js`
- 涉及接口：新增 `/api/gateway/pairing/approve-pending`
- 风险等级：L1

## 不做什么（边界）

- 本次不改 OpenClaw 上游配对机制，不绕过配对安全策略。
- 本次不做自动“清空已配对设备”或“强制重新签发 token”的高风险操作。
- 不做跨页面大改，只在仪表盘补最小可用操作入口。
</file>

<file path="plan/归档/2026-02-14_OpenClaw面板MVP/规格变更/OpenClaw面板.md">
# OpenClaw面板 - 变更

## 新增需求
### 需求：面板运行时可配置
#### 场景：监听与路径配置
- 当 面板在不同模板机运行
- 那么 系统必须支持 `panel.listen_host`、`panel.listen_port`、`openclaw.config_path`、`openclaw.service_name` 的可配置化

### 需求：日志来源可切换
#### 场景：journal/file 双模式
- 当 用户选择日志来源
- 那么 系统必须支持 `journalctl` 与文件日志两种读取方式

## 修改需求
### 需求：可视化配置中心
面板除字段化编辑外，新增最低校验基线：必填、URL 格式、模型名非空。

## 移除需求
### 需求：无
移除原因：本次无需求移除。
迁移方案：不适用。
</file>

<file path="plan/归档/2026-02-14_OpenClaw面板MVP/技术设计.md">
# 技术设计

## 背景与约束
- 目标环境：Debian 13（Trixie），典型规格 2C2G。
- 部署形式：非 Docker，预装在模板小鸡中。
- 安全基线：面板默认监听 `127.0.0.1`，公网入口由反代统一控制。
- 兼容要求：OpenClaw 配置路径、服务名、日志来源必须可配置，不能硬编码。

## 目标
- 构建单机可用的 OpenClaw 可视化面板 MVP。
- 让用户无需命令行即可完成配置、启停、排障、渠道测试。

## 不做（Non-Goals）
- 不做多租户 SaaS 总控
- 不做自动售卖开机链路集成
- 不做 OpenClaw 核心协议改造

## 技术决策
| 决策点 | 选择 | 原因 | 放弃方案 |
|--------|------|------|----------|
| 后端栈 | Node.js + Fastify | 与 OpenClaw 同运行时，降低模板依赖复杂度 | Go（额外构建链路） |
| 前端栈 | 原生 HTML/CSS/JS | 体积小、启动快、内存低 | React/Vue（额外构建与运行负担） |
| 服务控制 | 调用 `systemctl` | Debian 13 标准做法，集成成本低 | 自建守护进程 |
| 日志读取 | `journalctl` + 文件 tail 兜底 | 兼容 systemd 与文件日志两类场景 | 仅文件日志 |
| 实时日志 | SSE（Server-Sent Events） | 简单稳定、浏览器原生支持 | WebSocket（复杂度更高） |

## 风险与缓解
| 风险 | 缓解措施 |
|------|----------|
| OpenClaw 配置结构随版本变化 | 仅维护 MVP 关键字段，并保留原始 JSON 读取能力 |
| systemd 权限不足 | 返回清晰错误并在部署文档要求服务用户权限 |
| 日志流资源占用 | 限制默认 tail 行数与刷新频率，连接关闭即释放进程 |
| 敏感信息泄露 | 回显时掩码，落盘文件权限收敛到 600 |

## 迁移/回滚方案
- 迁移步骤：
  - 部署面板代码
  - 生成默认面板配置
  - 配置并启动面板服务
- 回滚步骤：
  - 停止面板服务
  - 恢复 OpenClaw 配置备份
  - 切回命令行运维
- 验证方式：
  - 页面配置写入成功
  - 服务状态可查询
  - 日志流可显示
  - 渠道测试可返回结果
</file>

<file path="plan/归档/2026-02-14_OpenClaw面板MVP/任务清单.md">
# 任务清单

## 1. 准备阶段
- [x] 1.1 阅读现有规格 | 验收：`plan/规格/OpenClaw面板.md` 已存在
- [x] 1.2 确认无冲突进行中任务 | 验收：仓库内无其他进行中任务目录

## 2. 实现阶段
- [x] 2.1 搭建后端服务骨架 | 验收：可启动 HTTP 服务并返回健康检查
- [x] 2.2 实现配置中心 API（读取/保存/校验） | 验收：配置可读写且校验生效
- [x] 2.3 实现 systemd 服务控制 API | 验收：status/start/stop/restart 返回明确结果
- [x] 2.4 实现日志 API（tail/stream/错误摘要） | 验收：可实时查看并过滤日志
- [x] 2.5 实现渠道测试 API（Telegram/飞书） | 验收：测试接口可返回可解释结果
- [x] 2.6 实现前端页面（配置/服务/日志/渠道） | 验收：页面可完成 MVP 交互闭环

## 3. 验证阶段
- [x] 3.1 运行静态检查或基础启动验证 | 验收：服务可正常启动
- [x] 3.2 场景验收通过 | 验收：按提案最小验证步骤通过

## 4. 收尾阶段
- [x] 4.1 合并规格变更到 plan/规格/ | 验收：规格已同步
- [x] 4.2 归档到 plan/归档/ | 验收：任务完成后执行

## 经验记录
### 步骤 1 完成记录
- 实际情况：当前仓库为空目录，需从零搭建
- 遇到问题：无
- 技术债：后续需补自动化部署脚本与反代模板

### 步骤 2/3 完成记录
- 实际情况：已完成 MVP 全链路，含配置、服务控制、日志与渠道测试接口
- 遇到问题：`fastify` 与 `@fastify/static` 版本不匹配导致启动失败，已统一版本修复
- 技术债：Linux 真机需补 systemd 权限与 journal 日志压测验证
</file>

<file path="plan/归档/2026-02-14_OpenClaw面板MVP/提案.md">
# OpenClaw面板MVP

创建时间：2026-02-14 00:00:00

## 为什么做
OpenClaw 的配置与运维高度依赖命令行，普通用户在 2C2G 服务器环境下部署和排障成本过高，难以形成模板化交付闭环。

## 改什么
- 新增单机可用的 Web 管理面板（非 Docker）
- 提供字段化配置能力（API、Base URL、模型、Telegram、飞书）
- 提供 systemd 服务控制（start/stop/restart/status）
- 提供日志实时查看、过滤与错误摘要
- 提供 Telegram/飞书连通性测试接口

## 影响范围
- 涉及模块：面板后端 API、前端页面、配置读写、日志读取、systemd 调用
- 涉及接口：本地 HTTP API（仅面板内部使用）
- 风险等级：L1

## 不做什么（边界）
- 本次不实现多租户总控后台
- 本次不实现模板机 cloud-init 自动初始化流程
- 本次不改 OpenClaw 核心代码与插件生态
- 本次不默认提供公网鉴权系统（由反代层负责）

## 验证（存在风险时必填）
- 最小验证步骤：
  - 启动面板并访问页面
  - 修改配置并落盘
  - 执行 service status/restart 并返回结果
  - 打开日志流并完成关键字过滤
  - Telegram/飞书测试接口返回可理解结果

## 回滚（存在风险时必填）
- 回滚触发条件：面板异常导致配置写入失败或影响 OpenClaw 运行
- 回滚步骤：
  - 恢复备份的 OpenClaw 配置文件
  - 停用面板进程或服务
  - 回退到上一个稳定版本
</file>

<file path="plan/归档/2026-02-15_OpenClaw渠道扩展_DiscordSlack/规格变更/OpenClaw面板.md">
# OpenClaw面板 - 变更

## 修改需求
### 需求：可视化配置中心
在现有 Telegram / 飞书基础上，新增 Discord / Slack 可视化配置能力，并保持字段映射到官方配置结构。

#### 场景：Discord 字段可视化
- 当 用户在页面修改 Discord 开关、Token、DM 策略、群策略等字段
- 那么 系统必须映射写入 `channels.discord.*`，并兼容 `channels.discord.dm.*`

#### 场景：Slack 字段可视化
- 当 用户在页面修改 Slack 模式、Token、Signing Secret、DM 策略等字段
- 那么 系统必须映射写入 `channels.slack.*`，并兼容 `channels.slack.dm.*`

#### 场景：策略校验
- 当 用户将 Discord/Slack 的 DM 策略设置为 `open`
- 那么 系统必须要求 `allowFrom` 包含 `*`，否则拒绝写入
</file>

<file path="plan/归档/2026-02-15_OpenClaw渠道扩展_DiscordSlack/任务清单.md">
# 任务清单

## 1. 准备阶段
- [x] 1.1 阅读 OpenClaw Discord/Slack 配置 schema | 验收：确认字段来源 `zod-schema.providers-core.ts`
- [x] 1.2 明确傻瓜化字段边界 | 验收：仅保留终端用户需要的业务字段

## 2. 实现阶段
- [x] 2.1 扩展后端 settings schema | 验收：支持 `channels.discord`、`channels.slack`
- [x] 2.2 扩展配置读写映射 | 验收：`extract/apply` 可对齐官方字段并兼容 `dm.*` 别名
- [x] 2.3 扩展前端配置表单 | 验收：页面新增 Discord/Slack 卡片与字段绑定
- [x] 2.4 增加渠道测试接口 | 验收：新增 Discord/Slack 测试 API 与前端按钮

## 3. 验证阶段
- [x] 3.1 语法检查通过 | 验收：`node --check` 通过
- [x] 3.2 冒烟检查通过 | 验收：`npm run check` 通过
- [x] 3.3 配置接口回归通过 | 验收：`GET/PUT /api/settings` 覆盖 Discord/Slack 字段

## 4. 收尾阶段
- [x] 4.1 规格主文档同步 | 验收：`plan/规格/OpenClaw面板.md` 已补 Discord/Slack
- [x] 4.2 归档任务文档 | 验收：任务目录已落到 `plan/归档/`

## 经验记录
### 步骤 2 完成记录
- 实际情况：Discord/Slack 都有 `dmPolicy/allowFrom` 别名与 `dm.*` 旧结构，写入时必须双写避免兼容问题。
- 遇到问题：本地 18080 端口存在旧进程，导致前端读取旧接口结构，需先清理再验证。
- 技术债：多账号（`accounts.*`）目前只覆盖 `main/首账号`，后续可补专用账号管理页。
</file>

<file path="plan/归档/2026-02-15_OpenClaw渠道扩展_DiscordSlack/提案.md">
# OpenClaw 渠道扩展（Discord / Slack）

创建时间：2026-02-15 00:00:00

## 为什么做
当前面板仅支持 Telegram 与飞书，无法覆盖 OpenClaw 常见的 Discord / Slack 接入场景，用户仍需回落命令行修改配置。

## 改什么
- 在可视化配置中心新增 Discord 与 Slack 渠道配置卡片
- 对齐 OpenClaw 官方字段映射：`channels.discord.*`、`channels.slack.*`
- 新增 Discord / Slack “测试连接”接口
- 保持页面不展示服务器 IP、监听端口、网关端点

## 影响范围
- 涉及模块：`src/openclaw-config.js`、`src/server.js`、`src/channel-tests.js`、`public/index.html`、`public/app.js`
- 涉及接口：`GET/PUT /api/settings`、`POST /api/test/discord`、`POST /api/test/slack`
- 风险等级：L1

## 不做什么（边界）
- 不实现 Discord/Slack 的全量高级字段（如多账号路由、线程高级策略）
- 不改 OpenClaw 本体代码
- 不引入 Docker 或重型运行时

## 验证
- `npm run check`
- `GET /api/settings` 返回 Discord / Slack 新字段
- `PUT /api/settings` 对 Discord / Slack 字段可写入并做策略校验
- `POST /api/test/discord` 与 `POST /api/test/slack` 可返回可读结果
</file>

<file path="plan/归档/2026-02-15_OpenClaw源码对齐面板重构/规格变更/OpenClaw面板.md">
# OpenClaw面板 - 变更

## 修改需求
### 需求：可视化配置中心
将首批字段从“通用占位字段”升级为 “OpenClaw 官方结构字段”。

#### 场景：模型字段对齐
- 当 用户配置 AI 模型
- 那么 系统必须映射到 `models.providers.*` 与 `agents.defaults.model.primary`

#### 场景：渠道字段对齐
- 当 用户配置 Telegram / Feishu
- 那么 系统必须映射到 `channels.telegram.*` 与 `channels.feishu.*`

### 需求：安全基线
用户页面不展示小鸡监听地址、端口、网关端点等运维字段。

#### 场景：用户操作页面
- 当 用户进入配置页面
- 那么 页面只展示模型与渠道业务字段，不展示基础设施端点
</file>

<file path="plan/归档/2026-02-15_OpenClaw源码对齐面板重构/任务清单.md">
# 任务清单

## 1. 准备阶段
- [x] 1.1 拉取 openclaw 官方仓库 | 验收：`third_party/openclaw` 存在
- [x] 1.2 定位配置 schema 与 CLI 映射 | 验收：完成字段清单

## 2. 实现阶段
- [x] 2.1 重写设置模型结构 | 验收：`/api/settings` 返回 model/telegram/feishu 新结构
- [x] 2.2 对齐 Telegram 字段 | 验收：支持 dmPolicy/groupPolicy/allowFrom/streamMode
- [x] 2.3 对齐 Feishu 字段 | 验收：支持 appId/appSecret/domain/connectionMode/policy
- [x] 2.4 重构前端信息架构 | 验收：改为 模型/渠道/服务/日志 四页签
- [x] 2.5 隐藏运维端点字段 | 验收：首页不显示 listen_host 等字段

## 3. 验证阶段
- [x] 3.1 冒烟检查通过 | 验收：`npm run check` 通过
- [x] 3.2 接口读写通过 | 验收：`GET/PUT /api/settings` 正常
- [x] 3.3 页面结构验证通过 | 验收：`HAS_RUNTIME_TAB=False`

## 4. 收尾阶段
- [x] 4.1 规格主文档同步 | 验收：`plan/规格/OpenClaw面板.md` 已更新
- [x] 4.2 归档到 plan/归档/ | 验收：完成后执行

## 经验记录
### 步骤 2 完成记录
- 实际情况：必须先源码对齐再做 UI，否则字段命名和策略很容易偏离
- 遇到问题：旧服务进程占用 18080，导致误读旧接口结构
- 技术债：后续应加入“字段来源注释”自动生成，减少版本漂移
</file>

<file path="plan/归档/2026-02-15_OpenClaw源码对齐面板重构/提案.md">
# OpenClaw 源码对齐面板重构

创建时间：2026-02-15 00:00:00

## 为什么做
现有 MVP 面板字段并未完全对齐 `openclaw/openclaw` 真实配置结构，且向用户暴露了运行层参数，不符合“傻瓜化”目标。

## 改什么
- 拉取 `openclaw/openclaw` 源码并提取真实配置项
- 将面板字段改为官方结构映射：`models.providers.*`、`agents.defaults.model.primary`、`channels.telegram.*`、`channels.feishu.*`
- 隐藏监听地址/端口等运维字段，不在用户页面展示
- 保留服务控制与日志排障能力

## 影响范围
- 涉及模块：`src/openclaw-config.js`、`public/index.html`、`public/app.js`、`public/styles.css`
- 涉及接口：`GET/PUT /api/settings`
- 风险等级：L1

## 不做什么（边界）
- 不实现 OpenClaw 全量配置字段（仅首批核心字段）
- 不实现多账号高级编排 UI（先保留 `accounts.main` 兼容写入）
- 不改动 OpenClaw 源码本体

## 验证
- `npm run check`
- `GET /api/settings` 返回新字段结构
- `PUT /api/settings` 可落盘且自动备份
- 首页不出现 `listen_host` 等运维字段
</file>

<file path="plan/归档/2026-02-16_OpenClaw面板更新入口_测试与CI/规格变更/OpenClaw面板.md">
# OpenClaw面板 - 变更

## 新增需求
### 需求：版本管理闭环
面板必须提供 OpenClaw 版本检查、升级、回滚的可视化能力，且升级失败必须自动回滚。

#### 场景：检查更新
- 当 用户点击“检查更新”
- 那么 系统必须返回当前版本与上游最新版本

#### 场景：一键升级
- 当 用户输入目标版本并点击“升级”
- 那么 系统必须拉取目标镜像、重建网关容器，并返回结果

#### 场景：升级失败自动回滚
- 当 目标版本容器启动失败
- 那么 系统必须自动回滚到升级前版本并返回回滚结果

#### 场景：手动回滚
- 当 用户点击“回滚”
- 那么 系统必须切换回指定版本并重建容器
</file>

<file path="plan/归档/2026-02-16_OpenClaw面板更新入口_测试与CI/技术设计.md">
# 技术设计

## 背景与约束
- 面板目前运行在 Docker 容器内，通过 Docker Socket 控制 `openclaw-gateway`。
- 需要在不暴露基础设施细节给终端用户的前提下，提供升级与回滚入口。
- 必须保留失败自动回滚，避免“点升级直接炸服”。

## 目标
- 提供可视化版本管理闭环：检查更新、升级、回滚。
- 提供最小但可执行的测试体系与 CI/CD。

## 不做（Non-Goals）
- 不做多 Bot 调度编排。
- 不做跨主机集群更新。

## 技术决策
| 决策点 | 选择 | 原因 | 放弃方案 |
|--------|------|------|----------|
| 更新实现方式 | 后端直接调用 Docker CLI，按容器 inspect 信息重建容器 | 不依赖宿主 `docker compose` 路径语义，容器内可执行 | 在容器内执行 compose 脚本（路径映射不稳定） |
| 版本检查源 | GitHub Releases API（openclaw/openclaw） | 数据直观，含 tag 与发布时间 | 仅本地镜像列表（拿不到最新信息） |
| 测试框架 | Node 内置 `node:test` | 轻量，无额外运行时开销 | 引入 Jest/Vitest（增加依赖与构建成本） |
| CI/CD 平台 | GitHub Actions | 与仓库托管一致，维护成本最低 | 自建 Runner 流水线 |

## 风险与缓解
| 风险 | 缓解措施 |
|------|----------|
| Docker 权限操作失败 | 每步捕获错误并返回可读信息 |
| 升级后容器起不来 | 自动回滚到旧镜像 |
| 远程版本查询失败 | 降级返回“仅显示当前版本” |
| API 被误调用 | 仅保留本地访问路径，部署层继续反代鉴权 |

## 迁移/回滚方案
- 迁移步骤：
  1. 部署新面板版本
  2. 用户在面板点击检查更新/升级
  3. 后端执行拉镜像并重建容器
- 回滚步骤：
  1. 自动回滚（升级失败触发）
  2. 或手动回滚到指定 tag
- 验证方式：
  - API 调用结果 + `docker inspect` 运行态 + 页面提示
</file>

<file path="plan/归档/2026-02-16_OpenClaw面板更新入口_测试与CI/任务清单.md">
# 任务清单

## 1. 准备阶段
- [x] 1.1 阅读现有规格 | 验收：`plan/规格/OpenClaw面板.md` 已确认
- [x] 1.2 确认无冲突进行中任务 | 验收：`plan/` 目录检查完成

## 2. 实现阶段
- [x] 2.1 新增更新 API | 验收：支持版本检查/升级/回滚
- [x] 2.2 前端新增更新管理区块 | 验收：可一键触发检查、升级、回滚
- [x] 2.3 补单元测试 | 验收：核心版本与回滚逻辑有测试覆盖
- [x] 2.4 补回归测试 | 验收：关键接口行为可回放验证
- [x] 2.5 补 CI/CD 工作流 | 验收：CI 跑检查与测试，CD 可构建发布镜像

## 3. 验证阶段
- [x] 3.1 本地测试通过 | 验收：`npm run test:unit && npm run test:regression && npm run check`
- [x] 3.2 容器联调通过 | 验收：升级失败自动回滚可复现
- [x] 3.3 页面联调通过 | 验收：按钮交互与反馈完整

## 4. 收尾阶段
- [x] 4.1 更新规格文档 | 验收：`plan/规格/OpenClaw面板.md` 同步更新管理能力
- [ ] 4.2 归档任务目录 | 验收：移动到 `plan/归档/`

## 经验记录
### 步骤 2 完成记录
- 实际情况：更新 API 采用 inspect + run 重建容器，避免容器内 compose 路径歧义
- 遇到问题：初版重建未保留 compose labels，导致 `compose ps` 丢失网关容器
- 技术债：后续可补“更新前预检查（磁盘空间/镜像可达性）”提升可观测性

### 步骤 3 完成记录
- 实际情况：已完成 API 实测（检查更新、回滚）与真实容器状态回查
- 遇到问题：Windows/WSL 下请求默认 content-type 触发 415，已改为显式 JSON 调用
- 技术债：目前未引入端到端浏览器自动化测试（Playwright），后续可按需要增加
</file>

<file path="plan/归档/2026-02-16_OpenClaw面板更新入口_测试与CI/提案.md">
# OpenClaw 面板更新入口 + 测试与 CI/CD

创建时间：2026-02-16 00:45:00

## 为什么做
当前面板已支持配置、服务控制、日志排障，但缺少“版本管理闭环”，用户仍需命令行执行升级/回滚。  
同时测试与 CI/CD 基础不足，后续迭代存在回归风险。

## 改什么
- 新增面板更新管理能力：检查版本、升级到指定 tag、回滚到指定 tag。
- 后端增加 Docker 更新/回滚 API，沿用“失败自动回滚”安全策略。
- 前端新增“更新管理”区域与操作反馈。
- 补齐单元测试与回归测试脚本。
- 新增 GitHub Actions：CI（检查+测试）与 CD（面板镜像构建发布）。

## 影响范围
- 涉及模块：`src/server.js`、`public/index.html`、`public/app.js`、`public/styles.css`、新增 `src/docker-update.js` 与测试目录、`.github/workflows/*`
- 风险等级：L2

## 不做什么（边界）
- 本次不做多 Bot 编排（仍只支持 OpenClaw）。
- 本次不改 OpenClaw 上游源码。
- 本次不做前端框架迁移（继续原生 JS/CSS）。

## 验证（存在风险时必填）
- 最小验证步骤：
  - 本地 API 验证：`/api/update/check`、`/api/update/upgrade`、`/api/update/rollback`
  - 运行 `npm run test:unit`、`npm run test:regression`、`npm run check`
  - `docker compose ps` 验证网关与面板存活

## 回滚（存在风险时必填）
- 回滚触发条件：升级后容器未运行，或 API 返回失败
- 回滚步骤：
  - 执行回滚 API 或 `bash deploy/docker-rollback.sh <old-tag>`
  - 恢复 `.env` 对应版本并重启容器
</file>

<file path="plan/规格/产品需求.md">
# 产品需求

最后更新：2026-02-16

## 能力概述

定义 OpenClaw 面板在“预装交付服务器”场景下的产品目标、边界、用户价值与验收标准，确保迁移与扩展不偏离插件式控制器定位。

## 关联文档
- `plan/规格/应用流程.md`
- `plan/规格/技术栈约束.md`
- `plan/规格/前端规范.md`
- `plan/规格/后端结构.md`
- `plan/规格/OpenClaw面板.md`

## 需求列表

### 需求：预装即用
用户购买服务器后，必须通过可视化控制台直接完成状态查看与核心配置，无需首次安装向导。

#### 场景：首次访问
- 当 用户首次打开控制台
- 那么 系统必须直接进入仪表盘，并展示当前可用状态与关键入口

#### 场景：免向导
- 当 用户进行模型或渠道配置
- 那么 系统必须通过标准页面完成操作，不依赖向导流程

### 需求：插件式控制边界
控制台必须作为 OpenClaw 外部控制器运行，不得依赖修改 OpenClaw 源码实现功能。

#### 场景：功能扩展
- 当 增加新功能（如 Skills 管理、对话控制台）
- 那么 必须通过配置写入、服务控制或 Gateway 接口接入

#### 场景：版本升级
- 当 OpenClaw 升级
- 那么 控制台应通过适配层处理差异，保持低耦合

### 需求：核心功能可见且可用
控制台必须至少覆盖状态总览、模型与提供商配置、渠道接入、技能管理、更新管理、日志查看与后台状态。

#### 场景：状态总览
- 当 用户进入仪表盘
- 那么 必须一眼看到运行状态、当前模型、渠道状态、技能状态与错误摘要

#### 场景：模型配置
- 当 用户选择模板模型或自定义提供商
- 那么 必须可以完成默认模型切换与提供商新增

#### 场景：渠道配置
- 当 用户配置 Telegram/飞书
- 那么 必须支持保存与连通性测试

#### 场景：技能管理
- 当 用户查看或调整技能状态
- 那么 必须提供清晰的启停与配置入口

### 需求：Chat 能力增强（控制台侧）
控制台必须提供多会话、流式消息与思考状态展示能力，作为运维/辅助入口，不替代原生对话系统。

#### 场景：多会话
- 当 用户切换会话
- 那么 历史消息必须按会话隔离展示

#### 场景：流式消息
- 当 用户发送消息
- 那么 必须实时显示流式输出并在完成后收敛成最终消息

#### 场景：思考状态
- 当 用户切换思考显示
- 那么 仅影响展示，不改变后端模型配置

### 需求：长期可维护
产品迭代必须优先保证结构稳定和可回滚，不允许以临时补丁替代架构治理。

#### 场景：跨模块改动
- 当 需求涉及多个模块
- 那么 必须先完成文档与接口契约，再进入编码

#### 场景：发布回滚
- 当 新功能影响稳定性
- 那么 必须可按模块关闭或回退，不影响已稳定功能
</file>

<file path="plan/规格/后端结构.md">
# 后端结构

最后更新：2026-02-16

## 能力概述

定义面板后端在“插件式控制器”模式下的模块边界、接口约束与数据流，保障迁移后长期可维护。

## 关联文档
- `plan/规格/产品需求.md`
- `plan/规格/应用流程.md`
- `plan/规格/技术栈约束.md`
- `plan/规格/OpenClaw面板.md`

## 需求列表

### 需求：分层职责明确
后端必须按“路由层 -> 服务层 -> 适配层 -> 配置/系统层”分层，禁止路由层直写复杂业务。

#### 场景：新增 Chat/Skills 路由
- 当 增加新的 API
- 那么 路由层只负责参数校验与返回封装，业务逻辑必须进入服务层

#### 场景：Gateway 调用
- 当 调用 OpenClaw Gateway RPC
- 那么 必须经过统一适配层，避免调用分散

### 需求：配置写入单一入口
`openclaw.json` 与 `panel.config.json` 的写入必须通过统一模块处理。

#### 场景：模型与提供商写入
- 当 保存默认模型或新增提供商
- 那么 必须通过 `openclaw-config` 统一映射，避免并发覆盖

#### 场景：渠道写入
- 当 保存 Telegram/飞书等渠道配置
- 那么 必须沿用现有字段映射和校验，不得绕过校验层

### 需求：Gateway 适配层标准化
所有 Gateway RPC 调用必须有统一超时、错误码和日志策略。

#### 场景：聊天消息发送
- 当 调用 `chat.send`
- 那么 必须记录请求 ID、sessionKey、runId，并处理超时与重试策略

#### 场景：技能状态读取
- 当 调用 `skills.status`
- 那么 接口失败时必须返回可降级错误，不得抛未处理异常

### 需求：流式事件链路稳定
Chat 流式事件必须通过统一事件通道传输并可重连。

#### 场景：SSE 断线
- 当 浏览器断线重连
- 那么 必须支持恢复监听并避免重复推送已完成消息

#### 场景：最终态丢失
- 当 长时间未收到 `final`
- 那么 服务层必须触发补偿查询（如拉取历史）并结束挂起状态

### 需求：安全与审计
敏感操作必须具备最小审计能力与脱敏日志策略。

#### 场景：技能高风险操作
- 当 执行启停或配置变更
- 那么 必须记录操作时间、目标、结果和操作者标识（若可用）

#### 场景：密钥相关日志
- 当 打印请求或配置变更日志
- 那么 必须脱敏 API Key/Secret，不得输出明文

### 需求：接口契约可版本化
新增接口必须遵循统一返回结构，并保留向后兼容。

#### 场景：新增 `/api/chat/*`、`/api/skills/*`
- 当 接口上线
- 那么 返回结构必须包含 `ok` 与可读 `message`/`error`，并在文档记录版本差异

#### 场景：兼容旧前端
- 当 旧页面仍调用既有接口
- 那么 后端必须保持旧接口行为不变
</file>

<file path="plan/规格/技术栈约束.md">
# 技术栈约束

最后更新：2026-02-16

## 能力概述

定义当前项目在迁移 ClawX 能力时必须遵守的技术栈边界、依赖策略与兼容约束，防止架构漂移。

## 关联文档
- `plan/规格/产品需求.md`
- `plan/规格/后端结构.md`
- `plan/规格/前端规范.md`
- `plan/规格/OpenClaw面板.md`

## 需求列表

### 需求：运行形态固定为 Web + Docker
项目必须保持 Fastify 服务端 + 静态前端 + Docker 部署，不引入 Electron 运行时依赖。

#### 场景：能力迁移
- 当 参考 ClawX 功能实现
- 那么 必须迁移为 Web 可运行形态，不可引入 Electron IPC、BrowserWindow、auto-updater

#### 场景：部署执行
- 当 进入生产部署
- 那么 必须继续支持 `docker compose` 标准流程

#### 场景：开发与生产环境差异
- 当 开发在 Windows Docker、生产在 Linux Docker
- 那么 每个关键能力必须在 Linux 环境完成复验，不得仅以 Windows 验证作为发布依据

### 需求：依赖控制
新增依赖必须可解释且最小化，优先复用现有栈能力。

#### 场景：实时通信
- 当 实现 Chat 流式消息
- 那么 优先复用 SSE；如必须使用 WS，需给出明确收益与回滚方案

#### 场景：状态管理
- 当 前端需要新增状态逻辑
- 那么 优先在现有 `public/app.js` 模块化拆分，不引入重型前端框架

### 需求：接口兼容优先
新增 API 必须与现有 `/api/settings`、`/api/service/*`、`/api/logs/*` 并存，不破坏已上线调用路径。

#### 场景：新增 chat/skills 接口
- 当 扩展后端路由
- 那么 必须保证旧接口返回结构与行为不变

#### 场景：配置写入
- 当 新功能写入 `openclaw.json`
- 那么 必须遵守现有字段映射与校验逻辑，禁止跨面板副作用写入

### 需求：安全基线不降低
新增能力不得降低当前安全边界。

#### 场景：密钥处理
- 当 展示或保存 API Key
- 那么 必须默认脱敏展示，日志中不得打印明文

#### 场景：外网访问
- 当 面板需要公网访问
- 那么 仍必须通过反向代理鉴权，不开放未授权直连

### 需求：单公网IP+端口映射部署约束
系统必须兼容“母机单公网 IP + 小机分配端口”交付方式，所有端口相关能力不得做硬编码假设。

#### 场景：对外入口地址
- 当 生成前端展示地址、Webhook 回调地址
- 那么 必须使用“公网 IP + 端口”形式，不得默认省略端口或假设 80/443，并由 `panel.config.json.reverse_proxy` 字段统一提供

#### 场景：端口配置
- 当 定义服务监听端口与对外暴露端口
- 那么 必须支持 env/配置文件可配置，禁止写死 80/443/3000 等固定端口

#### 场景：容器内部通信
- 当 Docker 容器之间互联
- 那么 必须优先使用内部网络与共享卷，不走公网入口地址

#### 场景：连通性判断
- 当 评估端口映射影响范围
- 那么 只能约束“外部入站访问”；容器内部通信不应受公网端口映射策略影响

### 需求：测试与发布约束
每一批迁移能力必须有可复现验证，且支持快速回滚。

#### 场景：功能发布
- 当 发布 Dashboard/Skills/Chat 新能力
- 那么 必须有对应测试证据与回滚开关

#### 场景：Docker 回归
- 当 容器重建或升级后
- 那么 新能力必须保持可用，旧能力不得回归
</file>

<file path="plan/规格/前端规范.md">
# 前端规范

最后更新：2026-02-16

## 能力概述

规范控制台前端的信息架构、交互行为、状态管理与文案表达，确保迁移后页面一致、易懂、可维护。

## 关联文档
- `plan/规格/产品需求.md`
- `plan/规格/应用流程.md`
- `plan/规格/后端结构.md`
- `plan/规格/OpenClaw面板.md`

## 需求列表

### 需求：信息架构一致
侧栏导航命名和分组必须以用户任务为中心，避免技术术语堆叠。

#### 场景：核心入口命名
- 当 展示导航菜单
- 那么 必须使用中文任务化命名（如“仪表盘”“模型与提供商配置”“渠道配置”“对话控制台”）

#### 场景：重复信息治理
- 当 同一系统状态在多个区域出现
- 那么 必须将主展示收敛到仪表盘，其他页面仅保留必要上下文

### 需求：模型与提供商页面可理解
模型页必须明确区分“设置当前默认模型”和“新增提供商”两条路径。

#### 场景：小白用户操作
- 当 用户进入模型页
- 那么 必须看到简明说明：先选默认模型，或新增提供商后再选模型

#### 场景：模板配置
- 当 用户使用基础模板
- 那么 只需填写提供商名、URL、Key 即可完成配置

#### 场景：自定义配置
- 当 用户切换到自定义模式
- 那么 必须展示完整字段并提供校验反馈

### 需求：仪表盘展示规范
仪表盘卡片必须突出“当前状态”和“可执行动作”。

#### 场景：模型卡片
- 当 展示可用模型
- 那么 按提供商分组，并标出当前模型、上下文窗口、最大输出、思考强度

#### 场景：风险提示
- 当 用户切换到更小上下文模型
- 那么 必须出现明确风险提示，且提示可读、可关闭

### 需求：Chat 交互规范
对话控制台必须采用稳定的状态机 UI，避免发送态卡死或消息重复。

#### 场景：流式消息
- 当 收到 `delta` 事件
- 那么 必须增量刷新消息区，不覆盖已完成消息

#### 场景：最终消息
- 当 收到 `final` 事件
- 那么 必须完成消息落地并清理流式占位状态

#### 场景：思考显示
- 当 用户切换“思考状态”
- 那么 必须仅控制展示层，不触发额外请求

### 需求：错误反馈规范
所有失败操作必须返回可执行的错误信息，不允许“静默失败”。

#### 场景：保存失败
- 当 配置保存失败
- 那么 必须展示失败原因、影响范围和建议修复动作

#### 场景：接口不可用
- 当 后端接口降级或超时
- 那么 必须提示“当前能力不可用”并保持页面其余功能可用

### 需求：代码组织规范
前端脚本必须模块化，避免单文件持续膨胀。

#### 场景：新增模块
- 当 增加 dashboard/chat/skills 大块逻辑
- 那么 必须拆分为独立模块文件，并保留统一入口编排

#### 场景：可测试性
- 当 涉及关键状态变更逻辑
- 那么 必须补充最小可验证脚本或测试用例
</file>

<file path="plan/规格/应用流程.md">
# 应用流程

最后更新：2026-02-16

## 能力概述

定义控制台主要页面与关键操作链路，确保用户路径清晰、动作可回放、异常可处理。

## 关联文档
- `plan/规格/产品需求.md`
- `plan/规格/前端规范.md`
- `plan/规格/后端结构.md`
- `plan/规格/OpenClaw面板.md`

## 需求列表

### 需求：主导航流程清晰
主导航必须至少包含：仪表盘、模型与提供商配置、渠道配置、对话控制台、更新管理、服务状态、日志中心。

#### 场景：页面切换
- 当 用户点击侧栏导航
- 那么 系统必须在对应页面展示该模块核心操作，不出现重复入口冲突

#### 场景：默认落点
- 当 用户访问根路径
- 那么 系统必须落在仪表盘页面

### 需求：仪表盘流程
仪表盘必须承载“看全局”和“快速动作”的流程。

#### 场景：快速判断系统健康
- 当 用户进入仪表盘
- 那么 系统必须展示关键健康指标与当前默认模型

#### 场景：快速切换模型
- 当 用户在仪表盘执行模型切换
- 那么 系统必须完成切换并反馈结果，必要时提示上下文风险

### 需求：模型与提供商配置流程
模型页必须拆分为“设置当前默认模型”和“新增提供商”两条路径。

#### 场景：默认模型设置
- 当 用户在下拉中选择模型并保存
- 那么 系统必须更新默认模型引用并回显当前生效值

#### 场景：新增提供商
- 当 用户选择模板或自定义并填写 URL/Key
- 那么 系统必须完成写入并支持后续选择该提供商模型

### 需求：渠道配置流程
渠道页必须统一管理 OpenClaw 实际渠道配置，并提供可复现测试。

#### 场景：Telegram 接入
- 当 用户填写 Bot Token 等字段并点击测试
- 那么 系统必须返回明确的连通性结果与错误原因

#### 场景：飞书接入
- 当 用户填写 AppId/AppSecret 并提交
- 那么 系统必须保存配置并返回校验结果

### 需求：Skills 管理流程
Skills 页必须支持“查看 -> 变更 -> 验证”的闭环。

#### 场景：查看技能状态
- 当 用户进入 Skills 页面
- 那么 系统必须展示技能列表和启用状态

#### 场景：变更技能状态
- 当 用户启用或停用技能
- 那么 系统必须进行确认并返回执行结果

### 需求：对话控制台流程
对话控制台必须支持多会话、流式消息、思考状态、中止运行。

#### 场景：会话切换
- 当 用户切换会话
- 那么 系统必须加载该会话历史，并保持输入区状态一致

#### 场景：消息流式返回
- 当 用户发送消息
- 那么 系统必须按 delta 逐步更新，并在 final 时完成落地

#### 场景：中止运行
- 当 用户点击停止
- 那么 系统必须终止当前运行并恢复可发送状态

### 需求：更新与日志流程
更新与日志页必须支持运维排障闭环。

#### 场景：检查更新与升级
- 当 用户发起检查/升级/回滚
- 那么 系统必须提供可追踪结果并保留失败原因

#### 场景：日志排障
- 当 用户查看实时日志或错误摘要
- 那么 系统必须支持过滤、实时刷新和关键错误定位
</file>

<file path="plan/规格/OpenClaw面板.md">
# OpenClaw面板

最后更新：2026-02-16

## 能力概述

提供 OpenClaw 的本机可视化配置、服务管理与日志排障能力，目标是让最终用户不需要命令行即可完成常见运维操作。

## 需求列表

### 需求：可视化配置中心

面板必须支持以字段化方式编辑 OpenClaw 关键配置，至少覆盖 API、Base URL、模型、Telegram、飞书、Discord、Slack 等常用字段。

#### 场景：字段化编辑
- 当 用户进入配置中心并修改关键字段
- 那么 系统必须进行输入校验并写入配置文件

#### 场景：敏感字段保护
- 当 用户查看已保存的 API Key 或 Secret
- 那么 面板必须默认掩码显示，不直接明文回显

#### 场景：字段校验
- 当 用户提交配置
- 那么 系统必须执行必填、URL 格式、模型名非空等基础校验

#### 场景：OpenClaw 官方字段映射
- 当 用户修改模型与渠道配置
- 那么 系统必须映射到官方字段：`models.providers.*`、`agents.defaults.model.primary`、`channels.telegram.*`、`channels.feishu.*`、`channels.discord.*`、`channels.slack.*`

### 需求：运行参数可配置

面板必须支持监听地址、端口、OpenClaw 配置路径、服务名、容器名、日志来源、运行时模式等运行参数可配置。

#### 场景：模板适配
- 当 面板部署到不同模板机
- 那么 运维人员必须可通过配置修改运行参数而无需改代码

### 需求：服务生命周期控制

面板必须支持对 OpenClaw 运行实例执行启动、停止、重启、状态查询，且兼容 `systemd` 与 `docker` 两种运行时。

#### 场景：可视化启停
- 当 用户点击服务控制按钮
- 那么 系统必须返回明确的成功或失败结果及错误原因

#### 场景：运行时切换
- 当 目标环境采用 Docker 部署
- 那么 系统必须通过容器名执行状态查询与启停控制，而不是依赖 systemd

### 需求：网关配对自愈操作

面板必须支持读取并批准 Gateway 的 pending 设备配对请求，帮助用户在 `pairing required` 场景下无需命令行即可恢复连接。

#### 场景：一键批准待处理配对
- 当 用户在仪表盘点击“批准待处理配对”
- 那么 系统必须读取 pending 请求并依次执行批准，返回批准数量与失败详情

#### 场景：无 pending 的空操作
- 当 当前没有待批准配对请求
- 那么 系统必须返回“无需处理”的成功结果，不报错

### 需求：仪表盘网关快速重启动作

面板必须在仪表盘提供“重启网关服务”入口，调用既有服务控制链路并反馈执行结果。

#### 场景：一键重启网关
- 当 用户在仪表盘点击“重启网关服务”
- 那么 系统必须触发网关重启并反馈成功或失败原因

### 需求：日志可观测

面板必须提供实时日志查看与错误定位能力。

#### 场景：实时日志
- 当 用户打开日志页面
- 那么 系统必须展示实时追加日志并支持关键字过滤

#### 场景：错误摘要
- 当 系统读取日志记录
- 那么 系统必须提供最近 N 条错误摘要以便快速排障

#### 场景：日志来源切换
- 当 目标环境日志策略不同
- 那么 系统必须支持 `journal`、`file` 与 `docker` 三种日志来源

### 需求：智能对话主页面

面板必须提供面向小白用户的聊天页面，支持多会话、流式回复、思考状态展示开关与停止回复。

#### 场景：多会话切换
- 当 用户在聊天页切换或新建会话
- 那么 系统必须按 `sessionKey` 隔离历史，避免串会话

#### 场景：流式回复
- 当 用户发送消息
- 那么 系统必须在消息区原位展示增量回复，并在终态收敛发送状态

#### 场景：思考状态开关
- 当 用户切换“显示思考状态”
- 那么 系统必须仅影响前端展示，不改变后端请求参数

#### 场景：高级调试折叠
- 当 用户进入聊天页
- 那么 高级调试信息必须默认折叠，不干扰主流程

#### 场景：附件发送
- 当 用户上传、粘贴或拖拽附件后发送消息
- 那么 系统必须完成“附件落盘 -> 路径映射 -> 聊天发送”闭环，并保证网关可读取附件

#### 场景：消息富渲染
- 当 助手消息包含 Markdown 或工具调用/结果内容
- 那么 系统必须以可读格式渲染（强调、代码、工具标签），避免用户阅读原始结构化文本

#### 场景：局部错误提示
- 当 聊天页中的单步动作失败（发送、刷新、附件处理、中止、重置）
- 那么 系统必须在聊天区域内给出明确错误提示，不只依赖全局操作时间线

### 需求：仪表盘状态总览

面板必须在仪表盘提供一页式巡检，集中展示运行状态、模型、渠道、Skills、错误摘要和版本信息。

#### 场景：一页巡检
- 当 用户打开仪表盘
- 那么 系统必须在同一页面展示运行状态、当前模型、渠道统计、Skills 统计、错误摘要与版本状态

#### 场景：快捷操作入口
- 当 用户需要继续操作（聊天、模型、渠道、技能、更新、服务控制）
- 那么 仪表盘必须提供可直接跳转的快捷入口，减少侧栏来回切换

#### 场景：运行态明细
- 当 用户需要确认当前“到底哪些渠道和技能在运行”
- 那么 仪表盘必须展示渠道运行态和 Skills 运行态明细列表

#### 场景：模型快速切换风险提示
- 当 用户在仪表盘快速切换默认模型，且目标模型上下文上限更小
- 那么 系统必须提示“可能因上下文超限导致失败”的风险，并要求确认后再执行切换

#### 场景：入口收敛与兼容
- 当 用户从旧入口或历史链接访问状态总览
- 那么 系统必须将状态巡检统一到仪表盘，并保证旧路径可兼容访问

### 需求：版本管理闭环

面板必须提供 OpenClaw 版本检查、升级、回滚能力，并在升级失败时自动回滚。

#### 场景：检查更新
- 当 用户点击“检查更新”
- 那么 系统必须返回当前版本与上游最新版本

#### 场景：一键升级
- 当 用户输入目标版本并执行升级
- 那么 系统必须拉取目标镜像并重建网关容器

#### 场景：升级失败自动回滚
- 当 升级后容器未进入 running 状态
- 那么 系统必须自动回滚到升级前镜像并返回回滚结果

### 需求：安全与公网入口基线

面板必须兼容“母机单公网 IP + 分配端口”部署，同时保持默认安全基线不降低。

#### 场景：默认监听
- 当 面板以 systemd 本地模式首次启动
- 那么 监听地址默认应为 `127.0.0.1`，并允许通过配置覆盖

#### 场景：Docker 对外映射
- 当 面板与网关通过 Docker 运行
- 那么 对外端口必须通过 env/配置文件可配置，不得写死固定公网端口

#### 场景：公网地址展示
- 当 用户打开仪表盘
- 那么 系统必须展示“面板公网访问地址”和“Webhook 回调基地址”，且格式为 `公网IP:端口`

#### 场景：容器内部通信
- 当 面板与网关发生内部通信
- 那么 必须优先使用 Docker 内部网络和共享卷，不经公网入口地址
</file>

<file path="plan/文档体系说明.md">
# 龙虾可视化仓库文档体系说明

最后更新：2026-02-19

## 目标

把任务文档、规格文档、历史资料统一收敛到 `plan/` 目录，避免“文档散落在仓库根目录”和“同一资料多份副本”导致后续执行偏航。

## 目录约束（唯一口径）

### 1) `plan/规格/`
- 用途：系统当前能力的真相来源（长期有效）。
- 内容：需求、场景、边界、约束。
- 要求：采用“当...那么...”可验收表达。

### 2) `plan/YYYY-MM-DD_任务名/`
- 用途：进行中任务与阶段产物。
- 最小集：
  - `提案.md`
  - `任务清单.md`
  - `技术设计.md`（跨模块/高风险时必需）
  - `规格变更/*.md`（涉及需求或契约变更时必需）

### 3) `plan/归档/`
- 用途：已完成任务归档。
- 归档前提：任务验收通过，且需要的规格合并已完成。

### 4) `plan/资料/`
- 用途：历史会话纪要、外部对接说明、一次性背景材料。
- 要求：只保存“参考资料”，不替代 `plan/规格` 与任务目录内正式文档。

## 根目录约束

- 仓库根目录只保留代码相关入口文档（如 `README.md`、`AGENTS.md`）。
- 历史纪要、对接说明、模板说明等资料不得长期放在根目录，统一进入 `plan/资料/`。

## 去重规则

1. 同一资料只保留一份主副本，位置固定在 `plan/资料/`。
2. 若发现根目录与 `plan/资料/` 同名资料并存，以 `plan/资料/` 为准，根目录副本删除。
3. 不处理第三方目录（如 `node_modules/`、`third_party/`、`data/`）中的文档重名，它们不属于本仓库业务文档体系。

## 本次已收敛的资料

- `历史对话总结2026.02.13.21.20.md`
- `历史对话总结2026.02.15.15.05.md`
- `历史对话总结2026.02.17.14.38.md`
- `OpenClaw可视化面板_开发对接说明_v1.md`
- `Template-Debian-OpenClaw001.md`

以上文件统一放置于：`plan/资料/`

## 边界提醒（避免再次串仓）

- 本仓库（`龙虾傻瓜化`）只承载可视化页面相关需求与实施文档。
- 服务器编排与母机自动化（`pve-vm-bot`）的实施文档放在对应仓库内，不在本仓库混写执行细节。
</file>

<file path="plan/资料/历史对话总结2026.02.13.21.20.md">
# 大盘鸡项目历史对话总结（截至 2026-02-13）

## 1. 目标与场景
- 你有芬兰母鸡（PVE）开小鸡，对外卖给客户使用。
- 小鸡没有独立公网 IP，使用母鸡公网 IP + 端口映射。
- 业务要求：客户从日本 IP 入口访问；小鸡主动外连（如 TG Bot）继续走母鸡默认出口，不做全局代理。

## 2. 架构结论
- 最终方向不是“客户端全局 VPN”，而是“日本入口网关 + 芬兰母鸡二次分发”。
- 核心链路：
  1. 客户端 -> 日本机公网端口
  2. 日本机通过 WG 隧道转发到芬兰母鸡
  3. 芬兰母鸡按端口段 DNAT 到对应小鸡内网 IP
- 动态化要求：
  - 每开一台小鸡（默认 50 连续端口）自动加映射
  - 删小鸡自动删映射，防止“幽灵端口占用”

## 3. 已确认关键信息
- 日本机公网 IP：`151.242.164.130`
- 芬兰母鸡公网 IP：`135.181.162.231`
- 芬兰母鸡内网网段：`10.10.10.0/24`
- 芬兰母鸡内网网桥：`vmbr1`
- 小鸡示例内网：`10.10.10.10`、`10.10.10.11`

## 4. 运行中遇到的问题与结论
- 问题 1：日本中转到小鸡 SSH 偶发卡顿/超时。
  - 现象：登录后部分命令会卡住，直连母鸡端口时更稳定。
  - 结论：链路存在稳定性问题，需继续按路径分段定位（本地 -> 日本机 -> 芬兰母鸡 -> 小鸡）。
- 问题 2：端口池管理冲突风险。
  - 你明确要求：`10000-20000` 给售卖小鸡使用，不要占用模板机。
  - 后续动作：模板机应迁移到保留端口（如你要求的 `9900`）并检查冲突。
- 问题 3：自动化闭环。
  - 你的 bot 已能产出 `VM_READY`（包含 `vmid`、`lan`、`port_start`），具备自动调用脚本的前提。

## 5. 安全与运维注意
- 聊天里出现过一次性 root 密码，视为已泄露，应立即轮换。
- bot 到服务器建议仅使用 SSH 密钥，不使用密码登录。
- 不建议在核心母鸡长期跑不明测试脚本；可在临时 VM 测试后销毁。

## 6. 当前工作重点
- 把“创建 VM -> 自动加映射”与“删除 VM -> 自动清理映射”彻底打通。
- 模板机端口迁移到保留区（不占用售卖区）。
- 排查日本中转链路的 SSH 卡顿根因，并形成稳定连接参数/方案。

## 7. 你后续可直接复用的沟通口径
- 业务模型：日本入口统一暴露，芬兰母鸡负责端口分发，小鸡主动流量直出母鸡。
- 规则策略：日本机范围规则一次性配置；母鸡按 VM 动态增删端口映射。
- 运维原则：端口池有台账、删除必回收、测试尽量在临时 VM。
</file>

<file path="plan/资料/历史对话总结2026.02.15.15.05.md">
# 大盘鸡项目历史对话增量归档（截至 2026-02-15 15:05）

## 1. 本轮到目前为止做了什么
- 梳理了当前业务架构：
  - 日本机作为公网入口；
  - 通过 WG 回源芬兰母鸡；
  - 芬兰母鸡按端口映射到小鸡内网。
- 明确了端口策略：
  - 售卖小鸡端口池固定为 `10000-20000`；
  - 模板机迁移到保留端口 `9900`，避免与售卖池冲突。
- 处理了 bot 一次性密码“看似成功但实际不可用”的根因问题（不是端口映射问题）：
  - 根因是模板或目标 VM 缺少 cloud-init 就绪条件，`cipassword` 无法可靠生效。
- 在 `pve-vm-bot` 仓库完成了代码修复、测试、提交与推送。
- 新增了模板小鸡 SSH MCP（`ssh-template-vm`），并已实测可直连。
- 更新了本目录 `AGENT.md`，把 `ssh-template-vm` 写入“当前已接入机器”清单。

## 2. 已完成项（可复核）
### 2.1 pve-vm-bot 代码修复已完成
- 仓库：`E:/AAA__ZhuoMian/大盘鸡/pve-vm-bot`
- 修复点：
  - `cloneAndBoot` 前增加模板 cloud-init readiness 校验；
  - `setRootPassword` 前增加目标 VM cloud-init readiness 校验；
  - 缺失时直接报错，阻断“无效一次性密码”继续下发。
- 测试：新增并通过 cloud-init 缺失/存在的单测。
- 校验命令：`npm run check`（syntax/test/security 全通过）。
- 提交与推送：
  - commit: `cf8b11b`
  - branch: `main`
  - push: `origin/main` 成功。

### 2.2 连接与文档已完成
- MCP：`ssh-template-vm` 已创建并启用（目标 `135.181.162.231:9900`）。
- 实测：可执行 `hostname/whoami/uname`，确认目标是 `OpenClaw001`。
- 文档：`AGENT.md` 已同步模板机连接信息。

### 2.3 现场体检结果（刚刚）
- 模板小鸡（OpenClaw001，Debian 13）当前状态：
  - `cloud-init`: missing
  - `qemu-guest-agent`: missing
- 芬兰母鸡上模板 VM（VMID=100）当前 `qm config`：
  - `ide2` 仍是安装 ISO（`local:iso/debian-13.3.0-amd64-DVD-1.iso`），
  - 尚未挂 `cloudinit` 盘。

## 3. 未完成项（下一步必须做）
1. 在模板小鸡 VM（100）内安装并初始化 cloud-init 与 qemu-guest-agent。
2. 在芬兰母鸡把 VM 100 的 `ide2` 从 ISO 改为 `cloudinit` 盘，并启用 qemu agent。
3. 做一次最小克隆验收：
   - 克隆测试 VM；
   - 注入一次性密码/IP/DNS；
   - 验证可登录且参数生效。
4. 把这套“模板初始化 + 验收”固化成可复用脚本或 SOP，避免后续重复踩坑。

## 4. 风险与注意事项
- 当前最大风险不是端口映射，而是模板云初始化条件不完整。
- 若继续用当前模板批量开机，仍可能出现“一次性密码不生效”的投诉。
- 一次性密码已在对话中暴露过，生产环境必须轮换。

## 5. 结论（给后续会话快速接手）
- bot 代码层面的“误报成功”已修复。
- 基础设施层面的 cloud-init 仍未落地，下一步优先做模板云初始化。
- 当前会话已具备直接操作模板机能力（`ssh-template-vm` 可用）。

---

## 6. 本轮后续执行结果（2026-02-15 15:10 追加）

### 6.1 已执行并完成
- 模板小鸡（VM 100）内部已安装：
  - `cloud-init 25.1.4`
  - `qemu-guest-agent`
- 已完成模板化清理动作：
  - `cloud-init clean --logs --seed`
  - `/etc/machine-id` 清空
  - SSH host keys 删除（用于后续克隆自动生成唯一主机指纹）
  - 写入 `/etc/cloud/cloud.cfg.d/99-pve.cfg`：`datasource_list: [ NoCloud, ConfigDrive ]`
- 芬兰母鸡 VM 100 配置已改为 cloud-init 就绪：
  - `ide2: local:100/vm-100-cloudinit.qcow2,media=cdrom,size=4M`
  - `agent: enabled=1`
  - `ciuser: root`
  - `nameserver: 1.1.1.1`
  - `searchdomain: local`
- 已验证可生成 cloud-init 数据：
  - `qm cloudinit dump 100 user`
  - `qm cloudinit dump 100 network`
  均可正常输出。

### 6.2 仍待完成（下一步）
1. 做一次最小克隆验收（从 100 克隆测试 VM）：
   - 下发 `cipassword/ipconfig/nameserver`
   - 验证新 VM 可登录，确认一次性密码链路恢复。
2. 若确认稳定，再把模板固化流程做成脚本/SOP 并接入 bot 的 ops 检查。

### 6.3 备注
- 在模板机里执行 `cloud-init status` 显示 `disabled-by-generator` 是当前模板运行态常见现象（当前实例未挂载有效 datasource 时会这样）；关键是克隆实例启动后能读取 `NoCloud` 数据，`qm cloudinit dump` 已证明母鸡侧数据盘生成链路正常。
</file>

<file path="plan/资料/历史对话总结2026.02.17.14.38.md">
# 大盘鸡项目历史对话增量归档（截至 2026-02-17 14:38）

## 1. 本轮核心主题（像日记一样的直白版）
- 今天这轮的主线不是改母鸡、也不是修小鸡，而是把你长期被 SSH 指纹校验卡住的问题一次性讲明白并落地处理。
- 你最关心的是：到底是不是服务器有问题，还是本地 SSH 客户端机制导致的。
- 最后结论很清晰：这类“同 IP + 不同端口 + 端口复用”的场景里，最容易报错的是你本地 `known_hosts` / 指纹校验策略，不是小鸡坏了。

## 2. 这轮我们做了什么
### 2.1 先把概念掰直（避免继续误判）
- 明确了 SSH 有两套校验：
  - 服务器身份校验（Host Key Fingerprint）：由**本地客户端**执行；
  - 用户身份校验（密码/公钥）：由**服务器端**执行。
- 解释了为什么你会出现“密码是对的但仍连不上”：
  - 因为连接会先做服务器指纹校验；
  - 指纹冲突时，连密码阶段都进不去。

### 2.2 把你关心的定位问题定性
- 你问“是不是模板小鸡里面要改”，我们确认：
  - 模板机要保证克隆卫生（这块你现在没暴雷）；
  - 你当前高频遇到的阻断点是本地客户端策略，不是母鸡/小鸡服务异常。
- 你问“客户两台电脑同时连会不会出问题”，结论：
  - 正常不会；
  - 问题主要发生在运维端反复用同一公网端口连接不同 VM 时。

### 2.3 按你要求直接动手改本地 SSH
- 你明确要求：取消指纹验证，只走密码验证。
- 已在本机 `C:\Users\bians\.ssh\config` 追加规则，仅针对你的两台入口：
  - `135.181.162.231`
  - `151.242.164.130`
- 已做本地生效校验，确认参数生效：
  - `StrictHostKeyChecking no`
  - `UserKnownHostsFile NUL`
  - `GlobalKnownHostsFile NUL`

## 3. 已完成项（可复核）
- [x] 完成“问题归因”统一口径：不是母鸡故障，不是小鸡故障，主要是本地 SSH 指纹机制触发。
- [x] 完成“只针对业务入口主机”的 SSH 配置改造（非全局乱改）。
- [x] 完成配置生效检查（`ssh -G` 输出已确认）。
- [x] 输出后续连接建议：继续用 `root@IP -p 端口`，不强依赖别名。

## 4. 本轮关键结论（给你回看用）
- 你之前遇到的“连接被拒/反复提示指纹”在当前业务模型下属于**可预期现象**。
- 你已经选择了“禁用这两台入口的指纹校验”路线，当前这类阻断基本可以收口。
- 后续若再出现卡顿/timeout，应优先按链路问题排查（网络/路由/负载），不要再按“指纹冲突”方向浪费时间。

## 5. 当前遗留与后续建议
- 遗留 1（策略层）：现在是“效率优先”配置，安全性下降（会忽略主机真伪校验）。
- 遗留 2（运营层）：如果后续交付给更高安全要求客户，建议再切回强校验模式。
- 可选优化：
  1. 给运维电脑单独维护一份 `ssh/config` 的“生产安全版”和“运维快连版”；
  2. Bot 输出连接信息时附一行“该端口可能复用，若启用校验请先清 known_hosts”。

## 6. 本轮落盘改动
- 修改文件：`C:\Users\bians\.ssh\config`
- 新增策略块（已生效）：
  - `Host 135.181.162.231 151.242.164.130`
  - `StrictHostKeyChecking no`
  - `UserKnownHostsFile NUL`
  - `GlobalKnownHostsFile NUL`

## 7. 给下轮会话的接手提示
- 如果你说“又连不上了”，第一步不要再怀疑指纹，先看是：
  - `Permission denied`（密码/账号问题）
  - `Connection timed out`（网络链路问题）
  - `Connection reset`（服务端/中间链路问题）
- 当前指纹策略已经按你的诉求关闭，除非你手动改回，否则这条线不再是主矛盾。
</file>

<file path="plan/资料/OpenClaw可视化面板_开发对接说明_v1.md">
# OpenClaw 可视化面板开发对接说明（v1）

更新时间：2026-02-14

## 结论（先说人话）
- 可以现在就开工开发，不必等云初始化全搞完。
- 但必须把“网络与初始化”做成可配置层，不能写死在代码里。
- 云初始化（cloud-init/模板修复）后补，不影响先把核心功能做出来。

## 当前目标
- 在每台小鸡内预装 OpenClaw + 可视化管理面板。
- 用户不碰命令行，页面完成：
  - API Key / Base URL / 模型配置
  - Telegram/飞书等渠道配置
  - 服务启停/重启/状态
  - 实时日志查看与错误提示

## 当前已知环境（开发必须兼容）
- 小鸡系统：Debian 13（Trixie）。
- 小鸡无独立公网 IP，访问方式为“母鸡 IP + 端口映射”。
- 现网链路：日本入口机 -> WG -> 芬兰母鸡 -> DNAT 到小鸡。
- 端口规划：
  - 售卖池：10000-20000
  - 模板机保留：9900
  - 每台小鸡通常分配 50 连续端口，首端口常用于 SSH 映射到 22。

## 为什么现在就能开发
- 面板核心是“本机配置与本机进程管理”，与端口映射逻辑可解耦。
- 只要面板监听地址、端口、反代信息可配置，后续网络调整不会推翻前端/后端主体。

## 现在就该做的功能（MVP）
1. 配置中心
- OpenClaw 配置字段化编辑（不要只做纯文本编辑器）。
- 支持敏感字段掩码显示（API Key）。
- 配置合法性校验（必填、URL格式、模型名非空等）。

2. 服务控制
- systemd 集成：start/stop/restart/status。
- 操作结果可视化返回（成功/失败原因）。

3. 日志面板
- 实时日志（tail + 自动刷新）。
- 关键字过滤、错误高亮。
- 最近 N 条错误摘要。

4. 接入配置
- Telegram、飞书先做第一批。
- 提供“测试连接”按钮。

## 必须预留的可配置项（避免后期返工）
- `panel.listen_host`（默认 `127.0.0.1`）
- `panel.listen_port`（例如 `18080`）
- `reverse_proxy.enabled`（后续接 Nginx/Caddy）
- `openclaw.config_path`
- `openclaw.service_name`
- `log.source`（journal/file）

## 安全底线（先做最小版本）
- 面板默认仅监听 `127.0.0.1`。
- 对外访问必须走反代 + 登录鉴权（至少 Basic Auth）。
- 所有敏感配置写入时加权限控制（文件 600）。

## 云初始化后补项（后续并行推进）
1. 模板机标准化
- 修复 cloud-init 可用性（当前部分实例一次性密码不生效）。
- 克隆后自动唯一化：
  - hostname
  - machine-id
  - SSH host keys

2. 首次启动初始化脚本
- 自动写入面板基础配置。
- 自动检测端口映射信息（如有 bot 回调参数则写入）。

3. bot 对接
- VM 创建成功后可选调用初始化接口：
  - vmid / lan / port_start / count

## 推荐实施顺序（你现在就能让对方做）
1. 先做面板核心（配置+服务+日志）并在单台 Debian13 上跑通。
2. 再加渠道配置（Telegram/飞书）和测试按钮。
3. 最后接模板化与云初始化（批量交付阶段）。

## 对外说法（给开发工程师）
- 先按“单机可用”开发，网络与端口映射按“可配置接口”处理。
- 不阻塞功能开发，云初始化和模板修复并行进行。
- 目标是尽快交 MVP，再接入自动化开机流程。
</file>

<file path="plan/资料/README.md">
# 资料目录说明

本目录用于存放历史会话纪要、对接说明、模板背景资料等“参考性文档”。

## 当前资料

- `历史对话总结2026.02.13.21.20.md`
- `历史对话总结2026.02.15.15.05.md`
- `历史对话总结2026.02.17.14.38.md`
- `OpenClaw可视化面板_开发对接说明_v1.md`
- `Template-Debian-OpenClaw001.md`

## 使用规则

1. 本目录文档仅作背景参考，不替代 `plan/规格` 与任务目录中的正式方案文档。
2. 根目录发现同名资料时，保留本目录版本，删除根目录重复副本。
3. 文档更新后请在对应任务目录的 `任务清单.md` 记录变更原因，避免后续语义漂移。
</file>

<file path="plan/资料/Template-Debian-OpenClaw001.md">
# Template-Debian-OpenClaw001（VM 100）模板机档案

最后更新：2026-02-11

## 1. 目标/用途

- 作为 **Debian 13 Golden Image**，后续通过 **Linked Clone** 快速批量开通小鸡（目标规格：4C / 4G / 30G）。
- 运行场景：浏览器自动化（OpenClaw）、Node.js 脚本、Docker 容器。
- 性能要求：CPU 必须用 **`host`**（透传 AVX2 等指令集）。

## 2. 所属节点/环境

| 项目 | 值 |
|---|---|
| 物理宿主机 | Hetzner（德国机房） |
| 节点名 | `9900K-1` |
| 宿主机 CPU | i9-9900K |
| PVE UI 版本（从截图） | 9.1.5 |

## 3. VM 硬件配置（已创建）

| 配置项 | 参数 | 备注 |
|---|---|---|
| VMID / 名称 | `100` / `Template-Debian-OpenClaw001` | 模板机 |
| 机型 / BIOS | `i440fx` / `SeaBIOS` | 兼容优先 |
| CPU | 4 Cores / `host` | 必须 `host` |
| 内存 | 4096 MiB | 可配合 Ballooning |
| 磁盘 | 30G（SCSI0） | 开启 Discard/TRIM |
| 控制器 | `VirtIO SCSI single` | IO 性能优先 |
| QEMU Guest Agent | Enabled | 需在系统内安装 `qemu-guest-agent` 后才会运行 |
| 网卡 | VirtIO | 连接 `vmbr0` |

## 4. 网络（NAT：共享公网 IPv4 + 独立端口）

> 关键点：**小鸡没有独立公网 IPv4**；但每台小鸡必须有一个**固定内网 IP（10.10.10.x）**，宿主机才能把 `公网IP:端口` 转发到对应小鸡。

### 4.1 内网段（统一一个网段）

| 项目 | 值 |
|---|---|
| 虚拟网桥 | `vmbr0` |
| 网关（宿主机） | `10.10.10.1/24` |
| 地址获取方式 | 不用 DHCP：全部静态分配 |
| 本模板机内网 IP（确认） | `10.10.10.100/24` |

### 4.2 端口分配（计划）

| 项目 | 值 |
|---|---|
| 入口 | 共享公网 IPv4 + 每台小鸡独立端口段 |
| 每台小鸡端口数 | 50（由分配脚本执行） |
| 示例（SSH） | `公网IPv4:<分配端口>` → `10.10.10.100:22`（实际端口号以脚本分配为准） |
| 出口 | 计划：IPv4 入站 / IPv6 出站（由大哥的 WG + 策略路由方案实现） |

## 5. 隔离要求（强制）

- **小鸡之间必须完全隔离（east-west 禁止）**：默认不允许 `10.10.10.x ↔ 10.10.10.y` 互通。
- 允许的最小通信：小鸡 → 网关（`10.10.10.1`）用于 NAT/DNS/必要服务。
- 具体落地方式：PVE Firewall 或宿主机 `nftables/iptables` 规则（待实施/验收）。

## 6. 当前安装状态（写档时）

- Debian 13 安装进行中；安装器已出现 **DHCP 获取失败**（符合“无 DHCP + 静态内网”的预期）。
- 下一步在安装器网络配置中手动填写静态地址：`10.10.10.100/24`，网关 `10.10.10.1`（DNS 以宿主机实际配置为准）。
</file>

<file path="deploy/docker-update.sh">
#!/usr/bin/env bash
set -euo pipefail

ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
cd "$ROOT_DIR"
export COMPOSE_PROJECT_NAME="openclawpanel"

pull_with_retry() {
  local service="$1"
  local max_attempts="${2:-5}"
  local attempt

  for ((attempt=1; attempt<=max_attempts; attempt++)); do
    echo "拉取 ${service} 镜像（第 ${attempt}/${max_attempts} 次）..."
    if docker compose pull "$service"; then
      return 0
    fi
    if (( attempt < max_attempts )); then
      sleep $((attempt * 3))
    fi
  done

  return 1
}

if [[ $# -lt 1 ]]; then
  echo "用法: bash deploy/docker-update.sh <tag>"
  echo "示例: bash deploy/docker-update.sh v2026.2.14"
  exit 1
fi

if [[ ! -f ./.env ]]; then
  echo ".env 不存在，请先执行 bash deploy/docker-init.sh"
  exit 1
fi

tag="$1"
tag="${tag#v}"
new_image="ghcr.io/openclaw/openclaw:${tag}"

old_image="$(grep -E '^OPENCLAW_IMAGE=' ./.env | head -n1 | cut -d'=' -f2- || true)"
if [[ -z "$old_image" ]]; then
  old_image="ghcr.io/openclaw/openclaw:2026.2.14"
fi

backup_env="./.env.bak.$(date +%Y%m%d%H%M%S)"
cp ./.env "$backup_env"

if grep -q '^OPENCLAW_IMAGE=' ./.env; then
  sed -i "s|^OPENCLAW_IMAGE=.*$|OPENCLAW_IMAGE=${new_image}|g" ./.env
else
  echo "OPENCLAW_IMAGE=${new_image}" >> ./.env
fi

echo "准备升级:"
echo "  old: ${old_image}"
echo "  new: ${new_image}"

rollback_to_old() {
  echo "恢复到旧镜像: ${old_image}"
  sed -i "s|^OPENCLAW_IMAGE=.*$|OPENCLAW_IMAGE=${old_image}|g" ./.env
  pull_with_retry openclaw-gateway 5 || true
  docker compose up -d openclaw-gateway || true
}

echo "拉取新镜像..."
if ! pull_with_retry openclaw-gateway 5; then
  echo "新镜像拉取失败，自动回退配置。"
  rollback_to_old
  exit 1
fi

echo "重建网关容器..."
if ! docker compose up -d openclaw-gateway; then
  echo "网关重建失败，自动回滚。"
  rollback_to_old
  exit 1
fi

sleep 6
running="$(docker inspect --format '{{.State.Running}}' openclaw-gateway 2>/dev/null || true)"

if [[ "$running" != "true" ]]; then
  echo "升级失败，开始自动回滚到: ${old_image}"
  rollback_to_old
  echo "已回滚。"
  exit 1
fi

echo "升级成功: ${new_image}"
echo "如需回滚，可执行:"
echo "  bash deploy/docker-rollback.sh ${old_image##*:}"
echo "环境备份:"
echo "  ${backup_env}"
</file>

<file path="deploy/openclaw-panel.service">
[Unit]
Description=OpenClaw Visual Panel
After=network.target

[Service]
Type=simple
User=root
WorkingDirectory=/opt/openclaw-panel
ExecStart=/usr/bin/node /opt/openclaw-panel/src/server.js
Restart=always
RestartSec=3
Environment=PANEL_CONFIG_PATH=/etc/openclaw-panel/panel.config.json

[Install]
WantedBy=multi-user.target
</file>

<file path="public/js/pages/chat-page.js">
import { api, chatConsoleState, getInputValue, setInput, setMessage } from "../core/panel-core.js";

function setChatStreamStatus(text) {
  setInput("chat_stream_status", text || "");
}

function setChatComposerSending(sending) {
  chatConsoleState.sending = Boolean(sending);
  const sendButton = document.querySelector("#chat_send_message");
  const abortButton = document.querySelector("#chat_abort_run");
  if (sendButton) {
    sendButton.disabled = chatConsoleState.sending;
    sendButton.textContent = chatConsoleState.sending ? "发送中..." : "发送消息";
  }
  if (abortButton) {
    abortButton.disabled = !chatConsoleState.sending;
  }
}

function setChatAttachmentHint(text) {
  const hint = document.querySelector("#chat_attachment_hint");
  if (!hint) {
    return;
  }
  hint.textContent = String(text || "").trim() || "支持点击上传、粘贴或拖拽文件（图片会显示预览）";
}

function setChatInlineHint(text, type = "") {
  const hint = document.querySelector("#chat_inline_hint");
  if (!hint) {
    return;
  }
  hint.textContent = String(text || "").trim();
  hint.classList.remove("error", "ok");
  if (type === "error") {
    hint.classList.add("error");
  } else if (type === "ok") {
    hint.classList.add("ok");
  }
}

function reportChatActionError(error, fallback = "操作失败") {
  const message = String(error?.message || error || "").trim() || fallback;
  setChatInlineHint(message, "error");
  setMessage(message, "error");
}

function formatFileSize(bytes) {
  const size = Number(bytes || 0);
  if (!Number.isFinite(size) || size <= 0) {
    return "-";
  }
  if (size < 1024) {
    return `${size} B`;
  }
  if (size < 1024 * 1024) {
    return `${(size / 1024).toFixed(1)} KB`;
  }
  return `${(size / (1024 * 1024)).toFixed(2)} MB`;
}

function renderChatAttachments() {
  const container = document.querySelector("#chat_attachment_list");
  if (!container) {
    return;
  }
  container.innerHTML = "";
  const items = Array.isArray(chatConsoleState.attachments) ? chatConsoleState.attachments : [];
  if (items.length === 0) {
    const empty = document.createElement("div");
    empty.className = "chat-empty";
    empty.textContent = "当前没有附件";
    container.appendChild(empty);
    return;
  }

  items.forEach((item, index) => {
    const node = document.createElement("div");
    node.className = "chat-attachment-item";

    const row = document.createElement("div");
    row.className = "chat-attachment-row";

    const info = document.createElement("div");
    const name = document.createElement("div");
    name.className = "chat-attachment-name";
    name.textContent = String(item.fileName || "file");
    const meta = document.createElement("div");
    meta.className = "chat-attachment-meta";
    meta.textContent = `${String(item.mimeType || "application/octet-stream")} | ${formatFileSize(item.fileSize)}`;
    info.appendChild(name);
    info.appendChild(meta);

    const removeBtn = document.createElement("button");
    removeBtn.type = "button";
    removeBtn.className = "btn-soft";
    removeBtn.dataset.attachmentIndex = String(index);
    removeBtn.textContent = "移除";

    row.appendChild(info);
    row.appendChild(removeBtn);
    node.appendChild(row);

    if (item.preview && String(item.mimeType || "").startsWith("image/")) {
      const image = document.createElement("img");
      image.className = "chat-attachment-preview";
      image.src = item.preview;
      image.alt = String(item.fileName || "image");
      node.appendChild(image);
    }
    container.appendChild(node);
  });
}

function removeChatAttachmentByIndex(index) {
  if (!Array.isArray(chatConsoleState.attachments)) {
    return;
  }
  if (!Number.isInteger(index) || index < 0 || index >= chatConsoleState.attachments.length) {
    return;
  }
  chatConsoleState.attachments.splice(index, 1);
  renderChatAttachments();
  setChatAttachmentHint(`已移除附件，当前 ${chatConsoleState.attachments.length} 个`);
}

function fileToBase64(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => {
      const raw = String(reader.result || "");
      const match = raw.match(/^data:[^;]+;base64,(.+)$/i);
      resolve(match ? match[1] : raw);
    };
    reader.onerror = () => {
      reject(new Error(`读取文件失败：${file?.name || "unknown"}`));
    };
    reader.readAsDataURL(file);
  });
}

async function stageChatFile(file) {
  const fileName = String(file?.name || "").trim() || "file";
  const mimeType = String(file?.type || "").trim() || "application/octet-stream";
  const base64 = await fileToBase64(file);
  const response = await api("/api/chat/attachments/stage", {
    method: "POST",
    body: JSON.stringify({
      fileName,
      mimeType,
      base64
    })
  });
  return response?.result && typeof response.result === "object" ? response.result : null;
}

async function stageChatFiles(files) {
  const list = Array.from(files || []).filter(Boolean);
  if (list.length === 0) {
    return;
  }
  if (chatConsoleState.staging) {
    setChatAttachmentHint("附件还在处理中，请稍候再操作");
    return;
  }
  chatConsoleState.staging = true;
  setChatAttachmentHint(`正在处理附件（${list.length} 个）...`);
  try {
    for (const file of list) {
      const staged = await stageChatFile(file);
      if (!staged) {
        continue;
      }
      const stagedPath = String(staged.stagedPath || "").trim();
      if (!stagedPath) {
        continue;
      }
      const existedIndex = chatConsoleState.attachments.findIndex((item) => item.stagedPath === stagedPath);
      if (existedIndex >= 0) {
        chatConsoleState.attachments[existedIndex] = staged;
      } else {
        chatConsoleState.attachments.push(staged);
      }
    }
    renderChatAttachments();
    setChatAttachmentHint(`附件已就绪：${chatConsoleState.attachments.length} 个`);
  } finally {
    chatConsoleState.staging = false;
  }
}

function renderChatStreamLines() {
  const output = document.querySelector("#chat_stream_output");
  if (!output) {
    return;
  }
  output.textContent = chatConsoleState.streamLines.length > 0 ? chatConsoleState.streamLines.join("\n") : "等待流式事件...";
}

function pushChatStreamLine(text) {
  const line = `[${new Date().toLocaleTimeString()}] ${text}`;
  chatConsoleState.streamLines.push(line);
  if (chatConsoleState.streamLines.length > 300) {
    chatConsoleState.streamLines = chatConsoleState.streamLines.slice(-300);
  }
  renderChatStreamLines();
}

function resetChatStreamOutput() {
  chatConsoleState.streamLines = [];
  chatConsoleState.streamDeltasByRunId = {};
  chatConsoleState.streamThinkingByRunId = {};
  renderChatStreamLines();
  renderChatMessageList();
}

function closeChatStreamSource() {
  if (chatConsoleState.streamSource) {
    chatConsoleState.streamSource.close();
    chatConsoleState.streamSource = null;
  }
  chatConsoleState.streamSessionKey = "";
}

function extractStreamTextFromMessage(message) {
  if (!message || typeof message !== "object") {
    return "";
  }
  const content = Array.isArray(message?.content) ? message.content : [];
  return content
    .map((part) => {
      if (!part || typeof part !== "object") {
        return "";
      }
      return typeof part.text === "string" ? part.text : "";
    })
    .join("");
}

function normalizeChatContent(content) {
  if (typeof content === "string") {
    return content;
  }
  if (Array.isArray(content)) {
    return content
      .map((entry) => {
        if (typeof entry === "string") {
          return entry;
        }
        if (!entry || typeof entry !== "object") {
          return "";
        }
        if (entry.type === "toolCall" || entry.type === "tool_call") {
          const toolName = String(entry.name || entry.tool || "unknown");
          const args =
            typeof entry.arguments === "string"
              ? entry.arguments
              : JSON.stringify(entry.arguments ?? entry.partialJson ?? {}, null, 2);
          return `[工具调用] ${toolName}\n参数:\n${args}`;
        }
        if (entry.type === "toolResult" || entry.type === "tool_result") {
          const resultText =
            typeof entry.text === "string"
              ? entry.text
              : JSON.stringify(entry.details ?? entry.result ?? entry, null, 2);
          return `[工具结果]\n${resultText}`;
        }
        if (typeof entry.text === "string") {
          return entry.text;
        }
        if (typeof entry.content === "string") {
          return entry.content;
        }
        return JSON.stringify(entry);
      })
      .filter(Boolean)
      .join("\n");
  }
  if (content && typeof content === "object") {
    if (typeof content.text === "string") {
      return content.text;
    }
    return JSON.stringify(content);
  }
  return String(content ?? "");
}

function escapeHtml(value) {
  return String(value ?? "")
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#39;");
}

function renderRichTextSegment(segment) {
  let html = escapeHtml(segment);
  html = html.replace(/\*\*([^\n*]+)\*\*/g, "<strong>$1</strong>");
  html = html.replace(/`([^`\n]+)`/g, "<code>$1</code>");
  html = html.replace(/\n/g, "<br>");
  return `<span>${html}</span>`;
}

function renderRichMessageBody(text) {
  const source = String(text || "");
  if (!source) {
    return "<span>(空消息)</span>";
  }
  const parts = source.split("```");
  return parts
    .map((part, index) => {
      if (index % 2 === 0) {
        return renderRichTextSegment(part);
      }
      const firstBreak = part.indexOf("\n");
      let codeLang = "";
      let codeBody = part;
      if (firstBreak >= 0) {
        codeLang = part.slice(0, firstBreak).trim();
        codeBody = part.slice(firstBreak + 1);
      }
      const langAttr = codeLang ? ` data-lang="${escapeHtml(codeLang)}"` : "";
      return `<pre class="chat-code"><code${langAttr}>${escapeHtml(codeBody)}</code></pre>`;
    })
    .join("");
}

function formatChatRole(role) {
  const normalized = String(role || "").trim().toLowerCase();
  if (normalized === "user") {
    return "你";
  }
  if (normalized === "assistant") {
    return "助手";
  }
  if (normalized === "system") {
    return "系统";
  }
  if (
    normalized === "tool" ||
    normalized === "tool_use" ||
    normalized === "tool_result" ||
    normalized === "toolresult" ||
    normalized === "toolcall"
  ) {
    return "工具";
  }
  return normalized || "未知";
}

function normalizeChatMessage(message = {}, index = 0) {
  const role = String(message?.role || message?.author || message?.type || "assistant").trim().toLowerCase() || "assistant";
  const status = String(message?.status || "").trim();
  const thinking = String(
    message?.thinkingState || message?.thinking || message?.reasoning || message?.reasoningEffort || ""
  ).trim();
  const body = normalizeChatContent(
    message?.content ?? message?.parts ?? message?.message ?? message?.delta ?? message?.text ?? ""
  );
  const attachments = Array.isArray(message?._attachedFiles)
    ? message._attachedFiles
        .map((entry) => ({
          fileName: String(entry?.fileName || "").trim(),
          mimeType: String(entry?.mimeType || "").trim() || "application/octet-stream",
          fileSize: Number(entry?.fileSize || 0) || 0,
          preview: String(entry?.preview || "").trim() || ""
        }))
        .filter((entry) => entry.fileName)
    : [];
  return {
    id: `history-${index + 1}`,
    role,
    status,
    thinking,
    body: body || "(空消息)",
    timestamp: message?.timestamp || message?.createdAt || message?.at || "",
    attachments
  };
}

function createChatMessageNode(item, { streaming = false, showThinking = true } = {}) {
  const node = document.createElement("div");
  const role = String(item?.role || "assistant").toLowerCase();
  node.className = `chat-message ${role === "user" ? "user" : "assistant"}${streaming ? " streaming" : ""}`;

  const header = document.createElement("div");
  header.className = "chat-message-header";

  const roleEl = document.createElement("span");
  roleEl.className = "chat-role";
  roleEl.textContent = formatChatRole(role);
  header.appendChild(roleEl);

  const metaEl = document.createElement("span");
  metaEl.textContent = streaming ? "实时生成中..." : String(item?.status || "").trim() || "";
  header.appendChild(metaEl);

  node.appendChild(header);

  if (showThinking && String(item?.thinking || "").trim()) {
    const thinkingEl = document.createElement("span");
    thinkingEl.className = "chat-thinking";
    thinkingEl.textContent = `思考：${item.thinking}`;
    node.appendChild(thinkingEl);
  }

  const body = document.createElement("div");
  body.className = "chat-message-body";
  const bodyText = String(item?.body || "").trim() || "(空消息)";
  const shouldRenderRich =
    role === "assistant" || role === "system" || role === "tool" || role === "toolresult" || role === "toolcall";
  if (shouldRenderRich) {
    body.innerHTML = renderRichMessageBody(bodyText);
  } else {
    body.textContent = bodyText;
  }
  node.appendChild(body);

  const files = Array.isArray(item?.attachments) ? item.attachments : [];
  if (files.length > 0) {
    const fileList = document.createElement("div");
    fileList.className = "chip-line";
    files.forEach((entry) => {
      const chip = document.createElement("span");
      chip.className = "mini-chip";
      chip.textContent = `${String(entry?.fileName || "file")} (${formatFileSize(entry?.fileSize)})`;
      fileList.appendChild(chip);
    });
    node.appendChild(fileList);
  }
  return node;
}

function renderChatMessageList() {
  const container = document.querySelector("#chat_messages");
  if (!container) {
    return;
  }
  const showThinking = Boolean(getInputValue("chat_show_thinking"));
  container.innerHTML = "";

  const items = Array.isArray(chatConsoleState.historyMessages) ? chatConsoleState.historyMessages : [];
  items.forEach((item) => {
    container.appendChild(createChatMessageNode(item, { showThinking }));
  });

  Object.entries(chatConsoleState.streamDeltasByRunId).forEach(([runId, text]) => {
    const thinking = String(chatConsoleState.streamThinkingByRunId[runId] || "").trim();
    container.appendChild(
      createChatMessageNode(
        {
          role: "assistant",
          status: runId ? `runId: ${runId}` : "",
          thinking,
          body: String(text || "").trim() || "正在生成..."
        },
        { streaming: true, showThinking }
      )
    );
  });

  if (container.childElementCount === 0) {
    const empty = document.createElement("div");
    empty.className = "chat-empty";
    empty.textContent = "请选择会话后开始对话";
    container.appendChild(empty);
  }

  container.scrollTop = container.scrollHeight;
}

function renderChatHistory(history = {}) {
  const output = document.querySelector("#chat_history_output");
  if (!output) {
    return;
  }
  const sessionKey = String(history.sessionKey || chatConsoleState.selectedSessionKey || "").trim();
  const sessionId = String(history.sessionId || "").trim();
  const thinkingLevel = String(history.thinkingLevel || "").trim();
  const verboseLevel = String(history.verboseLevel || "").trim();
  const messages = Array.isArray(history.messages) ? history.messages : [];

  const lines = [];
  lines.push(`sessionKey: ${sessionKey || "-"}`);
  lines.push(`sessionId: ${sessionId || "-"}`);
  lines.push(`thinkingLevel: ${thinkingLevel || "-"}`);
  lines.push(`verboseLevel: ${verboseLevel || "-"}`);
  lines.push(`messages: ${messages.length}`);

  chatConsoleState.historyMessages = messages.map((message, index) => normalizeChatMessage(message, index));
  renderChatMessageList();

  messages.forEach((message, index) => {
    const role = String(message?.role || message?.author || message?.type || "unknown").trim() || "unknown";
    const status = String(message?.status || "").trim();
    const thinkingState = String(
      message?.thinkingState || message?.thinking || message?.reasoning || message?.reasoningEffort || ""
    ).trim();
    const content = normalizeChatContent(
      message?.content ?? message?.parts ?? message?.message ?? message?.delta ?? message?.text ?? ""
    );

    lines.push("");
    lines.push(`#${index + 1} ${role}${status ? ` [${status}]` : ""}`);
    if (thinkingState) {
      lines.push(`思考状态: ${thinkingState}`);
    }
    lines.push(content || "(empty)");
  });

  output.textContent = lines.join("\n");
}

function handleChatStreamEvent(payload) {
  const data = payload && typeof payload === "object" ? payload : {};
  const state = String(data.state || "").trim();
  const runId = String(data.runId || "").trim();
  const sessionKey = String(data.sessionKey || "").trim();
  if (runId) {
    chatConsoleState.lastRunId = runId;
    setInput("chat_last_run_id", runId);
  }

  const deltaChunk = extractStreamTextFromMessage(data.message);
  if (state === "delta") {
    if (runId) {
      const previous = String(chatConsoleState.streamDeltasByRunId[runId] || "");
      chatConsoleState.streamDeltasByRunId[runId] = previous + deltaChunk;
    }
    pushChatStreamLine(`[chat:${state}] ${runId || "-"} ${deltaChunk || "(empty-delta)"}`);
    renderChatMessageList();
    return;
  }

  if (state === "final") {
    const mergedText = runId ? String(chatConsoleState.streamDeltasByRunId[runId] || "") : "";
    const finalChunk = deltaChunk || mergedText || "(empty)";
    pushChatStreamLine(`[chat:final] ${runId || "-"} ${finalChunk}`);
    if (runId) {
      delete chatConsoleState.streamDeltasByRunId[runId];
      delete chatConsoleState.streamThinkingByRunId[runId];
    }
    setChatComposerSending(false);
    renderChatMessageList();
    if (sessionKey) {
      loadChatHistory({ sessionKey, silent: true }).catch(() => {});
    }
    return;
  }

  if (state === "aborted" || state === "error") {
    const reason = String(data.stopReason || data.errorMessage || "").trim();
    pushChatStreamLine(`[chat:${state}] ${runId || "-"} ${reason || "-"}`);
    if (runId) {
      delete chatConsoleState.streamDeltasByRunId[runId];
      delete chatConsoleState.streamThinkingByRunId[runId];
    }
    setChatComposerSending(false);
    renderChatMessageList();
    if (sessionKey) {
      loadChatHistory({ sessionKey, silent: true }).catch(() => {});
    }
    return;
  }

  pushChatStreamLine(`[chat:${state || "unknown"}] ${runId || "-"} seq=${data.seq ?? "-"}`);
}

function handleAgentStreamEvent(payload) {
  const data = payload && typeof payload === "object" ? payload : {};
  const stream = String(data.stream || "").trim() || "-";
  const phase = String(data.phase || "").trim() || "-";
  const runId = String(data.runId || "").trim() || "-";
  pushChatStreamLine(`[agent:${stream}] ${runId} phase=${phase}`);
  if (runId !== "-") {
    chatConsoleState.streamThinkingByRunId[runId] = phase;
    renderChatMessageList();
  }
}

function connectChatStream(sessionKey, { silent = false, force = false } = {}) {
  const normalizedSessionKey = String(sessionKey || chatConsoleState.selectedSessionKey || "").trim();
  if (!normalizedSessionKey) {
    setChatStreamStatus("未连接（未选择会话）");
    return;
  }
  if (!force && chatConsoleState.streamSource && chatConsoleState.streamSessionKey === normalizedSessionKey) {
    return;
  }

  closeChatStreamSource();
  chatConsoleState.streamSessionKey = normalizedSessionKey;
  resetChatStreamOutput();
  setChatStreamStatus(`连接中 (${normalizedSessionKey})`);
  if (!silent) {
    setMessage(`实时通道连接中：${normalizedSessionKey}`, "info");
  }

  const query = new URLSearchParams({
    sessionKey: normalizedSessionKey,
    includeAgent: "true"
  });
  const source = new EventSource(`/api/chat/stream?${query.toString()}`);
  chatConsoleState.streamSource = source;

  source.addEventListener("ready", (event) => {
    try {
      const payload = JSON.parse(event.data || "{}");
      setChatStreamStatus(`已建立 (${payload.sessionKey || normalizedSessionKey})`);
      pushChatStreamLine(`[stream:ready] session=${payload.sessionKey || normalizedSessionKey}`);
    } catch {
      setChatStreamStatus("已建立");
    }
  });

  source.addEventListener("status", (event) => {
    try {
      const payload = JSON.parse(event.data || "{}");
      const state = String(payload.state || "").trim();
      if (state === "connected") {
        setChatStreamStatus(`已连接 (${payload.sessionKey || normalizedSessionKey})`);
      } else if (state === "reconnecting") {
        setChatStreamStatus(`重连中（第${payload.attempt || 1}次）`);
      } else if (state === "connect-failed") {
        setChatStreamStatus("连接失败，自动重试中");
      } else if (state === "gateway-closed") {
        setChatStreamStatus("网关断开，自动重连中");
      } else {
        setChatStreamStatus(state || "状态更新");
      }
      pushChatStreamLine(`[stream:${state || "status"}] ${payload.reason || payload.message || ""}`.trim());
    } catch {
      setChatStreamStatus("状态更新");
    }
  });

  source.addEventListener("chat", (event) => {
    try {
      handleChatStreamEvent(JSON.parse(event.data || "{}"));
    } catch (error) {
      pushChatStreamLine(`[stream:parse-error] ${error.message || String(error)}`);
    }
  });

  source.addEventListener("agent", (event) => {
    try {
      handleAgentStreamEvent(JSON.parse(event.data || "{}"));
    } catch (error) {
      pushChatStreamLine(`[stream:parse-error] ${error.message || String(error)}`);
    }
  });

  source.addEventListener("stream-error", (event) => {
    try {
      const payload = JSON.parse(event.data || "{}");
      pushChatStreamLine(`[stream:error] ${payload.message || "unknown error"}`);
      setChatComposerSending(false);
    } catch {
      pushChatStreamLine("[stream:error] unknown error");
      setChatComposerSending(false);
    }
  });

  source.addEventListener("error", () => {
    setChatStreamStatus("连接波动，浏览器重连中");
  });
}

function renderChatSessionSelect() {
  const select = document.querySelector("#chat_session_select");
  if (!select) {
    return;
  }
  const sessions = Array.isArray(chatConsoleState.sessions) ? chatConsoleState.sessions : [];
  select.innerHTML = "";
  if (sessions.length === 0) {
    const emptyOption = document.createElement("option");
    emptyOption.value = "";
    emptyOption.textContent = "暂无会话";
    select.appendChild(emptyOption);
    select.value = "";
    return;
  }

  sessions.forEach((session) => {
    const option = document.createElement("option");
    option.value = session?.key || "";
    const ctx = Number(session?.contextTokens || 0);
    const model = String(session?.model || "-");
    const name = String(session?.displayName || session?.key || "未命名会话");
    option.textContent = `${name} | ${model} | ctx ${ctx > 0 ? ctx.toLocaleString() : "-"}`;
    select.appendChild(option);
  });

  if (chatConsoleState.selectedSessionKey && sessions.some((item) => item?.key === chatConsoleState.selectedSessionKey)) {
    select.value = chatConsoleState.selectedSessionKey;
  } else {
    select.selectedIndex = 0;
    chatConsoleState.selectedSessionKey = String(select.value || "").trim();
  }
}

async function loadChatSessions({ silent = false, preserveSelection = true, selectedSessionKey = "" } = {}) {
  const response = await api("/api/chat/sessions");
  const result = response?.result && typeof response.result === "object" ? response.result : {};
  const sessions = Array.isArray(result.sessions) ? result.sessions : [];
  const previous = String(chatConsoleState.selectedSessionKey || "").trim();
  const requested = String(selectedSessionKey || "").trim();
  chatConsoleState.sessions = sessions;

  if (requested && sessions.some((item) => item?.key === requested)) {
    chatConsoleState.selectedSessionKey = requested;
  } else if (preserveSelection && previous && sessions.some((item) => item?.key === previous)) {
    chatConsoleState.selectedSessionKey = previous;
  } else {
    chatConsoleState.selectedSessionKey = String(sessions[0]?.key || "").trim();
  }

  chatConsoleState.attachments = [];
  renderChatAttachments();
  setChatAttachmentHint("支持点击上传、粘贴或拖拽文件（图片会显示预览）");

  renderChatSessionSelect();
  if (chatConsoleState.selectedSessionKey) {
    connectChatStream(chatConsoleState.selectedSessionKey, { silent: true });
    await loadChatHistory({
      sessionKey: chatConsoleState.selectedSessionKey,
      silent: true
    });
  } else {
    closeChatStreamSource();
    setChatStreamStatus("未连接（暂无会话）");
    chatConsoleState.historyMessages = [];
    renderChatMessageList();
    setChatComposerSending(false);
    const output = document.querySelector("#chat_history_output");
    if (output) {
      output.textContent = "暂无会话可展示";
    }
  }
  if (!silent) {
    setMessage(`会话列表刷新完成，共 ${sessions.length} 条`, "ok");
  }
  if (silent) {
    setChatInlineHint("");
  }
}

async function loadChatHistory({ sessionKey = "", silent = false } = {}) {
  const normalizedSessionKey = String(sessionKey || chatConsoleState.selectedSessionKey || "").trim();
  if (!normalizedSessionKey) {
    throw new Error("请先选择会话");
  }
  chatConsoleState.selectedSessionKey = normalizedSessionKey;
  const query = new URLSearchParams({
    sessionKey: normalizedSessionKey,
    limit: "200"
  });
  const response = await api(`/api/chat/history?${query.toString()}`);
  const result = response?.result && typeof response.result === "object" ? response.result : {};
  renderChatHistory({
    ...result,
    sessionKey: normalizedSessionKey
  });
  if (!silent) {
    setMessage(`会话历史刷新完成：${normalizedSessionKey}`, "ok");
  }
}

async function createChatSession() {
  const response = await api("/api/chat/session/new", {
    method: "POST",
    body: JSON.stringify({})
  });
  const result = response?.result && typeof response.result === "object" ? response.result : {};
  const sessionKey = String(result.key || "").trim();
  if (!sessionKey) {
    throw new Error("新建会话失败：未返回会话 key");
  }
  await loadChatSessions({
    silent: true,
    preserveSelection: false,
    selectedSessionKey: sessionKey
  });
  setChatInlineHint("新会话创建成功", "ok");
  setMessage(`已创建新会话：${sessionKey}`, "ok");
}

async function sendChatConsoleMessage() {
  const sessionKey = String(getInputValue("chat_session_select") || chatConsoleState.selectedSessionKey || "").trim();
  const message = String(getInputValue("chat_message_input") || "").trim();
  const attachments = Array.isArray(chatConsoleState.attachments) ? [...chatConsoleState.attachments] : [];
  if (!sessionKey) {
    throw new Error("请先选择会话");
  }
  if (!message && attachments.length === 0) {
    throw new Error("请输入消息或添加至少一个附件");
  }
  if (chatConsoleState.sending) {
    throw new Error("当前正在生成回复，请稍候或先点击“停止回复”");
  }
  if (chatConsoleState.staging) {
    throw new Error("附件仍在处理中，请稍候再发送");
  }

  const payload = {
    sessionKey,
    message,
    thinking: String(getInputValue("chat_thinking_level") || "").trim(),
    idempotencyKey: String(getInputValue("chat_idempotency_key") || "").trim(),
    attachments: attachments.map((item) => ({
      fileName: String(item?.fileName || "").trim() || "file",
      mimeType: String(item?.mimeType || "").trim() || "application/octet-stream",
      fileSize: Number(item?.fileSize || 0) || 0,
      stagedPath: String(item?.stagedPath || "").trim(),
      preview: String(item?.preview || "").trim() || ""
    }))
  };
  if (payload.attachments.some((item) => !item.stagedPath)) {
    throw new Error("存在未完成的附件，请重新添加后再发送");
  }

  const optimisticMessage = {
    id: `local-user-${Date.now()}`,
    role: "user",
    status: payload.attachments.length > 0 ? `附件 ${payload.attachments.length} 个` : "",
    thinking: "",
    body: message || "(仅附件)",
    attachments: payload.attachments
      .map((item) => ({
        fileName: item.fileName,
        mimeType: item.mimeType,
        fileSize: item.fileSize,
        preview: item.preview
      }))
      .filter((item) => item.fileName)
  };
  chatConsoleState.historyMessages.push(optimisticMessage);
  chatConsoleState.attachments = [];
  renderChatAttachments();
  setChatAttachmentHint("支持点击上传、粘贴或拖拽文件（图片会显示预览）");
  setInput("chat_message_input", "");
  setInput("chat_file_input", "");

  chatConsoleState.streamDeltasByRunId = {};
  chatConsoleState.streamThinkingByRunId = {};
  renderChatMessageList();

  setChatComposerSending(true);
  connectChatStream(sessionKey, { silent: true });
  try {
    const response = await api("/api/chat/send", {
      method: "POST",
      body: JSON.stringify(payload)
    });
    const result = response?.result && typeof response.result === "object" ? response.result : {};
    chatConsoleState.lastRunId = String(result.runId || "").trim();
    setInput("chat_last_run_id", chatConsoleState.lastRunId);
    if (!chatConsoleState.lastRunId) {
      setChatComposerSending(false);
    }
    setMessage(
      payload.attachments.length > 0
        ? `消息和附件已发送（status=${result.status || "unknown"}，附件=${payload.attachments.length}）`
        : `消息已发送（status=${result.status || "unknown"}）`,
      "ok"
    );
    setChatInlineHint("消息已发送，正在等待回复...", "ok");
  } catch (error) {
    setChatComposerSending(false);
    chatConsoleState.historyMessages = chatConsoleState.historyMessages.filter((item) => item.id !== optimisticMessage.id);
    chatConsoleState.attachments = attachments;
    renderChatAttachments();
    renderChatMessageList();
    throw error;
  }
}

function setupChatAttachmentInput() {
  const fileInput = document.querySelector("#chat_file_input");
  const pickBtn = document.querySelector("#chat_pick_files");
  const attachmentList = document.querySelector("#chat_attachment_list");
  const messageInput = document.querySelector("#chat_message_input");

  pickBtn?.addEventListener("click", () => {
    fileInput?.click();
  });

  fileInput?.addEventListener("change", () => {
    const files = Array.from(fileInput.files || []);
    if (files.length === 0) {
      return;
    }
    stageChatFiles(files).catch((error) => reportChatActionError(error, "附件处理失败"));
    fileInput.value = "";
  });

  attachmentList?.addEventListener("click", (event) => {
    const target = event.target;
    if (!(target instanceof HTMLElement)) {
      return;
    }
    const idx = Number.parseInt(String(target.dataset.attachmentIndex || ""), 10);
    if (Number.isInteger(idx)) {
      removeChatAttachmentByIndex(idx);
    }
  });

  const dragTargets = [messageInput, attachmentList].filter(Boolean);
  dragTargets.forEach((node) => {
    node.addEventListener("dragover", (event) => {
      event.preventDefault();
      attachmentList?.classList.add("is-dragover");
    });
    node.addEventListener("dragleave", () => {
      attachmentList?.classList.remove("is-dragover");
    });
    node.addEventListener("drop", (event) => {
      event.preventDefault();
      attachmentList?.classList.remove("is-dragover");
      const files = Array.from(event.dataTransfer?.files || []);
      if (files.length > 0) {
        stageChatFiles(files).catch((error) => reportChatActionError(error, "附件处理失败"));
      }
    });
  });

  messageInput?.addEventListener("paste", (event) => {
    const files = Array.from(event.clipboardData?.files || []);
    if (files.length === 0) {
      return;
    }
    event.preventDefault();
    stageChatFiles(files).catch((error) => reportChatActionError(error, "附件处理失败"));
  });
}

async function abortChatConsoleRun() {
  const sessionKey = String(getInputValue("chat_session_select") || chatConsoleState.selectedSessionKey || "").trim();
  if (!sessionKey) {
    throw new Error("请先选择会话");
  }
  const runId = String(getInputValue("chat_last_run_id") || "").trim();
  const response = await api("/api/chat/abort", {
    method: "POST",
    body: JSON.stringify({
      sessionKey,
      runId
    })
  });
  const result = response?.result && typeof response.result === "object" ? response.result : {};
  const runIds = Array.isArray(result.runIds) ? result.runIds : [];
  setChatComposerSending(false);
  setMessage(
    result.aborted ? `已发送中止请求，runIds=${runIds.join(",") || "-"}` : "当前没有可中止的运行任务",
    result.aborted ? "ok" : "info"
  );
  setChatInlineHint(result.aborted ? "已发送停止请求" : "当前没有可停止的任务", result.aborted ? "ok" : "");
  await loadChatHistory({ sessionKey, silent: true }).catch(() => {});
}

async function resetChatConsoleSession() {
  const sessionKey = String(getInputValue("chat_session_select") || chatConsoleState.selectedSessionKey || "").trim();
  if (!sessionKey) {
    throw new Error("请先选择会话");
  }
  await api("/api/chat/session/reset", {
    method: "POST",
    body: JSON.stringify({
      sessionKey,
      reason: "reset"
    })
  });
  chatConsoleState.lastRunId = "";
  setInput("chat_last_run_id", "");
  setChatComposerSending(false);
  chatConsoleState.streamDeltasByRunId = {};
  chatConsoleState.streamThinkingByRunId = {};
  chatConsoleState.attachments = [];
  renderChatAttachments();
  setChatAttachmentHint("支持点击上传、粘贴或拖拽文件（图片会显示预览）");
  renderChatMessageList();
  setMessage(`会话已重置：${sessionKey}`, "ok");
  setChatInlineHint("会话已清空", "ok");
  await loadChatHistory({ sessionKey, silent: true }).catch(() => {});
}

function setupChatConsole() {
  if (chatConsoleState.bound) {
    return;
  }
  chatConsoleState.bound = true;
  setChatStreamStatus("未连接");
  setChatComposerSending(false);
  renderChatAttachments();
  setChatAttachmentHint("支持点击上传、粘贴或拖拽文件（图片会显示预览）");
  setChatInlineHint("");
  setupChatAttachmentInput();
  const sessionSelect = document.querySelector("#chat_session_select");
  sessionSelect?.addEventListener("change", () => {
    const selected = String(sessionSelect.value || "").trim();
    chatConsoleState.selectedSessionKey = selected;
    setChatComposerSending(false);
    chatConsoleState.attachments = [];
    renderChatAttachments();
    setChatAttachmentHint("支持点击上传、粘贴或拖拽文件（图片会显示预览）");
    connectChatStream(selected, { silent: true, force: true });
    loadChatHistory({ sessionKey: selected }).catch((error) => setMessage(error.message || String(error), "error"));
  });

  document.querySelector("#chat_new_session")?.addEventListener("click", () => {
    createChatSession().catch((error) => reportChatActionError(error, "新建会话失败"));
  });
  document.querySelector("#chat_refresh_sessions")?.addEventListener("click", () => {
    loadChatSessions()
      .then(() => setChatInlineHint("会话列表已刷新", "ok"))
      .catch((error) => reportChatActionError(error, "刷新会话失败"));
  });
  document.querySelector("#chat_load_history")?.addEventListener("click", () => {
    loadChatHistory()
      .then(() => setChatInlineHint("会话历史已刷新", "ok"))
      .catch((error) => reportChatActionError(error, "刷新历史失败"));
  });
  document.querySelector("#chat_reconnect_stream")?.addEventListener("click", () => {
    connectChatStream(chatConsoleState.selectedSessionKey, { force: true });
    setChatInlineHint("已触发实时通道重连", "ok");
  });
  document.querySelector("#chat_send_message")?.addEventListener("click", () => {
    sendChatConsoleMessage().catch((error) => reportChatActionError(error, "发送失败"));
  });
  const messageInput = document.querySelector("#chat_message_input");
  messageInput?.addEventListener("keydown", (event) => {
    if (event.key === "Enter" && !event.shiftKey) {
      event.preventDefault();
      sendChatConsoleMessage().catch((error) => reportChatActionError(error, "发送失败"));
    }
  });
  document.querySelector("#chat_show_thinking")?.addEventListener("change", () => {
    renderChatMessageList();
  });
  document.querySelector("#chat_abort_run")?.addEventListener("click", () => {
    abortChatConsoleRun().catch((error) => reportChatActionError(error, "停止失败"));
  });
  document.querySelector("#chat_reset_session")?.addEventListener("click", () => {
    resetChatConsoleSession().catch((error) => reportChatActionError(error, "重置会话失败"));
  });

  window.addEventListener("beforeunload", () => {
    closeChatStreamSource();
  });
}


export {
  loadChatSessions,
  setupChatConsole
};
</file>

<file path="public/js/pages/skills-page.js">
import { api, getInputValue, setInput, setMessage, setText, skillsPageState } from "../core/panel-core.js";

function truncateText(value, max = 72) {
  const text = String(value || "").trim();
  if (!text) {
    return "-";
  }
  if (text.length <= max) {
    return text;
  }
  return `${text.slice(0, max - 1)}…`;
}

function setSkillsSaveResult(text, mode = "") {
  const result = document.querySelector("#skills_save_result");
  if (!result) {
    return;
  }
  result.textContent = text;
  result.classList.toggle("success", mode === "success");
  result.classList.toggle("fail", mode === "fail");
}

function resetSkillEditForm() {
  setInput("skills_edit_enabled", false);
  setInput("skills_edit_apikey", "");
  setInput("skills_edit_clear_apikey", false);
  setInput("skills_edit_env", "");
  setSkillsSaveResult("选择一个 Skill 后可编辑配置。", "");
}

function parseSkillEnvPatch(rawText) {
  const text = String(rawText || "").trim();
  if (!text) {
    return {};
  }
  let parsed;
  try {
    parsed = JSON.parse(text);
  } catch {
    throw new Error("环境变量 JSON 格式不合法");
  }
  if (!parsed || typeof parsed !== "object" || Array.isArray(parsed)) {
    throw new Error("环境变量必须是对象 JSON");
  }
  const normalized = {};
  Object.entries(parsed).forEach(([key, value]) => {
    const name = String(key || "").trim();
    if (!name) {
      return;
    }
    normalized[name] = value == null ? "" : String(value);
  });
  return normalized;
}

function collectSkillConfigPatch() {
  const enabled = Boolean(getInputValue("skills_edit_enabled"));
  const apiKey = String(getInputValue("skills_edit_apikey") || "").trim();
  const clearApiKey = Boolean(getInputValue("skills_edit_clear_apikey"));
  const env = parseSkillEnvPatch(getInputValue("skills_edit_env"));
  return {
    enabled,
    apiKey,
    clearApiKey,
    env
  };
}

async function saveSkillConfigPatch() {
  const skillKey = String(skillsPageState.selectedSkillKey || "").trim();
  if (!skillKey) {
    throw new Error("请先选择一个 Skill");
  }
  const patch = collectSkillConfigPatch();
  const response = await api(`/api/skills/${encodeURIComponent(skillKey)}/config`, {
    method: "PUT",
    body: JSON.stringify(patch)
  });
  setSkillsSaveResult(response.message || "保存完成", response.ok ? "success" : "fail");
  setMessage(response.message || "Skill 配置已更新", response.ok ? "ok" : "error");
  await loadSkillsStatus({ preserveSelection: true, selectedSkillKey: skillKey });
}

function renderSkillsList(skills = []) {
  const list = document.querySelector("#skills_list");
  if (!list) {
    return;
  }
  list.innerHTML = "";

  if (!Array.isArray(skills) || skills.length === 0) {
    const empty = document.createElement("p");
    empty.className = "muted-line";
    empty.textContent = "暂无可展示的 Skills。";
    list.appendChild(empty);
    return;
  }

  skills.forEach((skill) => {
    const item = document.createElement("button");
    item.type = "button";
    item.className = "skill-row";
    const isSelected = String(skill?.key || "") === skillsPageState.selectedSkillKey;
    if (isSelected) {
      item.classList.add("is-selected");
    }
    item.innerHTML = `
      <span class="skill-row-main">${truncateText(skill?.key || "-", 40)}</span>
      <span class="skill-row-meta">${skill?.enabled ? "已启用" : "未启用"} · 更新 ${skill?.updatedAtText || "-"}</span>
      <span class="skill-row-desc">${truncateText(skill?.summary || "暂无说明", 80)}</span>
    `;
    item.addEventListener("click", () => {
      loadSkillConfig(String(skill?.key || "").trim(), { silent: false }).catch((error) =>
        setMessage(error.message || "Skill 配置读取失败", "error")
      );
    });
    list.appendChild(item);
  });
}

function confirmSkillToggle(skill, nextEnabled) {
  const riskLevel = String(skill?.riskLevel || "").trim().toLowerCase();
  if (nextEnabled && riskLevel === "restricted") {
    return window.confirm(`Skill "${skill?.key}" 标记为受限能力，启用后可能影响运行态，确认继续吗？`);
  }
  if (!nextEnabled) {
    return window.confirm(`确认停用 Skill "${skill?.key}"？停用后相关能力将立即不可用。`);
  }
  return true;
}

async function loadSkillConfig(skillKey, { silent = false } = {}) {
  const normalizedSkillKey = String(skillKey || "").trim();
  if (!normalizedSkillKey) {
    skillsPageState.selectedSkillConfig = null;
    skillsPageState.selectedSkillKey = "";
    resetSkillEditForm();
    renderSkillsList(skillsPageState.skills);
    return;
  }
  const response = await api(`/api/skills/${encodeURIComponent(normalizedSkillKey)}/config`);
  skillsPageState.selectedSkillConfig = response?.result || null;
  skillsPageState.selectedSkillKey = normalizedSkillKey;

  const config = response?.result || {};
  setInput("skills_edit_enabled", Boolean(config.enabled));
  setInput("skills_edit_apikey", "");
  setInput("skills_edit_clear_apikey", false);
  setInput("skills_edit_env", JSON.stringify(config.env || {}, null, 2));
  setText("skills_selected_key", normalizedSkillKey);
  setSkillsSaveResult(
    config.apiKeyMasked ? `当前 API Key：${config.apiKeyMasked}（可留空保持不变）` : "当前未设置 API Key",
    ""
  );
  renderSkillsList(skillsPageState.skills);
  if (!silent) {
    setMessage(`已加载 Skill：${normalizedSkillKey}`, "ok");
  }
}

async function setSkillEnabled(skillKey, enabled) {
  const response = await api(`/api/skills/${encodeURIComponent(skillKey)}/enabled`, {
    method: "POST",
    body: JSON.stringify({ enabled: Boolean(enabled) })
  });
  setMessage(response.message || "Skill 状态已更新", response.ok ? "ok" : "error");
}

async function loadSkillsStatus({ silent = false, preserveSelection = true, selectedSkillKey = "" } = {}) {
  const response = await api("/api/skills/status");
  const skills = Array.isArray(response?.result?.skills) ? response.result.skills : [];
  skillsPageState.skills = skills;

  const requested = String(selectedSkillKey || "").trim();
  const targetSkillKeyFromState = String(skillsPageState.selectedSkillKey || "").trim();
  let nextSelected = "";
  if (requested && skills.some((skill) => String(skill?.key || "").trim() === requested)) {
    nextSelected = requested;
  } else if (
    preserveSelection &&
    targetSkillKeyFromState &&
    skills.some((skill) => String(skill?.key || "").trim() === targetSkillKeyFromState)
  ) {
    nextSelected = targetSkillKeyFromState;
  } else if (skills.length > 0) {
    nextSelected = String(skills[0]?.key || "").trim();
  }

  skillsPageState.selectedSkillKey = nextSelected;
  renderSkillsList(skills);

  if (nextSelected) {
    await loadSkillConfig(nextSelected, { silent: true });
  } else {
    skillsPageState.selectedSkillConfig = null;
    setText("skills_selected_key", "未选择");
    resetSkillEditForm();
  }

  if (!silent) {
    setMessage(`Skills 状态已刷新（${skills.length} 项）`, "ok");
  }
}

function setupSkillsPage() {
  if (skillsPageState.bound) {
    return;
  }
  skillsPageState.bound = true;

  document.querySelector("#skills_refresh")?.addEventListener("click", () => {
    loadSkillsStatus({ silent: false, preserveSelection: true }).catch((error) =>
      setMessage(error.message || "Skills 刷新失败", "error")
    );
  });

  document.querySelector("#skills_toggle_enabled")?.addEventListener("click", async () => {
    const skillKey = String(skillsPageState.selectedSkillKey || "").trim();
    if (!skillKey) {
      setMessage("请先选择一个 Skill", "error");
      return;
    }
    const current = skillsPageState.skills.find((item) => String(item?.key || "").trim() === skillKey);
    if (!current) {
      setMessage("当前 Skill 不存在，已刷新列表", "error");
      await loadSkillsStatus({ silent: true, preserveSelection: false });
      return;
    }
    const nextEnabled = !Boolean(current.enabled);
    if (!confirmSkillToggle(current, nextEnabled)) {
      setMessage("已取消 Skill 操作", "info");
      return;
    }
    await setSkillEnabled(skillKey, nextEnabled);
    await loadSkillsStatus({ silent: true, preserveSelection: true, selectedSkillKey: skillKey });
  });

  document.querySelector("#skills_save_config")?.addEventListener("click", () => {
    saveSkillConfigPatch().catch((error) => {
      setSkillsSaveResult(error.message || "保存失败", "fail");
      setMessage(error.message || "Skill 配置保存失败", "error");
    });
  });
}

export { loadSkillsStatus, setupSkillsPage };
</file>

<file path="src/channel-tests.js">
function withTimeout(promise, ms) {
  const controller = new AbortController();
  const timer = setTimeout(() => controller.abort(), ms);
  return {
    signal: controller.signal,
    wrapped: promise(controller.signal).finally(() => clearTimeout(timer))
  };
}

export async function testTelegramBot(botToken) {
  if (!botToken) {
    return {
      ok: false,
      message: "botToken 不能为空"
    };
  }

  try {
    const url = `https://api.telegram.org/bot${botToken}/getMe`;
    const { wrapped, signal } = withTimeout(
      (controllerSignal) =>
        fetch(url, {
          method: "GET",
          signal: controllerSignal
        }),
      8000
    );
    const response = await wrapped;
    const payload = await response.json();
    if (response.ok && payload.ok) {
      return {
        ok: true,
        message: `连接成功，机器人：${payload.result?.username || "unknown"}`
      };
    }
    return {
      ok: false,
      message: payload?.description || `请求失败（${response.status}）`
    };
  } catch (error) {
    return {
      ok: false,
      message: `连接失败：${error.message}`
    };
  }
}

export async function testFeishuBot(appId, appSecret) {
  if (!appId || !appSecret) {
    return {
      ok: false,
      message: "appId 和 appSecret 不能为空"
    };
  }

  try {
    const { wrapped } = withTimeout(
      (signal) =>
        fetch("https://open.feishu.cn/open-apis/auth/v3/tenant_access_token/internal", {
          method: "POST",
          headers: {
            "content-type": "application/json"
          },
          body: JSON.stringify({
            app_id: appId,
            app_secret: appSecret
          }),
          signal
        }),
      8000
    );
    const response = await wrapped;
    const payload = await response.json();
    if (response.ok && payload.code === 0 && payload.tenant_access_token) {
      return {
        ok: true,
        message: "飞书连接成功，凭证可用"
      };
    }
    return {
      ok: false,
      message: payload?.msg || `请求失败（${response.status}）`
    };
  } catch (error) {
    return {
      ok: false,
      message: `连接失败：${error.message}`
    };
  }
}

export async function testDiscordBot(token) {
  if (!token) {
    return {
      ok: false,
      message: "token 不能为空"
    };
  }

  try {
    const { wrapped } = withTimeout(
      (signal) =>
        fetch("https://discord.com/api/v10/users/@me", {
          method: "GET",
          headers: {
            authorization: `Bot ${token}`
          },
          signal
        }),
      8000
    );
    const response = await wrapped;
    const payload = await response.json();
    if (response.ok && payload?.id) {
      return {
        ok: true,
        message: `连接成功，机器人：${payload.username || payload.global_name || payload.id}`
      };
    }
    return {
      ok: false,
      message: payload?.message || payload?.error || `请求失败（${response.status}）`
    };
  } catch (error) {
    return {
      ok: false,
      message: `连接失败：${error.message}`
    };
  }
}

async function testSlackBotToken(botToken) {
  const { wrapped } = withTimeout(
    (signal) =>
      fetch("https://slack.com/api/auth.test", {
        method: "POST",
        headers: {
          authorization: `Bearer ${botToken}`,
          "content-type": "application/x-www-form-urlencoded"
        },
        body: "",
        signal
      }),
    8000
  );
  const response = await wrapped;
  const payload = await response.json();
  if (response.ok && payload.ok) {
    return {
      ok: true,
      message: `Bot Token 可用，团队：${payload.team || "unknown"}`
    };
  }
  return {
    ok: false,
    message: payload?.error || `Bot Token 校验失败（${response.status}）`
  };
}

async function testSlackAppToken(appToken) {
  const { wrapped } = withTimeout(
    (signal) =>
      fetch("https://slack.com/api/apps.connections.open", {
        method: "POST",
        headers: {
          authorization: `Bearer ${appToken}`,
          "content-type": "application/x-www-form-urlencoded"
        },
        body: "",
        signal
      }),
    8000
  );
  const response = await wrapped;
  const payload = await response.json();
  if (response.ok && payload.ok) {
    return {
      ok: true,
      message: "App Token 可用（Socket 链接可建立）"
    };
  }
  return {
    ok: false,
    message: payload?.error || `App Token 校验失败（${response.status}）`
  };
}

export async function testSlackBot({ mode, botToken, appToken, signingSecret }) {
  if (!botToken) {
    return {
      ok: false,
      message: "botToken 不能为空"
    };
  }

  if (mode === "http" && !signingSecret) {
    return {
      ok: false,
      message: "HTTP 模式需要 signingSecret"
    };
  }

  try {
    const botCheck = await testSlackBotToken(botToken);
    if (!botCheck.ok) {
      return botCheck;
    }

    if (mode === "socket") {
      if (!appToken) {
        return {
          ok: false,
          message: "Socket 模式需要 appToken"
        };
      }
      const appCheck = await testSlackAppToken(appToken);
      if (!appCheck.ok) {
        return appCheck;
      }
      return {
        ok: true,
        message: "Slack Socket 模式校验通过（Bot Token + App Token 均可用）"
      };
    }

    return {
      ok: true,
      message: "Slack HTTP 模式基础校验通过（Bot Token 可用，Signing Secret 已填写）"
    };
  } catch (error) {
    return {
      ok: false,
      message: `连接失败：${error.message}`
    };
  }
}
</file>

<file path="src/dashboard-service.js">
import { extractSettings } from "./openclaw-config.js";
import { callGatewayRpc } from "./gateway-client.js";
import { runServiceAction } from "./systemd.js";

const DASHBOARD_GATEWAY_TIMEOUT_MS = 1_000;
const DASHBOARD_GATEWAY_RETRIES = 6;
const DASHBOARD_GATEWAY_RETRY_DELAY_MS = 1_000;

function trimString(value) {
  return String(value || "").trim();
}

function toBoolean(value) {
  return value === true;
}

function summarizeModel(modelSettings = {}) {
  const providers = Array.isArray(modelSettings?.catalog?.providers) ? modelSettings.catalog.providers : [];
  const providerItems = providers.map((provider) => {
    const models = Array.isArray(provider?.models) ? provider.models : [];
    return {
      id: trimString(provider?.id),
      api: trimString(provider?.api),
      baseUrl: trimString(provider?.baseUrl),
      modelCount: models.length,
      models: models.map((model) => ({
        id: trimString(model?.id),
        name: trimString(model?.name || model?.id),
        contextWindow: Number(model?.contextWindow || 0) || null,
        maxTokens: Number(model?.maxTokens || 0) || null,
        thinkingStrength: trimString(model?.thinkingStrength) || "无"
      }))
    };
  });
  const totalModels = providerItems.reduce((sum, item) => sum + item.modelCount, 0);
  return {
    primaryRef: trimString(modelSettings?.primary),
    current: {
      providerId: trimString(modelSettings?.providerId),
      modelId: trimString(modelSettings?.modelId),
      modelName: trimString(modelSettings?.modelName || modelSettings?.modelId),
      contextWindow: Number(modelSettings?.contextWindow || 0) || null,
      maxTokens: Number(modelSettings?.maxTokens || 0) || null,
      thinkingStrength: trimString(modelSettings?.thinkingStrength) || "无"
    },
    counts: {
      providers: providerItems.length,
      models: totalModels
    },
    providers: providerItems
  };
}

function summarizeConfiguredChannels(channelSettings = {}) {
  const channelKeys = ["telegram", "feishu", "discord", "slack"];
  const items = channelKeys.map((key) => {
    const raw = channelSettings?.[key] && typeof channelSettings[key] === "object" ? channelSettings[key] : {};
    return {
      id: key,
      enabled: toBoolean(raw.enabled),
      dmPolicy: trimString(raw.dmPolicy),
      groupPolicy: trimString(raw.groupPolicy)
    };
  });
  const enabled = items.filter((item) => item.enabled).length;
  return {
    total: items.length,
    enabled,
    disabled: items.length - enabled,
    items
  };
}

function summarizeGatewayChannelRuntime(payload) {
  const channels = payload?.channels && typeof payload.channels === "object" ? payload.channels : {};
  const channelOrder = Array.isArray(payload?.channelOrder) ? payload.channelOrder : Object.keys(channels);
  const channelLabels = payload?.channelLabels && typeof payload.channelLabels === "object" ? payload.channelLabels : {};
  const items = channelOrder.map((id) => {
    const raw = channels[id] && typeof channels[id] === "object" ? channels[id] : {};
    return {
      id,
      label: trimString(channelLabels[id] || id),
      configured: toBoolean(raw.configured),
      running: toBoolean(raw.running),
      lastError: trimString(raw.lastError),
      lastProbeAt: raw.lastProbeAt ?? null
    };
  });
  const running = items.filter((item) => item.running).length;
  return {
    ok: true,
    total: items.length,
    running,
    stopped: items.length - running,
    items
  };
}

function summarizeSkills(payload) {
  const skills = Array.isArray(payload?.skills) ? payload.skills : [];
  const items = skills.map((skill) => ({
    key: trimString(skill?.skillKey || skill?.name),
    name: trimString(skill?.name),
    enabled: !toBoolean(skill?.disabled),
    eligible: toBoolean(skill?.eligible),
    blocked: toBoolean(skill?.blockedByAllowlist),
    source: trimString(skill?.source),
    updatedAt: skill?.updatedAt ?? null
  }));
  const enabled = items.filter((item) => item.enabled).length;
  const eligible = items.filter((item) => item.eligible).length;
  const blocked = items.filter((item) => item.blocked).length;
  return {
    ok: true,
    total: items.length,
    enabled,
    disabled: items.length - enabled,
    eligible,
    blocked,
    items
  };
}

function normalizeRpcError(error) {
  if (!error) {
    return "gateway rpc failed";
  }
  return trimString(error.message || error) || "gateway rpc failed";
}

async function loadGatewaySummary(panelConfig, gatewayToken, callRpc) {
  const [channelsResult, skillsResult] = await Promise.allSettled([
    callRpc({
      panelConfig,
      method: "channels.status",
      params: {},
      timeoutMs: DASHBOARD_GATEWAY_TIMEOUT_MS,
      retries: DASHBOARD_GATEWAY_RETRIES,
      retryDelayMs: DASHBOARD_GATEWAY_RETRY_DELAY_MS,
      token: gatewayToken
    }),
    callRpc({
      panelConfig,
      method: "skills.status",
      params: {},
      timeoutMs: DASHBOARD_GATEWAY_TIMEOUT_MS,
      retries: DASHBOARD_GATEWAY_RETRIES,
      retryDelayMs: DASHBOARD_GATEWAY_RETRY_DELAY_MS,
      token: gatewayToken
    })
  ]);

  const channels =
    channelsResult.status === "fulfilled"
      ? summarizeGatewayChannelRuntime(channelsResult.value)
      : {
          ok: false,
          total: 0,
          running: 0,
          stopped: 0,
          items: [],
          message: normalizeRpcError(channelsResult.reason)
        };
  const skills =
    skillsResult.status === "fulfilled"
      ? summarizeSkills(skillsResult.value)
      : {
          ok: false,
          total: 0,
          enabled: 0,
          disabled: 0,
          eligible: 0,
          blocked: 0,
          items: [],
          message: normalizeRpcError(skillsResult.reason)
        };

  return { channels, skills };
}

async function loadRuntimeSummary(panelConfig, runAction) {
  try {
    const result = await runAction("status", panelConfig);
    return {
      ok: toBoolean(result?.ok),
      active: toBoolean(result?.active),
      mode: trimString(panelConfig?.runtime?.mode) || "systemd",
      message: trimString(result?.message || result?.output)
    };
  } catch (error) {
    return {
      ok: false,
      active: false,
      mode: trimString(panelConfig?.runtime?.mode) || "systemd",
      message: trimString(error?.message || error)
    };
  }
}

export async function buildDashboardSummary({
  panelConfig,
  openclawConfig,
  deps = {}
}) {
  const readSettings = deps.extractSettings || extractSettings;
  const runAction = deps.runServiceAction || runServiceAction;
  const callRpc = deps.callGatewayRpc || callGatewayRpc;
  const gatewayToken = trimString(deps.gatewayToken ?? process.env.OPENCLAW_GATEWAY_TOKEN);

  const settings = readSettings(openclawConfig);
  const runtime = await loadRuntimeSummary(panelConfig, runAction);
  const gateway = await loadGatewaySummary(panelConfig, gatewayToken, callRpc);

  return {
    generatedAt: new Date().toISOString(),
    model: summarizeModel(settings.model),
    channels: {
      configured: summarizeConfiguredChannels(settings.channels),
      runtime: gateway.channels
    },
    skills: gateway.skills,
    runtime
  };
}
</file>

<file path="src/direct-update.js">
import fs from "node:fs/promises";
import os from "node:os";
import path from "node:path";
import { spawn } from "node:child_process";

const DEFAULT_BOT_RELEASE_REPO = "openclaw/openclaw";
const DEFAULT_PANEL_RELEASE_REPO = "Bianshumeng/openclaw-panel-public";
const DEFAULT_PANEL_SERVICE_NAME = "openclaw-panel";
const DEFAULT_PANEL_APP_DIR = "/opt/openclaw-panel";

function trimText(value) {
  return String(value || "").trim();
}

function stripLeadingV(value) {
  return trimText(value).replace(/^v/i, "");
}

function normalizeTag(value) {
  const text = trimText(value);
  if (!text) {
    return "";
  }
  return text.startsWith("v") || text.startsWith("V") ? text : `v${text}`;
}

function normalizeRepo(value, fallbackRepo) {
  const text = trimText(value);
  if (!text) {
    return fallbackRepo;
  }
  if (!/^[A-Za-z0-9_.-]+\/[A-Za-z0-9_.-]+$/.test(text)) {
    throw new Error(`发布仓库格式不合法：${text}（应为 owner/repo）`);
  }
  return text;
}

function shellQuote(value) {
  return `'${String(value || "").replace(/'/g, `'\\''`)}'`;
}

function parseVersionFromText(value) {
  const text = trimText(value);
  if (!text) {
    return "";
  }
  const match = text.match(/([0-9]{4}\.[0-9]+\.[0-9]+(?:-[0-9A-Za-z._-]+)?)/);
  if (match) {
    return stripLeadingV(match[1]);
  }
  return stripLeadingV(text.split(/\s+/)[0] || "");
}

function toInstallMethod(rawInstall = "") {
  const value = trimText(rawInstall).toLowerCase();
  if (!value) {
    return "global";
  }
  if (/(git|source|checkout|workspace|repo)/.test(value)) {
    return "source";
  }
  if (/(pnpm|npm|yarn|bun|global)/.test(value)) {
    return "global";
  }
  return "global";
}

export function parseOpenClawUpdateStatus(rawOutput = "") {
  const text = String(rawOutput || "");
  const installMatch = text.match(/│\s*Install\s*│\s*([^│\n]+)\s*│/i);
  const updateMatch = text.match(/│\s*Update\s*│\s*([^│\n]+)\s*│/i);
  const installRaw = trimText(installMatch?.[1] || "");
  const updateRaw = trimText(updateMatch?.[1] || "");

  const installMethod = toInstallMethod(installRaw);
  const strategy = installMethod === "source" ? "openclaw-update" : "package-manager";

  const hasAvailableKeyword = /available/i.test(updateRaw) || /update available/i.test(text);
  const hasUpToDateKeyword = /up[\s-]?to[\s-]?date/i.test(updateRaw) || /already up[\s-]?to[\s-]?date/i.test(text);
  let latestTag = "";
  const preferred = [updateRaw, text];
  const patterns = [
    /npm update\s+([0-9][0-9A-Za-z._-]*)/i,
    /latest(?:\s+version)?\s*[:：]?\s*([0-9][0-9A-Za-z._-]*)/i,
    /available[^\n]*\b([0-9]{4}\.[0-9]+\.[0-9]+(?:-[0-9A-Za-z._-]+)?)/i,
    /([0-9]{4}\.[0-9]+\.[0-9]+(?:-[0-9A-Za-z._-]+)?)/i
  ];
  for (const source of preferred) {
    if (!source) {
      continue;
    }
    for (const pattern of patterns) {
      const matched = source.match(pattern);
      if (matched && matched[1]) {
        latestTag = stripLeadingV(matched[1]);
        break;
      }
    }
    if (latestTag) {
      break;
    }
  }

  return {
    installRaw,
    updateRaw,
    installMethod,
    strategy,
    latestTag,
    updateAvailable: hasAvailableKeyword && !hasUpToDateKeyword
  };
}

async function fetchJson(url, { fetchImpl = fetch, githubToken = "" } = {}) {
  const headers = {
    accept: "application/vnd.github+json",
    "user-agent": "openclaw-panel-updater"
  };
  const token = trimText(githubToken);
  if (token) {
    headers.authorization = `Bearer ${token}`;
  }
  const response = await fetchImpl(url, { headers });
  const bodyText = await response.text();
  if (!response.ok) {
    const err = new Error(`GitHub API 请求失败: ${response.status}`);
    err.status = response.status;
    err.bodyText = bodyText;
    throw err;
  }
  try {
    return JSON.parse(bodyText);
  } catch (error) {
    throw new Error(`GitHub API 返回了非 JSON 内容: ${error.message}`);
  }
}

function parseReleasePayload(payload, releaseRepo) {
  const tag = trimText(payload?.tag_name || payload?.name);
  const tarballUrl = trimText(payload?.tarball_url || payload?.zipball_url);
  if (!tag || !tarballUrl) {
    throw new Error(`发布信息不完整（repo=${releaseRepo}）`);
  }
  return {
    tag,
    tarballUrl,
    publishedAt: trimText(payload?.published_at),
    htmlUrl: trimText(payload?.html_url),
    releaseRepo
  };
}

async function fetchLatestRelease({ releaseRepo, fetchImpl = fetch, githubToken = "" }) {
  const url = `https://api.github.com/repos/${releaseRepo}/releases/latest`;
  const payload = await fetchJson(url, { fetchImpl, githubToken });
  return parseReleasePayload(payload, releaseRepo);
}

async function fetchReleaseByTag({ releaseRepo, tag, fetchImpl = fetch, githubToken = "" }) {
  const normalized = trimText(tag);
  const candidates = [];
  if (normalized) {
    candidates.push(normalized);
    if (normalized.startsWith("v") || normalized.startsWith("V")) {
      candidates.push(normalized.slice(1));
    } else {
      candidates.push(`v${normalized}`);
    }
  }
  const deduped = [...new Set(candidates.map((item) => trimText(item)).filter(Boolean))];
  let lastError = null;
  for (const candidate of deduped) {
    try {
      const url = `https://api.github.com/repos/${releaseRepo}/releases/tags/${encodeURIComponent(candidate)}`;
      const payload = await fetchJson(url, { fetchImpl, githubToken });
      return parseReleasePayload(payload, releaseRepo);
    } catch (error) {
      if (Number(error?.status) === 404) {
        lastError = error;
        continue;
      }
      throw error;
    }
  }
  if (lastError) {
    throw new Error(`未找到发布版本：${normalized}`);
  }
  throw new Error("缺少目标发布版本");
}

async function getCurrentOpenClawVersion({ runCmd }) {
  const result = await runCmd("openclaw", ["--version"], 15000);
  if (!result.ok) {
    throw new Error(result.stderr || result.message || "无法读取 openclaw 当前版本");
  }
  return parseVersionFromText(result.stdout);
}

export async function checkBotDirectUpdate({
  runCmd,
  releaseRepo = DEFAULT_BOT_RELEASE_REPO
} = {}) {
  if (typeof runCmd !== "function") {
    throw new Error("缺少 runCmd");
  }
  const currentTag = await getCurrentOpenClawVersion({ runCmd });
  const statusResult = await runCmd("openclaw", ["update", "status"], 30000);
  if (!statusResult.ok) {
    return {
      ok: true,
      currentTag,
      latestTag: "",
      updateAvailable: false,
      warning: statusResult.stderr || statusResult.message || "无法检查更新状态",
      installMethod: "global",
      strategy: "package-manager",
      releaseRepo
    };
  }
  const parsed = parseOpenClawUpdateStatus(statusResult.stdout);
  let updateAvailable = Boolean(parsed.updateAvailable);
  if (!updateAvailable && parsed.latestTag && currentTag) {
    updateAvailable = stripLeadingV(parsed.latestTag) !== stripLeadingV(currentTag);
  }
  return {
    ok: true,
    currentTag,
    latestTag: parsed.latestTag || "",
    updateAvailable,
    warning: "",
    installMethod: parsed.installMethod,
    strategy: parsed.strategy,
    releaseRepo
  };
}

async function runOpenClawPostChecks({ runCmd }) {
  const checks = [
    { name: "doctor", args: ["doctor"], timeout: 120000 },
    { name: "gateway restart", args: ["gateway", "restart"], timeout: 120000 },
    { name: "health", args: ["health"], timeout: 120000 }
  ];
  const warnings = [];
  for (const item of checks) {
    const result = await runCmd("openclaw", item.args, item.timeout);
    if (!result.ok) {
      warnings.push(`${item.name}: ${trimText(result.stderr || result.message || "失败")}`);
    }
  }
  return warnings;
}

export async function mutateBotDirectUpdate({
  action = "upgrade",
  tag = "",
  runCmd
} = {}) {
  if (typeof runCmd !== "function") {
    throw new Error("缺少 runCmd");
  }
  const targetTag = trimText(tag);
  if (action === "rollback" && !targetTag) {
    return {
      ok: false,
      action,
      rolledBack: false,
      message: "回滚必须提供目标版本号（tag）"
    };
  }
  const args = ["update", "--yes"];
  if (targetTag) {
    args.push("--tag", stripLeadingV(targetTag));
  }
  const result = await runCmd("openclaw", args, 20 * 60 * 1000);
  if (!result.ok) {
    return {
      ok: false,
      action,
      rolledBack: false,
      message: trimText(result.stderr || result.message || "OpenClaw 更新失败")
    };
  }
  const currentTag = await getCurrentOpenClawVersion({ runCmd }).catch(() => stripLeadingV(targetTag));
  const warnings = await runOpenClawPostChecks({ runCmd });
  const baseMessage = action === "rollback" ? "OpenClaw 回滚成功" : "OpenClaw 更新成功";
  const warningMessage = warnings.length > 0 ? `；后置检查告警：${warnings.join(" | ")}` : "";
  return {
    ok: true,
    action,
    targetImage: currentTag ? `openclaw:${currentTag}` : `openclaw:${stripLeadingV(targetTag) || "latest"}`,
    oldImage: "",
    rolledBack: false,
    requiresRestart: false,
    message: `${baseMessage}${warningMessage}`
  };
}

function resolvePanelAppDir(value = "") {
  const configured = trimText(value || process.env.PANEL_APP_DIR);
  if (configured) {
    return path.resolve(configured);
  }
  if (process.platform === "linux") {
    return DEFAULT_PANEL_APP_DIR;
  }
  return process.cwd();
}

function resolvePanelServiceName(value = "") {
  return trimText(value || process.env.PANEL_SERVICE_NAME) || DEFAULT_PANEL_SERVICE_NAME;
}

function resolvePanelUpdateStateDir(value = "") {
  const configured = trimText(value || process.env.PANEL_UPDATE_STATE_DIR);
  if (configured) {
    return path.resolve(configured);
  }
  if (process.platform === "linux") {
    return "/var/lib/openclaw-panel/update";
  }
  return path.join(os.tmpdir(), "openclaw-panel-update");
}

async function readJsonFileSafe(filePath, fallbackValue = {}) {
  try {
    const content = await fs.readFile(filePath, "utf8");
    return JSON.parse(content);
  } catch {
    return fallbackValue;
  }
}

async function readPanelCurrentVersion(appDir) {
  const markerPath = path.join(appDir, ".panel-release.json");
  const marker = await readJsonFileSafe(markerPath, {});
  const markerTag = trimText(marker?.tag);
  if (markerTag) {
    return markerTag;
  }
  const packageJsonPath = path.join(appDir, "package.json");
  const packageJson = await readJsonFileSafe(packageJsonPath, {});
  const packageVersion = trimText(packageJson?.version);
  if (packageVersion) {
    return normalizeTag(packageVersion);
  }
  return "";
}

async function downloadTarball(tarballUrl, destinationPath, { fetchImpl = fetch, githubToken = "" } = {}) {
  const headers = {
    accept: "application/octet-stream",
    "user-agent": "openclaw-panel-updater"
  };
  const token = trimText(githubToken);
  if (token) {
    headers.authorization = `Bearer ${token}`;
  }
  const response = await fetchImpl(tarballUrl, { headers });
  if (!response.ok) {
    throw new Error(`下载发布包失败: HTTP ${response.status}`);
  }
  const buffer = Buffer.from(await response.arrayBuffer());
  await fs.writeFile(destinationPath, buffer, { mode: 0o600 });
}

function safeTagForFilename(tag) {
  return trimText(tag).replace(/[^0-9A-Za-z._-]/g, "_");
}

function buildApplyScript({
  appDir,
  serviceName,
  tarballPath,
  tag,
  releaseRepo,
  pendingPath
}) {
  const markerPath = path.join(appDir, ".panel-release.json");
  const markerPayload = JSON.stringify(
    {
      tag,
      releaseRepo,
      appliedAt: new Date().toISOString()
    },
    null,
    2
  );
  return [
    "set -euo pipefail",
    `APP_DIR=${shellQuote(appDir)}`,
    `SERVICE_NAME=${shellQuote(serviceName)}`,
    `TARBALL=${shellQuote(tarballPath)}`,
    `PENDING=${shellQuote(pendingPath)}`,
    "TMP_DIR=$(mktemp -d)",
    "cleanup(){ rm -rf \"$TMP_DIR\"; }",
    "trap cleanup EXIT",
    "tar -xzf \"$TARBALL\" -C \"$TMP_DIR\"",
    "SRC_DIR=$(find \"$TMP_DIR\" -mindepth 1 -maxdepth 1 -type d | head -n 1)",
    "if [ -z \"$SRC_DIR\" ]; then echo 'release unpack failed'; exit 1; fi",
    "mkdir -p \"$APP_DIR\"",
    "if command -v rsync >/dev/null 2>&1; then",
    "  rsync -a --delete --exclude '.git' --exclude 'node_modules' --exclude '.runtime' \"$SRC_DIR\"/ \"$APP_DIR\"/",
    "else",
    "  find \"$APP_DIR\" -mindepth 1 -maxdepth 1 ! -name '.runtime' -exec rm -rf {} +",
    "  cp -a \"$SRC_DIR\"/. \"$APP_DIR\"/",
    "fi",
    "cd \"$APP_DIR\"",
    "npm install --omit=dev",
    `cat > ${shellQuote(markerPath)} <<'JSON'`,
    markerPayload,
    "JSON",
    "rm -f \"$PENDING\"",
    "systemctl daemon-reload || true",
    "systemctl restart \"$SERVICE_NAME\""
  ].join("\n");
}

export async function checkPanelDirectUpdate({
  releaseRepo = DEFAULT_PANEL_RELEASE_REPO,
  githubToken = "",
  fetchImpl = fetch,
  appDir = ""
} = {}) {
  const finalRepo = normalizeRepo(releaseRepo, DEFAULT_PANEL_RELEASE_REPO);
  const finalAppDir = resolvePanelAppDir(appDir);
  const currentTag = await readPanelCurrentVersion(finalAppDir);
  try {
    const latest = await fetchLatestRelease({ releaseRepo: finalRepo, fetchImpl, githubToken });
    const updateAvailable = currentTag ? stripLeadingV(currentTag) !== stripLeadingV(latest.tag) : true;
    return {
      ok: true,
      currentTag,
      latestTag: latest.tag,
      latestPublishedAt: latest.publishedAt,
      releaseRepo: finalRepo,
      updateAvailable,
      warning: ""
    };
  } catch (error) {
    return {
      ok: true,
      currentTag,
      latestTag: "",
      latestPublishedAt: null,
      releaseRepo: finalRepo,
      updateAvailable: false,
      warning: error.message || String(error)
    };
  }
}

export async function stagePanelDirectUpdate({
  tag = "",
  releaseRepo = DEFAULT_PANEL_RELEASE_REPO,
  githubToken = "",
  fetchImpl = fetch,
  appDir = "",
  stateDir = ""
} = {}) {
  const finalRepo = normalizeRepo(releaseRepo, DEFAULT_PANEL_RELEASE_REPO);
  const finalAppDir = resolvePanelAppDir(appDir);
  const finalStateDir = resolvePanelUpdateStateDir(stateDir);
  await fs.mkdir(finalStateDir, { recursive: true });
  const release = trimText(tag)
    ? await fetchReleaseByTag({ releaseRepo: finalRepo, tag, fetchImpl, githubToken })
    : await fetchLatestRelease({ releaseRepo: finalRepo, fetchImpl, githubToken });
  const currentTag = await readPanelCurrentVersion(finalAppDir);
  const archiveName = `panel-${safeTagForFilename(release.tag)}.tar.gz`;
  const tarballPath = path.join(finalStateDir, archiveName);
  await downloadTarball(release.tarballUrl, tarballPath, { fetchImpl, githubToken });
  const pendingPath = path.join(finalStateDir, "pending.json");
  const pendingPayload = {
    tag: release.tag,
    releaseRepo: finalRepo,
    appDir: finalAppDir,
    tarballPath,
    stagedAt: new Date().toISOString(),
    publishedAt: release.publishedAt
  };
  await fs.writeFile(pendingPath, `${JSON.stringify(pendingPayload, null, 2)}\n`, { mode: 0o600 });
  return {
    ok: true,
    action: "stage",
    targetImage: `panel:${release.tag}`,
    oldImage: currentTag ? `panel:${currentTag}` : "",
    rolledBack: false,
    requiresRestart: true,
    message: `已准备版本包 ${release.tag}，请点击“应用更新并重启”生效。`
  };
}

export async function applyPanelDirectUpdate({
  tag = "",
  releaseRepo = DEFAULT_PANEL_RELEASE_REPO,
  githubToken = "",
  fetchImpl = fetch,
  appDir = "",
  stateDir = "",
  panelServiceName = ""
} = {}) {
  if (process.platform !== "linux") {
    return {
      ok: false,
      action: "apply",
      rolledBack: false,
      requiresReconnect: false,
      message: "控制台自更新仅支持 Linux 服务器环境执行"
    };
  }
  const finalStateDir = resolvePanelUpdateStateDir(stateDir);
  await fs.mkdir(finalStateDir, { recursive: true });
  const pendingPath = path.join(finalStateDir, "pending.json");
  let pending = await readJsonFileSafe(pendingPath, null);
  if (!pending || !trimText(pending?.tarballPath)) {
    if (!trimText(tag)) {
      return {
        ok: false,
        action: "apply",
        rolledBack: false,
        requiresReconnect: false,
        message: "未找到待应用的版本包，请先执行“检查新版本/准备更新包”"
      };
    }
    await stagePanelDirectUpdate({
      tag,
      releaseRepo,
      githubToken,
      fetchImpl,
      appDir,
      stateDir: finalStateDir
    });
    pending = await readJsonFileSafe(pendingPath, null);
  }
  if (!pending || !trimText(pending?.tarballPath)) {
    return {
      ok: false,
      action: "apply",
      rolledBack: false,
      requiresReconnect: false,
      message: "未找到待应用的版本包"
    };
  }
  const finalAppDir = resolvePanelAppDir(trimText(pending?.appDir) || appDir);
  const finalServiceName = resolvePanelServiceName(panelServiceName);
  const finalTag = trimText(pending?.tag) || normalizeTag(tag) || "unknown";
  const finalRepo = normalizeRepo(trimText(pending?.releaseRepo) || releaseRepo, DEFAULT_PANEL_RELEASE_REPO);
  const script = buildApplyScript({
    appDir: finalAppDir,
    serviceName: finalServiceName,
    tarballPath: trimText(pending.tarballPath),
    tag: finalTag,
    releaseRepo: finalRepo,
    pendingPath
  });
  const logPath = path.join(finalStateDir, `apply-${Date.now()}.log`);
  const wrapper = `${script}\n`;
  const child = spawn("bash", ["-lc", `(${wrapper}) > ${shellQuote(logPath)} 2>&1`], {
    detached: true,
    stdio: "ignore"
  });
  child.unref();
  const currentTag = await readPanelCurrentVersion(finalAppDir);
  return {
    ok: true,
    action: "apply",
    targetImage: `panel:${finalTag}`,
    oldImage: currentTag ? `panel:${currentTag}` : "",
    rolledBack: false,
    requiresReconnect: true,
    reconnectAfterMs: 12000,
    message: `已开始应用 ${finalTag} 并重启控制台服务，页面将短暂断开后恢复。`,
    logPath
  };
}
</file>

<file path="src/openclaw-config/model-catalog.js">
function isRecord(value) {
  return value !== null && typeof value === "object" && !Array.isArray(value);
}

function normalizeRef(providerId, modelId) {
  const cleanProviderId = String(providerId || "").trim();
  const cleanModelId = String(modelId || "").trim();
  if (!cleanProviderId || !cleanModelId) {
    return "";
  }
  return `${cleanProviderId}/${cleanModelId}`;
}

function ensureCatalogConfig(currentConfig) {
  const next = structuredClone(currentConfig || {});

  if (!isRecord(next.models)) {
    next.models = {};
  }
  if (!isRecord(next.models.providers)) {
    next.models.providers = {};
  }
  if (!isRecord(next.agents)) {
    next.agents = {};
  }
  if (!isRecord(next.agents.defaults)) {
    next.agents.defaults = {};
  }
  if (!isRecord(next.agents.defaults.model)) {
    next.agents.defaults.model = {};
  }
  if (!isRecord(next.agents.defaults.models)) {
    next.agents.defaults.models = {};
  }

  return next;
}

function collectModelRefs(providers) {
  const refs = [];
  Object.entries(providers || {}).forEach(([providerId, providerEntry]) => {
    const models = Array.isArray(providerEntry?.models) ? providerEntry.models : [];
    models.forEach((modelEntry) => {
      const modelId = String(modelEntry?.id || "").trim();
      const ref = normalizeRef(providerId, modelId);
      if (ref) {
        refs.push(ref);
      }
    });
  });
  return refs;
}

function resolveFallbackPrimary(providers) {
  for (const [providerId, providerEntry] of Object.entries(providers || {})) {
    const models = Array.isArray(providerEntry?.models) ? providerEntry.models : [];
    for (const modelEntry of models) {
      const modelId = String(modelEntry?.id || "").trim();
      const ref = normalizeRef(providerId, modelId);
      if (ref) {
        return ref;
      }
    }
  }
  return "";
}

function remapModelOverrides(nextConfig, remap) {
  const currentOverrides = isRecord(nextConfig?.agents?.defaults?.models) ? nextConfig.agents.defaults.models : {};
  const mappedOverrides = {};
  Object.entries(currentOverrides).forEach(([ref, value]) => {
    const mappedRef = String(remap(ref) || "").trim();
    if (!mappedRef) {
      return;
    }
    if (!Object.prototype.hasOwnProperty.call(mappedOverrides, mappedRef)) {
      mappedOverrides[mappedRef] = value;
    }
  });
  nextConfig.agents.defaults.models = mappedOverrides;
}

function normalizePrimaryAndOverrides(nextConfig) {
  const providers = isRecord(nextConfig?.models?.providers) ? nextConfig.models.providers : {};
  const validRefs = new Set(collectModelRefs(providers));

  const currentPrimary = String(nextConfig?.agents?.defaults?.model?.primary || "").trim();
  const normalizedPrimary = validRefs.has(currentPrimary) ? currentPrimary : resolveFallbackPrimary(providers);
  nextConfig.agents.defaults.model.primary = normalizedPrimary;

  const currentOverrides = isRecord(nextConfig?.agents?.defaults?.models) ? nextConfig.agents.defaults.models : {};
  const filteredOverrides = {};
  Object.entries(currentOverrides).forEach(([ref, value]) => {
    if (validRefs.has(ref)) {
      filteredOverrides[ref] = value;
    }
  });
  nextConfig.agents.defaults.models = filteredOverrides;

  return {
    primary: normalizedPrimary,
    availableModelRefs: [...validRefs]
  };
}

function readOptionalPositiveInt(value, fieldName) {
  if (value === undefined || value === null || value === "") {
    return undefined;
  }
  const parsed = Number(value);
  if (!Number.isFinite(parsed) || parsed <= 0) {
    throw new Error(`${fieldName} 必须是正整数`);
  }
  return Math.floor(parsed);
}

function updateProviderInCatalog(currentConfig, payload = {}) {
  const sourceProviderId = String(payload.providerId || "").trim();
  const targetProviderId = String(payload.nextProviderId || sourceProviderId).trim();
  const nextApi = String(payload.api || "").trim();
  const nextBaseUrl = String(payload.baseUrl || "").trim();

  if (!sourceProviderId) {
    throw new Error("providerId 不能为空");
  }
  if (!targetProviderId) {
    throw new Error("nextProviderId 不能为空");
  }
  if (!nextApi) {
    throw new Error("供应商 API 模式不能为空");
  }
  if (!nextBaseUrl) {
    throw new Error("供应商 Base URL 不能为空");
  }

  const nextConfig = ensureCatalogConfig(currentConfig);
  const providers = nextConfig.models.providers;
  const sourceProvider = providers[sourceProviderId];
  if (!isRecord(sourceProvider)) {
    throw new Error(`供应商不存在：${sourceProviderId}`);
  }

  if (targetProviderId !== sourceProviderId && isRecord(providers[targetProviderId])) {
    throw new Error(`供应商名称已存在：${targetProviderId}`);
  }

  const updatedProvider = {
    ...sourceProvider,
    api: nextApi,
    baseUrl: nextBaseUrl
  };

  if (Object.prototype.hasOwnProperty.call(payload, "apiKey")) {
    updatedProvider.apiKey = String(payload.apiKey || "").trim();
  }

  if (targetProviderId !== sourceProviderId) {
    delete providers[sourceProviderId];
  }
  providers[targetProviderId] = updatedProvider;

  if (targetProviderId !== sourceProviderId) {
    const sourcePrefix = `${sourceProviderId}/`;
    const targetPrefix = `${targetProviderId}/`;
    const currentPrimary = String(nextConfig.agents.defaults.model.primary || "").trim();
    if (currentPrimary.startsWith(sourcePrefix)) {
      nextConfig.agents.defaults.model.primary = `${targetPrefix}${currentPrimary.slice(sourcePrefix.length)}`;
    }
    remapModelOverrides(nextConfig, (ref) =>
      ref.startsWith(sourcePrefix) ? `${targetPrefix}${ref.slice(sourcePrefix.length)}` : ref
    );
  }

  const normalized = normalizePrimaryAndOverrides(nextConfig);
  return {
    nextConfig,
    providerId: targetProviderId,
    primary: normalized.primary
  };
}

function updateModelInCatalog(currentConfig, payload = {}) {
  const providerId = String(payload.providerId || "").trim();
  const sourceModelId = String(payload.modelId || "").trim();
  const targetModelId = String(payload.nextModelId || sourceModelId).trim();

  if (!providerId) {
    throw new Error("providerId 不能为空");
  }
  if (!sourceModelId) {
    throw new Error("modelId 不能为空");
  }
  if (!targetModelId) {
    throw new Error("nextModelId 不能为空");
  }

  const nextConfig = ensureCatalogConfig(currentConfig);
  const providers = nextConfig.models.providers;
  const provider = providers[providerId];
  if (!isRecord(provider)) {
    throw new Error(`供应商不存在：${providerId}`);
  }

  const models = Array.isArray(provider.models) ? [...provider.models] : [];
  const sourceIndex = models.findIndex((modelEntry) => String(modelEntry?.id || "").trim() === sourceModelId);
  if (sourceIndex < 0) {
    throw new Error(`模型不存在：${providerId}/${sourceModelId}`);
  }

  if (
    targetModelId !== sourceModelId &&
    models.some((modelEntry, index) => index !== sourceIndex && String(modelEntry?.id || "").trim() === targetModelId)
  ) {
    throw new Error(`模型 ID 已存在：${providerId}/${targetModelId}`);
  }

  const currentModel = isRecord(models[sourceIndex]) ? models[sourceIndex] : {};
  const nextModel = {
    ...currentModel,
    id: targetModelId
  };

  if (Object.prototype.hasOwnProperty.call(payload, "name")) {
    const nextName = String(payload.name || "").trim();
    nextModel.name = nextName || targetModelId;
  } else if (!String(nextModel.name || "").trim()) {
    nextModel.name = targetModelId;
  }

  const nextContextWindow = readOptionalPositiveInt(payload.contextWindow, "contextWindow");
  if (nextContextWindow !== undefined) {
    nextModel.contextWindow = nextContextWindow;
  }

  const nextMaxTokens = readOptionalPositiveInt(payload.maxTokens, "maxTokens");
  if (nextMaxTokens !== undefined) {
    nextModel.maxTokens = nextMaxTokens;
  }

  models[sourceIndex] = nextModel;
  provider.models = models;

  if (targetModelId !== sourceModelId) {
    const sourceRef = normalizeRef(providerId, sourceModelId);
    const targetRef = normalizeRef(providerId, targetModelId);
    if (!targetRef) {
      throw new Error("模型引用无效");
    }
    if (String(nextConfig.agents.defaults.model.primary || "").trim() === sourceRef) {
      nextConfig.agents.defaults.model.primary = targetRef;
    }
    remapModelOverrides(nextConfig, (ref) => (ref === sourceRef ? targetRef : ref));
  }

  const normalized = normalizePrimaryAndOverrides(nextConfig);
  return {
    nextConfig,
    providerId,
    modelId: targetModelId,
    modelName: String(nextModel.name || targetModelId).trim() || targetModelId,
    primary: normalized.primary
  };
}

function removeProviderFromCatalog(currentConfig, payload = {}) {
  const providerId = String(payload.providerId || "").trim();
  if (!providerId) {
    throw new Error("providerId 不能为空");
  }

  const nextConfig = ensureCatalogConfig(currentConfig);
  const providers = nextConfig.models.providers;
  if (!isRecord(providers[providerId])) {
    throw new Error(`供应商不存在：${providerId}`);
  }

  delete providers[providerId];

  const providerPrefix = `${providerId}/`;
  const currentPrimary = String(nextConfig.agents.defaults.model.primary || "").trim();
  if (currentPrimary.startsWith(providerPrefix)) {
    nextConfig.agents.defaults.model.primary = "";
  }
  remapModelOverrides(nextConfig, (ref) => (ref.startsWith(providerPrefix) ? "" : ref));

  const normalized = normalizePrimaryAndOverrides(nextConfig);
  return {
    nextConfig,
    providerId,
    primary: normalized.primary
  };
}

function removeModelFromCatalog(currentConfig, payload = {}) {
  const providerId = String(payload.providerId || "").trim();
  const modelId = String(payload.modelId || "").trim();

  if (!providerId) {
    throw new Error("providerId 不能为空");
  }
  if (!modelId) {
    throw new Error("modelId 不能为空");
  }

  const nextConfig = ensureCatalogConfig(currentConfig);
  const providers = nextConfig.models.providers;
  const provider = providers[providerId];
  if (!isRecord(provider)) {
    throw new Error(`供应商不存在：${providerId}`);
  }

  const models = Array.isArray(provider.models) ? [...provider.models] : [];
  const nextModels = models.filter((modelEntry) => String(modelEntry?.id || "").trim() !== modelId);
  if (nextModels.length === models.length) {
    throw new Error(`模型不存在：${providerId}/${modelId}`);
  }

  const deletedRef = normalizeRef(providerId, modelId);
  const currentPrimary = String(nextConfig.agents.defaults.model.primary || "").trim();

  let providerRemoved = false;
  if (nextModels.length > 0) {
    provider.models = nextModels;
    remapModelOverrides(nextConfig, (ref) => (ref === deletedRef ? "" : ref));
  } else {
    delete providers[providerId];
    providerRemoved = true;
    const providerPrefix = `${providerId}/`;
    remapModelOverrides(nextConfig, (ref) => (ref.startsWith(providerPrefix) ? "" : ref));
  }

  if (currentPrimary === deletedRef || (providerRemoved && currentPrimary.startsWith(`${providerId}/`))) {
    nextConfig.agents.defaults.model.primary = "";
  }

  const normalized = normalizePrimaryAndOverrides(nextConfig);
  return {
    nextConfig,
    providerId,
    modelId,
    providerRemoved,
    primary: normalized.primary
  };
}

export { removeModelFromCatalog, removeProviderFromCatalog, updateModelInCatalog, updateProviderInCatalog };
</file>

<file path="src/smoke-check.js">
import { loadPanelConfig } from "./panel-config.js";
import { loadOpenClawConfig, extractSettings } from "./openclaw-config.js";

async function run() {
  const { config, filePath } = await loadPanelConfig();
  console.log(`[ok] panel config path: ${filePath}`);
  const openclaw = await loadOpenClawConfig(config.openclaw.config_path);
  const settings = extractSettings(openclaw);
  console.log(`[ok] provider: ${settings.model.providerId}/${settings.model.modelId}`);
  console.log("[ok] smoke check done");
}

run().catch((error) => {
  console.error(`[fail] ${error.message}`);
  process.exit(1);
});
</file>

<file path="src/utils.js">
import fs from "node:fs/promises";
import os from "node:os";
import path from "node:path";

export function expandHome(inputPath) {
  if (!inputPath || typeof inputPath !== "string") {
    return inputPath;
  }
  if (inputPath === "~") {
    return os.homedir();
  }
  if (inputPath.startsWith("~/")) {
    return path.join(os.homedir(), inputPath.slice(2));
  }
  return inputPath;
}

export async function ensureParentDir(filePath) {
  const dir = path.dirname(filePath);
  await fs.mkdir(dir, { recursive: true });
}

export async function readJsonFile(filePath, fallback = {}) {
  try {
    const raw = await fs.readFile(filePath, "utf8");
    return JSON.parse(raw);
  } catch (error) {
    if (error.code === "ENOENT") {
      return fallback;
    }
    throw error;
  }
}

export async function writeJsonFileAtomic(filePath, data, mode = 0o600) {
  await ensureParentDir(filePath);
  const tempPath = `${filePath}.tmp`;
  const raw = `${JSON.stringify(data, null, 2)}\n`;
  await fs.writeFile(tempPath, raw, { encoding: "utf8", mode });
  await fs.rename(tempPath, filePath);
  try {
    await fs.chmod(filePath, mode);
  } catch {
    // ignore on systems that do not support chmod semantics
  }
}

export function maskSecret(value) {
  if (!value || typeof value !== "string") {
    return "";
  }
  const trimmed = value.trim();
  if (!trimmed) {
    return "";
  }
  if (trimmed.length <= 6) {
    return "*".repeat(trimmed.length);
  }
  const tail = trimmed.slice(-4);
  return `${"*".repeat(Math.max(0, trimmed.length - 4))}${tail}`;
}

export function isLikelyMasked(value) {
  return typeof value === "string" && /^\*{4,}/.test(value);
}

export function pickTruthy(...values) {
  for (const value of values) {
    if (value !== undefined && value !== null && value !== "") {
      return value;
    }
  }
  return undefined;
}

export function toPositiveInt(value, fallback) {
  const parsed = Number.parseInt(String(value), 10);
  if (Number.isNaN(parsed) || parsed <= 0) {
    return fallback;
  }
  return parsed;
}

export function nowIso() {
  return new Date().toISOString();
}
</file>

<file path="deploy/docker-init.sh">
#!/usr/bin/env bash
set -euo pipefail

ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
cd "$ROOT_DIR"
export COMPOSE_PROJECT_NAME="openclawpanel"

require_cmd() {
  if ! command -v "$1" >/dev/null 2>&1; then
    echo "缺少依赖: $1"
    exit 1
  fi
}

require_cmd docker
docker compose version >/dev/null 2>&1 || {
  echo "docker compose 不可用"
  exit 1
}

pull_with_retry() {
  local service="$1"
  local max_attempts="${2:-5}"
  local attempt

  for ((attempt=1; attempt<=max_attempts; attempt++)); do
    echo "拉取 ${service} 镜像（第 ${attempt}/${max_attempts} 次）..."
    if docker compose pull "$service"; then
      return 0
    fi
    if (( attempt < max_attempts )); then
      sleep $((attempt * 3))
    fi
  done

  return 1
}

cleanup_conflict_container() {
  local name="$1"
  local existing_project

  if ! docker ps -a --format '{{.Names}}' | grep -qx "$name"; then
    return 0
  fi

  existing_project="$(docker inspect -f '{{ index .Config.Labels "com.docker.compose.project" }}' "$name" 2>/dev/null || true)"
  if [[ -z "$existing_project" || "$existing_project" == "$COMPOSE_PROJECT_NAME" ]]; then
    return 0
  fi

  echo "检测到旧容器 ${name}（compose 项目: ${existing_project}），为避免命名冲突将自动移除。"
  docker rm -f "$name" >/dev/null
}

mkdir -p ./data/openclaw ./data/openclaw/workspace ./data/panel

if [[ ! -f ./.env ]]; then
  cp ./.env.example ./.env
  if command -v openssl >/dev/null 2>&1; then
    token="$(openssl rand -hex 32)"
  else
    token="$(python3 - <<'PY'
import secrets
print(secrets.token_hex(32))
PY
)"
  fi
  sed -i "s/replace-with-random-token/${token}/g" ./.env
  echo ".env 已创建，并生成随机 OPENCLAW_GATEWAY_TOKEN"
fi

if [[ ! -f ./data/panel/panel.config.json ]]; then
  cp ./deploy/panel.config.docker.json ./data/panel/panel.config.json
  chmod 600 ./data/panel/panel.config.json || true
  echo "已写入 ./data/panel/panel.config.json"
fi

if [[ ! -f ./data/openclaw/openclaw.json ]]; then
  cat > ./data/openclaw/openclaw.json <<'EOF'
{
  "gateway": {
    "mode": "local"
  },
  "agents": {
    "defaults": {
      "model": {
        "primary": "openai/gpt-4o-mini"
      }
    }
  },
  "models": {
    "providers": {
      "openai": {
        "api": "openai-responses",
        "baseUrl": "https://api.openai.com/v1",
        "apiKey": "",
        "models": [
          {
            "id": "gpt-4o-mini",
            "name": "GPT-4o Mini",
            "contextWindow": 128000,
            "maxTokens": 16384
          }
        ]
      }
    }
  },
  "channels": {}
}
EOF
  chmod 600 ./data/openclaw/openclaw.json || true
  echo "已初始化 ./data/openclaw/openclaw.json"
fi

echo "拉取 OpenClaw 镜像..."
if ! pull_with_retry openclaw-gateway 5; then
  echo "拉取镜像失败，请检查网络或稍后重试。"
  exit 1
fi

cleanup_conflict_container openclaw-gateway
cleanup_conflict_container openclaw-panel

echo "构建面板镜像..."
docker compose build panel

echo "启动服务..."
docker compose up -d

panel_bind_ip="$(grep -E '^PANEL_BIND_IP=' ./.env | head -n1 | cut -d'=' -f2- || true)"
panel_port="$(grep -E '^PANEL_PORT=' ./.env | head -n1 | cut -d'=' -f2- || true)"
gateway_bind_ip="$(grep -E '^OPENCLAW_GATEWAY_BIND_IP=' ./.env | head -n1 | cut -d'=' -f2- || true)"
gateway_port="$(grep -E '^OPENCLAW_GATEWAY_PORT=' ./.env | head -n1 | cut -d'=' -f2- || true)"
panel_bind_ip="${panel_bind_ip:-127.0.0.1}"
panel_port="${panel_port:-18080}"
gateway_bind_ip="${gateway_bind_ip:-0.0.0.0}"
gateway_port="${gateway_port:-18789}"

panel_hint_host="$panel_bind_ip"
if [[ "$panel_hint_host" == "0.0.0.0" ]]; then
  panel_hint_host="127.0.0.1"
fi

echo ""
echo "启动完成："
echo "  面板(映射地址): http://${panel_hint_host}:${panel_port}"
echo "  网关(映射地址): http://${gateway_bind_ip}:${gateway_port}"
echo "  如需展示公网地址/Webhook地址，请编辑 data/panel/panel.config.json 的 reverse_proxy 字段。"
echo "  查看容器: docker compose ps"
echo "  查看网关日志: docker logs -f openclaw-gateway"
</file>

<file path="public/app-api.js">
export async function requestJson(fetchImpl, url, options = {}) {
  const { allowBusinessError = false, ...fetchOptions } = options;
  const headers = new Headers(fetchOptions.headers || {});
  const hasBody = fetchOptions.body !== undefined && fetchOptions.body !== null;
  if (hasBody && !headers.has("content-type")) {
    headers.set("content-type", "application/json");
  }
  const response = await fetchImpl(url, {
    ...fetchOptions,
    headers
  });

  let payload = null;
  try {
    payload = await response.json();
  } catch {
    throw new Error(`响应解析失败 (HTTP ${response.status})`);
  }

  if (!response.ok) {
    throw new Error(payload?.message || `请求失败 (HTTP ${response.status})`);
  }

  if (!allowBusinessError && payload?.ok === false) {
    throw new Error(payload.message || "请求失败");
  }

  return payload;
}
</file>

<file path="public/js/core/panel-core.js">
import { requestJson } from "../../app-api.js";
import { PANEL_ROUTES, isKnownPanelPath, panelByPath } from "../../app-routes.js";
import { AICODECAT_PROVIDER, resolveAicodecatBaseUrl, resolveProviderId } from "../../config-generator.js";

const THEME_KEY = "openclaw-panel-theme";
const DASHBOARD_CONTEXT_KEY = "openclaw-panel-dashboard-context-tokens";
const MODEL_TEMPLATE_MAP = {
  "aicodecat-gpt": {
    title: "GPT 系列模板",
    providerId: "aicodecat-gpt",
    api: "openai-responses",
    baseUrl: "https://aicode.cat/v1",
    models: [
      {
        id: "gpt-5.2",
        name: "GPT-5.2",
        reasoning: true,
        input: ["text", "image"],
        contextWindow: 400000,
        maxTokens: 128000
      },
      {
        id: "gpt-5.2-codex",
        name: "GPT-5.2 Codex",
        reasoning: true,
        input: ["text", "image"],
        contextWindow: 400000,
        maxTokens: 128000
      },
      {
        id: "gpt-5.3-codex",
        name: "GPT-5.3 Codex",
        reasoning: true,
        input: ["text", "image"],
        contextWindow: 400000,
        maxTokens: 128000
      }
    ]
  },
  "aicodecat-claude": {
    title: "Claude 系列模板",
    providerId: "aicodecat-claude",
    api: "anthropic-messages",
    baseUrl: "https://aicode.cat",
    models: [
      {
        id: "claude-opus-4-6",
        name: "Claude Opus 4.6",
        reasoning: true,
        input: ["text", "image"],
        contextWindow: 200000,
        maxTokens: 64000
      },
      {
        id: "claude-sonnet-4-5-20250929",
        name: "Claude Sonnet 4.5",
        reasoning: true,
        input: ["text", "image"],
        contextWindow: 200000,
        maxTokens: 64000
      },
      {
        id: "claude-haiku-4-5",
        name: "Claude Haiku 4.5",
        reasoning: true,
        input: ["text", "image"],
        contextWindow: 200000,
        maxTokens: 64000
      }
    ]
  },
  "aicodecat-gemini": {
    title: "Gemini 系列模板",
    providerId: "aicodecat-gemini",
    api: "google-generative-ai",
    baseUrl: "https://aicode.cat/v1beta",
    models: [
      {
        id: "gemini-3-pro-preview",
        name: "Gemini 3 Pro Preview",
        reasoning: false,
        input: ["text", "image"],
        contextWindow: 1048576,
        maxTokens: 65536
      },
      {
        id: "gemini-3-flash-preview",
        name: "Gemini 3 Flash Preview",
        reasoning: false,
        input: ["text", "image"],
        contextWindow: 1048576,
        maxTokens: 65536
      }
    ]
  }
};

const MODEL_PROFILE_BY_FAMILY = Object.freeze({
  gpt: {
    apiMode: "openai-responses",
    contextWindow: 400000,
    maxTokens: 128000
  },
  claude: {
    apiMode: "anthropic-messages",
    contextWindow: 200000,
    maxTokens: 64000
  },
  gemini: {
    apiMode: "google-generative-ai",
    contextWindow: 1048576,
    maxTokens: 65536
  }
});

const DEFAULT_MODEL_OPTIONS = Object.freeze(
  Object.values(MODEL_TEMPLATE_MAP)
    .flatMap((template) => template.models || [])
    .reduce((acc, item) => {
      const id = String(item?.id || "").trim();
      if (!id || acc.some((entry) => entry.id === id)) {
        return acc;
      }
      acc.push({
        id,
        name: String(item?.name || id).trim() || id
      });
      return acc;
    }, [])
);

const modelEditorState = {
  modelCatalog: {
    providers: [],
    modelRefs: []
  },
  defaultModelRefs: [],
  currentModelSettings: null,
  currentModelPayload: null,
  providerMode: "template",
  dashboardBound: false
};

const dashboardSummaryState = {
  errorCount: null,
  latestError: "",
  currentTag: "",
  latestTag: "",
  updateAvailable: false,
  updateWarning: ""
};

const skillsPageState = {
  bound: false,
  selectedSkillKey: "",
  selectedSkillConfig: null,
  skills: []
};

const chatConsoleState = {
  bound: false,
  selectedSessionKey: "",
  sessions: [],
  lastRunId: "",
  streamSource: null,
  streamSessionKey: "",
  streamLines: [],
  streamDeltasByRunId: {},
  streamThinkingByRunId: {},
  historyMessages: [],
  sending: false,
  attachments: [],
  staging: false
};

const channelSettingsSnapshot = {
  settings: null
};

const els = {
  messages: document.querySelector("#messages"),
  serviceOutput: document.querySelector("#service_output"),
  logOutput: document.querySelector("#log_output"),
  errorSummary: document.querySelector("#error_summary"),
  runtimeState: document.querySelector("#runtime_state"),
  metaServiceName: document.querySelector("#meta_service_name"),
  metaLogSource: document.querySelector("#meta_log_source"),
  dashboardPublicHint: document.querySelector("#dashboard_public_hint"),
  serviceState: document.querySelector("#service_state"),
  serviceHint: document.querySelector("#service_hint"),
  themeToggle: document.querySelector("#theme_toggle"),
  updateState: document.querySelector("#update_state"),
  updateHint: document.querySelector("#update_hint"),
  updateCurrentTag: document.querySelector("#update_current_tag"),
  updateLatestTag: document.querySelector("#update_latest_tag")
};

function setMessage(message, type = "info") {
  if (!els.messages) {
    return;
  }
  const line = `[${new Date().toLocaleTimeString()}][${type}] ${message}`;
  els.messages.textContent = `${line}\n${els.messages.textContent}`.slice(0, 12000);
}

function setInput(id, value) {
  const el = document.querySelector(`#${id}`);
  if (!el) {
    return;
  }
  if (el.type === "checkbox") {
    el.checked = Boolean(value);
    return;
  }
  el.value = value ?? "";
}

function setText(id, value) {
  const el = document.querySelector(`#${id}`);
  if (!el) {
    return;
  }
  el.textContent = value ?? "";
}

function getInputValue(id) {
  const el = document.querySelector(`#${id}`);
  if (!el) {
    return "";
  }
  if (el.type === "checkbox") {
    return el.checked;
  }
  return el.value;
}

async function api(url, options = {}) {
  return requestJson(fetch, url, options);
}

function setupTabs() {
  const tabs = Array.from(document.querySelectorAll(".tab"));
  const panels = Array.from(document.querySelectorAll(".panel"));
  const hasPanel = (panelName) => panels.some((panel) => panel.dataset.panel === panelName);

  const activate = (panelName, { push = false, replace = false } = {}) => {
    tabs.forEach((tab) => {
      tab.classList.toggle("is-active", tab.dataset.tabTarget === panelName);
    });
    panels.forEach((panel) => {
      panel.classList.toggle("is-visible", panel.dataset.panel === panelName);
    });

    const route = PANEL_ROUTES[panelName] || "/model";
    if (push && window.location.pathname !== route) {
      window.history.pushState({ panel: panelName }, "", route);
    } else if (replace && window.location.pathname !== route) {
      window.history.replaceState({ panel: panelName }, "", route);
    }
  };

  tabs.forEach((tab) => {
    tab.addEventListener("click", (event) => {
      const targetPanel = String(tab.dataset.tabTarget || "").trim();
      if (!targetPanel || !hasPanel(targetPanel)) {
        return;
      }
      event.preventDefault();
      activate(targetPanel, { push: true });
    });
  });

  window.addEventListener("popstate", () => {
    activate(panelByPath(window.location.pathname));
  });

  const initialPanel = panelByPath(window.location.pathname);
  const shouldNormalizePath = !isKnownPanelPath(window.location.pathname);
  if (hasPanel(initialPanel)) {
    activate(initialPanel, { replace: shouldNormalizePath });
  } else if (panels.length > 0) {
    activate(panels[0].dataset.panel, { replace: shouldNormalizePath });
  }
}

function applyTheme(theme) {
  const value = theme === "dark" ? "dark" : "light";
  document.documentElement.dataset.theme = value;
  document.body.dataset.theme = value;
  document.documentElement.classList.toggle("sl-theme-dark", value === "dark");
  document.documentElement.classList.toggle("sl-theme-light", value !== "dark");
  if (els.themeToggle) {
    els.themeToggle.textContent = value === "dark" ? "切换到白色模式" : "切换到深夜模式";
  }
}

function setupTheme() {
  const saved = localStorage.getItem(THEME_KEY);
  applyTheme(saved || "light");

  els.themeToggle?.addEventListener("click", () => {
    const next = document.body.dataset.theme === "dark" ? "light" : "dark";
    localStorage.setItem(THEME_KEY, next);
    applyTheme(next);
    setMessage(`界面已切换到${next === "dark" ? "深夜模式" : "白色模式"}`, "info");
  });
}

function toPositiveInt(value, fallback) {
  const parsed = Number(value);
  if (!Number.isFinite(parsed) || parsed <= 0) {
    return fallback;
  }
  return Math.floor(parsed);
}

function normalizeModelDraft(rawModel, fallbackModel = {}) {
  const id = String(rawModel?.id || fallbackModel?.id || "").trim();
  const name = String(rawModel?.name || fallbackModel?.name || id).trim() || id;
  if (!id) {
    return null;
  }
  const fallbackContextWindow = toPositiveInt(fallbackModel?.contextWindow, 200000);
  const fallbackMaxTokens = toPositiveInt(fallbackModel?.maxTokens, 8192);
  const normalized = {
    ...rawModel,
    id,
    name,
    contextWindow: toPositiveInt(rawModel?.contextWindow, fallbackContextWindow),
    maxTokens: toPositiveInt(rawModel?.maxTokens, fallbackMaxTokens)
  };
  const sourceInput = Array.isArray(rawModel?.input)
    ? rawModel.input
    : Array.isArray(fallbackModel?.input)
      ? fallbackModel.input
      : [];
  if (Array.isArray(sourceInput) && sourceInput.length > 0) {
    normalized.input = [...new Set(sourceInput.map((item) => String(item).trim()).filter(Boolean))];
  }
  if (rawModel?.reasoning !== undefined) {
    normalized.reasoning = Boolean(rawModel.reasoning);
  } else if (fallbackModel?.reasoning !== undefined) {
    normalized.reasoning = Boolean(fallbackModel.reasoning);
  }
  return normalized;
}

function buildModelPayload({
  primary,
  providerId,
  providerApi,
  providerBaseUrl,
  providerApiKey = "",
  modelId,
  modelName,
  contextWindow,
  maxTokens,
  providerModels = []
}) {
  return {
    primary: String(primary || "").trim(),
    providerId: String(providerId || "").trim(),
    providerApi: String(providerApi || "").trim(),
    providerBaseUrl: String(providerBaseUrl || "").trim(),
    providerApiKey: String(providerApiKey || "").trim(),
    modelId: String(modelId || "").trim(),
    modelName: String(modelName || modelId || "").trim(),
    contextWindow: toPositiveInt(contextWindow, 200000),
    maxTokens: toPositiveInt(maxTokens, 8192),
    providerModels: Array.isArray(providerModels)
      ? providerModels.map((item) => normalizeModelDraft(item)).filter(Boolean)
      : []
  };
}

function modelFamilyById(modelId) {
  const value = String(modelId || "").trim().toLowerCase();
  if (value.startsWith("claude-")) {
    return "claude";
  }
  if (value.startsWith("gemini-")) {
    return "gemini";
  }
  return "gpt";
}

function buildDefaultModelEntry(modelId, modelName = "") {
  const id = String(modelId || "").trim();
  if (!id) {
    return null;
  }
  const family = modelFamilyById(id);
  const profile = MODEL_PROFILE_BY_FAMILY[family] || MODEL_PROFILE_BY_FAMILY.gpt;
  const providerApi = profile.apiMode;
  const providerId = resolveProviderId(AICODECAT_PROVIDER, providerApi);
  return {
    ref: `${providerId}/${id}`,
    providerId,
    providerApi,
    providerBaseUrl: resolveAicodecatBaseUrl(providerApi),
    modelId: id,
    modelName: String(modelName || id).trim() || id,
    contextWindow: profile.contextWindow,
    maxTokens: profile.maxTokens
  };
}

function fillDefaultModelOptions(selectEl, { includeCustom = false, selectedValue = "" } = {}) {
  if (!(selectEl instanceof HTMLSelectElement)) {
    return "";
  }

  const currentValue = String(selectedValue || selectEl.value || "").trim();
  selectEl.innerHTML = "";
  DEFAULT_MODEL_OPTIONS.forEach((item) => {
    const option = document.createElement("option");
    option.value = item.id;
    option.textContent = item.id;
    selectEl.appendChild(option);
  });

  if (includeCustom) {
    const customOption = document.createElement("option");
    customOption.value = "custom";
    customOption.textContent = "自定义";
    selectEl.appendChild(customOption);
  }

  if (DEFAULT_MODEL_OPTIONS.some((item) => item.id === currentValue)) {
    selectEl.value = currentValue;
  } else if (includeCustom && currentValue === "custom") {
    selectEl.value = "custom";
  } else {
    selectEl.value = DEFAULT_MODEL_OPTIONS[0]?.id || (includeCustom ? "custom" : "");
  }

  return String(selectEl.value || "").trim();
}

function toNonNegativeInt(value) {
  const parsed = Number(value);
  if (!Number.isFinite(parsed) || parsed < 0) {
    return null;
  }
  return Math.floor(parsed);
}

function parseModelRef(ref) {
  const value = String(ref || "").trim();
  if (!value.includes("/")) {
    return {
      providerId: "",
      modelId: value
    };
  }
  const [providerId, modelId] = value.split("/", 2);
  return {
    providerId: String(providerId || "").trim(),
    modelId: String(modelId || "").trim()
  };
}

function getDashboardContextTokens() {
  const inputs = Array.from(document.querySelectorAll("[data-dashboard-context-input]"));
  for (const input of inputs) {
    const parsed = toNonNegativeInt(input?.value || "");
    if (parsed !== null) {
      return parsed;
    }
  }
  return toNonNegativeInt(localStorage.getItem(DASHBOARD_CONTEXT_KEY) || "");
}

function formatLocalTime(value) {
  const timestamp = Number(value);
  if (!Number.isFinite(timestamp) || timestamp <= 0) {
    return "-";
  }
  return new Date(timestamp).toLocaleString();
}

function setStackListEmpty(container, message) {
  if (!container) {
    return;
  }
  container.innerHTML = "";
  const empty = document.createElement("p");
  empty.className = "dashboard-list-empty";
  empty.textContent = message;
  container.appendChild(empty);
}

function createDashboardStatusTag(text, variant = "neutral") {
  const tag = document.createElement("sl-tag");
  tag.size = "small";
  tag.pill = true;
  tag.variant = variant;
  tag.textContent = text;
  return tag;
}

const hasPanel = (panelName) => Boolean(document.querySelector(`.panel[data-panel="${panelName}"]`));

export {
  AICODECAT_PROVIDER,
  DASHBOARD_CONTEXT_KEY,
  DEFAULT_MODEL_OPTIONS,
  MODEL_PROFILE_BY_FAMILY,
  MODEL_TEMPLATE_MAP,
  THEME_KEY,
  api,
  applyTheme,
  buildDefaultModelEntry,
  buildModelPayload,
  channelSettingsSnapshot,
  chatConsoleState,
  createDashboardStatusTag,
  dashboardSummaryState,
  els,
  fillDefaultModelOptions,
  formatLocalTime,
  getDashboardContextTokens,
  getInputValue,
  hasPanel,
  isKnownPanelPath,
  modelEditorState,
  modelFamilyById,
  normalizeModelDraft,
  panelByPath,
  parseModelRef,
  setInput,
  setMessage,
  setStackListEmpty,
  setText,
  setupTabs,
  setupTheme,
  skillsPageState,
  toNonNegativeInt,
  toPositiveInt
};
</file>

<file path="public/js/pages/config-generator-page.js">
import {
  AICODECAT_PROVIDER,
  DEFAULT_MODEL_OPTIONS,
  MODEL_PROFILE_BY_FAMILY,
  fillDefaultModelOptions,
  modelFamilyById,
  setMessage
} from "../core/panel-core.js";
import { apiModeFamily, convertConfig, resolveAicodecatBaseUrl } from "../../config-generator.js";

function setupConfigGenerator() {
  const providerEl = document.querySelector("#cfg_provider");
  const providerCustomEl = document.querySelector("#cfg_provider_custom");
  const apiModeEl = document.querySelector("#cfg_apimode");
  const apiModeCustomEl = document.querySelector("#cfg_apimode_custom");
  const baseUrlEl = document.querySelector("#cfg_baseurl");
  const baseUrlCustomEl = document.querySelector("#cfg_baseurl_custom");
  const modelIdEl = document.querySelector("#cfg_model_id");
  const modelIdCustomEl = document.querySelector("#cfg_model_id_custom");
  const apiKeyEl = document.querySelector("#cfg_apikey");
  const apiKeyToggleEl = document.querySelector("#cfg_apikey_toggle");
  const contextWindowEl = document.querySelector("#cfg_context_window");
  const maxTokensEl = document.querySelector("#cfg_max_tokens");
  const reasoningEl = document.querySelector("#cfg_reasoning");
  const inheritExistingEl = document.querySelector("#cfg_inherit_existing");
  const configInputEl = document.querySelector("#cfg_input");
  const outputEl = document.querySelector("#cfg_output");
  const statusEl = document.querySelector("#cfg_status");
  const generateBtn = document.querySelector("#cfg_generate");
  const copyBtn = document.querySelector("#cfg_copy");

  if (
    !providerEl ||
    !apiModeEl ||
    !baseUrlEl ||
    !modelIdEl ||
    !apiKeyEl ||
    !contextWindowEl ||
    !maxTokensEl ||
    !reasoningEl ||
    !inheritExistingEl ||
    !configInputEl ||
    !outputEl ||
    !statusEl
  ) {
    return;
  }

  const fillGeneratorModelOptions = () => {
    fillDefaultModelOptions(modelIdEl, {
      includeCustom: true,
      selectedValue: String(modelIdEl.value || "").trim()
    });
  };

  fillGeneratorModelOptions();

  const modelByFamily = {
    gpt: DEFAULT_MODEL_OPTIONS.find((item) => modelFamilyById(item.id) === "gpt")?.id || "gpt-5.2",
    claude:
      DEFAULT_MODEL_OPTIONS.find((item) => modelFamilyById(item.id) === "claude")?.id ||
      "claude-sonnet-4-5-20250929",
    gemini:
      DEFAULT_MODEL_OPTIONS.find((item) => modelFamilyById(item.id) === "gemini")?.id || "gemini-3-pro-preview"
  };
  const reasoningByFamily = {
    gpt: true,
    claude: true,
    gemini: false
  };

  const updateCustomFieldVisibility = (selectEl, inputEl) => {
    if (!selectEl || !inputEl) {
      return;
    }
    const useCustom = selectEl.value === "custom";
    inputEl.classList.toggle("is-visible", useCustom);
  };

  const getFieldValue = (selectEl, customEl) => {
    if (!selectEl) {
      return "";
    }
    if (selectEl.value === "custom") {
      return String(customEl?.value || "").trim();
    }
    return String(selectEl.value || "").trim();
  };

  const toPositiveInt = (value) => {
    const parsed = Number(value);
    if (!Number.isFinite(parsed) || parsed <= 0) {
      return null;
    }
    return Math.floor(parsed);
  };

  const resolveFamilyForDefaults = () => {
    const modelId = getFieldValue(modelIdEl, modelIdCustomEl);
    if (modelId) {
      return modelFamilyById(modelId);
    }
    return apiModeFamily(getFieldValue(apiModeEl, apiModeCustomEl));
  };

  const applyModelAdvancedDefaults = (force = false) => {
    const family = resolveFamilyForDefaults();
    const profile = MODEL_PROFILE_BY_FAMILY[family] || MODEL_PROFILE_BY_FAMILY.gpt;
    if (force || !String(contextWindowEl.value || "").trim()) {
      contextWindowEl.value = String(profile?.contextWindow || 200000);
    }
    if (force || !String(maxTokensEl.value || "").trim()) {
      maxTokensEl.value = String(profile?.maxTokens || 8192);
    }
    if (force) {
      reasoningEl.checked = Boolean(reasoningByFamily[family]);
    }
  };

  const setStatus = (text) => {
    statusEl.value = text;
    const isFail = text === "失败";
    const isDone = text === "完成";
    const isWorking = text === "处理中";
    statusEl.classList.toggle("is-fail", isFail);
    statusEl.classList.toggle("is-done", isDone);
    statusEl.classList.toggle("is-working", isWorking);
  };

  const setOutputText = (text, type = "info") => {
    outputEl.textContent = text;
    outputEl.classList.toggle("is-error", type === "error");
  };

  const syncApiKeyVisibility = () => {
    if (!apiKeyToggleEl) {
      return;
    }
    const isVisible = apiKeyEl.type === "text";
    apiKeyToggleEl.textContent = "👁";
    apiKeyToggleEl.classList.toggle("is-visible", isVisible);
    apiKeyToggleEl.setAttribute("aria-pressed", isVisible ? "true" : "false");
    apiKeyToggleEl.setAttribute("aria-label", isVisible ? "隐藏 API 密钥" : "显示 API 密钥");
    apiKeyToggleEl.setAttribute("title", isVisible ? "隐藏 API 密钥" : "显示 API 密钥");
  };

  const syncBaseUrlAndModelForAicodecat = () => {
    const provider = getFieldValue(providerEl, providerCustomEl);
    const apiMode = getFieldValue(apiModeEl, apiModeCustomEl);
    if (provider !== AICODECAT_PROVIDER) {
      return;
    }

    if (baseUrlEl.value !== "custom") {
      baseUrlEl.value = resolveAicodecatBaseUrl(apiMode);
      updateCustomFieldVisibility(baseUrlEl, baseUrlCustomEl);
    }

    if (modelIdEl.value !== "custom") {
      const family = apiModeFamily(apiMode);
      modelIdEl.value = modelByFamily[family] || modelByFamily.gpt;
      updateCustomFieldVisibility(modelIdEl, modelIdCustomEl);
    }
    applyModelAdvancedDefaults(true);
  };

  [providerEl, apiModeEl, baseUrlEl, modelIdEl].forEach((selectEl) => {
    const customEl = document.querySelector(`#${selectEl.id}_custom`);
    selectEl.addEventListener("change", () => {
      updateCustomFieldVisibility(selectEl, customEl);
      if (selectEl === providerEl || selectEl === apiModeEl) {
        syncBaseUrlAndModelForAicodecat();
      } else if (selectEl === modelIdEl) {
        applyModelAdvancedDefaults(true);
      }
    });
    updateCustomFieldVisibility(selectEl, customEl);
  });

  apiKeyToggleEl?.addEventListener("click", () => {
    const shouldShow = apiKeyEl.type === "password";
    apiKeyEl.type = shouldShow ? "text" : "password";
    syncApiKeyVisibility();
    apiKeyEl.focus({ preventScroll: true });
  });
  syncApiKeyVisibility();

  copyBtn?.addEventListener("click", async () => {
    try {
      await navigator.clipboard.writeText(outputEl.textContent || "");
      copyBtn.textContent = "已复制";
      window.setTimeout(() => {
        copyBtn.textContent = "复制结果";
      }, 1200);
    } catch {
      copyBtn.textContent = "复制失败";
      window.setTimeout(() => {
        copyBtn.textContent = "复制结果";
      }, 1200);
    }
  });

  generateBtn?.addEventListener("click", () => {
    const contextWindow = toPositiveInt(contextWindowEl.value);
    const maxTokens = toPositiveInt(maxTokensEl.value);
    const payload = {
      config: String(configInputEl.value || "").trim(),
      baseurl: getFieldValue(baseUrlEl, baseUrlCustomEl),
      apikey: String(apiKeyEl.value || "").trim(),
      apimode: getFieldValue(apiModeEl, apiModeCustomEl),
      provider: getFieldValue(providerEl, providerCustomEl),
      model_id: getFieldValue(modelIdEl, modelIdCustomEl),
      context_window: contextWindow,
      max_tokens: maxTokens,
      reasoning: Boolean(reasoningEl.checked),
      inherit_existing: String(inheritExistingEl.value || "").trim() === "true"
    };

    if (!payload.config) {
      setOutputText("错误: 请输入原始 Config JSON", "error");
      setStatus("失败");
      return;
    }
    if (!payload.baseurl) {
      setOutputText("错误: 请选择或输入 Base URL", "error");
      setStatus("失败");
      return;
    }
    if (!payload.apikey) {
      setOutputText("错误: 请输入 API Key", "error");
      setStatus("失败");
      return;
    }
    if (!payload.provider || !payload.apimode || !payload.model_id) {
      setOutputText("错误: provider / apimode / model_id 不能为空", "error");
      setStatus("失败");
      return;
    }
    if (payload.context_window === null) {
      setOutputText("错误: 请填写有效的模型最大上下文（正整数）", "error");
      setStatus("失败");
      return;
    }
    if (payload.max_tokens === null) {
      setOutputText("错误: 请填写有效的最大输出内容（正整数）", "error");
      setStatus("失败");
      return;
    }

    setStatus("处理中");
    try {
      const result = convertConfig(payload);
      setOutputText(JSON.stringify(result, null, 2), "ok");
      setStatus("完成");
      setMessage("配置生成完成（仅前端本地转换）", "ok");
    } catch (error) {
      setOutputText(`错误: ${error.message || String(error)}`, "error");
      setStatus("失败");
      setMessage(`配置生成失败：${error.message || String(error)}`, "error");
    }
  });

  syncBaseUrlAndModelForAicodecat();
  applyModelAdvancedDefaults(false);
}

export { setupConfigGenerator };
</file>

<file path="src/gateway-client.js">
import crypto, { randomUUID } from "node:crypto";
import fs from "node:fs";
import os from "node:os";
import path from "node:path";
import { WebSocket } from "ws";

const DEFAULT_TIMEOUT_MS = 10_000;
const DEFAULT_RETRIES = 0;
const DEFAULT_RETRY_DELAY_MS = 1_000;
const DEFAULT_GATEWAY_PORT = 18_789;
const PROTOCOL_VERSION = 3;
const DEVICE_IDENTITY_VERSION = 1;
const ED25519_SPKI_PREFIX = Buffer.from("302a300506032b6570032100", "hex");

function toPositiveInt(value, fallback) {
  const parsed = Number(value);
  if (!Number.isFinite(parsed) || parsed <= 0) {
    return fallback;
  }
  return Math.floor(parsed);
}

function wait(ms) {
  return new Promise((resolve) => {
    setTimeout(resolve, ms);
  });
}

function trimString(value) {
  return String(value || "").trim();
}

function resolveHomePath(filePath) {
  const value = trimString(filePath);
  if (!value) {
    return value;
  }
  if (value === "~") {
    return os.homedir();
  }
  if (value.startsWith("~/") || value.startsWith("~\\")) {
    return path.join(os.homedir(), value.slice(2));
  }
  return value;
}

function safeParseJson(filePath) {
  try {
    if (!filePath || !fs.existsSync(filePath)) {
      return null;
    }
    const raw = fs.readFileSync(filePath, "utf8");
    return JSON.parse(raw);
  } catch {
    return null;
  }
}

function writeJsonFile(filePath, payload) {
  try {
    fs.mkdirSync(path.dirname(filePath), { recursive: true });
    fs.writeFileSync(filePath, `${JSON.stringify(payload, null, 2)}\n`, { mode: 0o600 });
    try {
      fs.chmodSync(filePath, 0o600);
    } catch {
      // best-effort permissions
    }
  } catch {
    // ignore write failures; runtime can continue with in-memory identity
  }
}

function base64UrlEncode(buf) {
  return Buffer.from(buf)
    .toString("base64")
    .replaceAll("+", "-")
    .replaceAll("/", "_")
    .replace(/=+$/g, "");
}

function base64UrlDecode(input) {
  const normalized = String(input || "").replaceAll("-", "+").replaceAll("_", "/");
  const padded = normalized + "=".repeat((4 - (normalized.length % 4)) % 4);
  return Buffer.from(padded, "base64");
}

function derivePublicKeyRaw(publicKeyPem) {
  const key = crypto.createPublicKey(publicKeyPem);
  const spki = key.export({ type: "spki", format: "der" });
  if (
    Buffer.isBuffer(spki) &&
    spki.length === ED25519_SPKI_PREFIX.length + 32 &&
    spki.subarray(0, ED25519_SPKI_PREFIX.length).equals(ED25519_SPKI_PREFIX)
  ) {
    return spki.subarray(ED25519_SPKI_PREFIX.length);
  }
  return Buffer.from(spki);
}

function publicKeyRawBase64UrlFromPem(publicKeyPem) {
  return base64UrlEncode(derivePublicKeyRaw(publicKeyPem));
}

function fingerprintPublicKey(publicKeyPem) {
  return crypto.createHash("sha256").update(derivePublicKeyRaw(publicKeyPem)).digest("hex");
}

function generateDeviceIdentity() {
  const { publicKey, privateKey } = crypto.generateKeyPairSync("ed25519");
  const publicKeyPem = publicKey.export({ type: "spki", format: "pem" }).toString();
  const privateKeyPem = privateKey.export({ type: "pkcs8", format: "pem" }).toString();
  return {
    deviceId: fingerprintPublicKey(publicKeyPem),
    publicKeyPem,
    privateKeyPem
  };
}

function resolveDefaultStateDir(panelConfig, env = process.env) {
  const configPath = resolveHomePath(
    trimString(env.OPENCLAW_CONFIG_PATH) || trimString(panelConfig?.openclaw?.config_path)
  );
  if (configPath) {
    return path.dirname(configPath);
  }
  return path.join(os.homedir(), ".openclaw");
}

function resolveGatewayIdentityPath(panelConfig, env = process.env) {
  const override = resolveHomePath(trimString(env.OPENCLAW_DEVICE_IDENTITY_PATH));
  if (override) {
    return override;
  }
  return path.join(resolveDefaultStateDir(panelConfig, env), "identity", "device.json");
}

function resolveGatewayDeviceAuthPath(identityPath) {
  return path.join(path.dirname(identityPath), "device-auth.json");
}

function loadOrCreateDeviceIdentity(identityPath) {
  const parsed = safeParseJson(identityPath);
  if (
    parsed?.version === DEVICE_IDENTITY_VERSION &&
    typeof parsed.deviceId === "string" &&
    typeof parsed.publicKeyPem === "string" &&
    typeof parsed.privateKeyPem === "string"
  ) {
    const derivedId = fingerprintPublicKey(parsed.publicKeyPem);
    const normalized = {
      version: DEVICE_IDENTITY_VERSION,
      deviceId: derivedId,
      publicKeyPem: parsed.publicKeyPem,
      privateKeyPem: parsed.privateKeyPem,
      createdAtMs: toPositiveInt(parsed.createdAtMs, Date.now())
    };
    if (parsed.deviceId !== derivedId) {
      writeJsonFile(identityPath, normalized);
    }
    return normalized;
  }
  const generated = generateDeviceIdentity();
  const stored = {
    version: DEVICE_IDENTITY_VERSION,
    ...generated,
    createdAtMs: Date.now()
  };
  writeJsonFile(identityPath, stored);
  return stored;
}

function loadStoredDeviceToken(identityPath, role) {
  const parsed = safeParseJson(resolveGatewayDeviceAuthPath(identityPath));
  const token = parsed?.tokens?.[role]?.token;
  return typeof token === "string" ? trimString(token) : "";
}

function buildDeviceAuthPayload({ deviceId, clientId, clientMode, role, scopes, signedAtMs, token, nonce }) {
  const version = nonce ? "v2" : "v1";
  const normalizedScopes = Array.isArray(scopes) ? scopes.map((value) => trimString(value)).filter(Boolean) : [];
  const base = [
    version,
    trimString(deviceId),
    trimString(clientId),
    trimString(clientMode),
    trimString(role),
    normalizedScopes.join(","),
    String(toPositiveInt(signedAtMs, Date.now())),
    trimString(token)
  ];
  if (version === "v2") {
    base.push(trimString(nonce));
  }
  return base.join("|");
}

function signDevicePayload(privateKeyPem, payload) {
  const privateKey = crypto.createPrivateKey(privateKeyPem);
  const signature = crypto.sign(null, Buffer.from(String(payload || ""), "utf8"), privateKey);
  return base64UrlEncode(signature);
}

function buildConnectDevice({ deviceIdentity, token, role, scopes, nonce }) {
  if (!deviceIdentity || !deviceIdentity.deviceId || !deviceIdentity.publicKeyPem || !deviceIdentity.privateKeyPem) {
    return undefined;
  }
  const signedAt = Date.now();
  try {
    const clientId = "cli";
    const clientMode = "cli";
    const payload = buildDeviceAuthPayload({
      deviceId: deviceIdentity.deviceId,
      clientId,
      clientMode,
      role,
      scopes,
      signedAtMs: signedAt,
      token,
      nonce
    });
    return {
      id: deviceIdentity.deviceId,
      publicKey: publicKeyRawBase64UrlFromPem(deviceIdentity.publicKeyPem),
      signature: signDevicePayload(deviceIdentity.privateKeyPem, payload),
      signedAt,
      ...(nonce ? { nonce } : {})
    };
  } catch {
    return undefined;
  }
}

export class GatewayRpcError extends Error {
  constructor(message, options = {}) {
    const text = String(message || "gateway rpc error");
    super(text);
    this.name = "GatewayRpcError";
    this.type = options.type || "unknown";
    this.method = options.method || "";
    this.code = options.code || "";
    this.attempt = toPositiveInt(options.attempt, 1);
    this.details = options.details || {};
    this.cause = options.cause;
  }
}

export function resolveGatewayWsUrl(panelConfig, env = process.env) {
  const envOverride = trimString(env.OPENCLAW_GATEWAY_WS_URL);
  if (envOverride) {
    return envOverride;
  }

  const explicit = trimString(panelConfig?.openclaw?.gateway_ws_url);
  if (explicit) {
    return explicit;
  }

  const runtime = trimString(panelConfig?.runtime?.mode) || "systemd";
  const host =
    runtime === "docker"
      ? trimString(panelConfig?.openclaw?.container_name) ||
        trimString(panelConfig?.openclaw?.service_name) ||
        "openclaw-gateway"
      : "127.0.0.1";
  const envPort =
    runtime === "docker" ? trimString(env.OPENCLAW_GATEWAY_CONTAINER_PORT) : trimString(env.OPENCLAW_GATEWAY_PORT);
  const port =
    toPositiveInt(envPort, 0) ||
    toPositiveInt(panelConfig?.openclaw?.gateway_port, 0) ||
    DEFAULT_GATEWAY_PORT;
  return `ws://${host}:${port}/ws`;
}

function categorizeErrorType(message, remoteError) {
  const text = String(message || "").toLowerCase();
  const remoteCode = String(remoteError?.code || "").toLowerCase();
  if (
    text.includes("unauthorized") ||
    text.includes("forbidden") ||
    text.includes("auth") ||
    remoteCode.includes("unauthorized") ||
    remoteCode.includes("forbidden")
  ) {
    return "auth";
  }
  if (remoteError) {
    return "remote";
  }
  if (text.includes("timeout")) {
    return "timeout";
  }
  if (
    text.includes("closed") ||
    text.includes("connect") ||
    text.includes("socket") ||
    text.includes("network") ||
    text.includes("econn")
  ) {
    return "network";
  }
  if (text.includes("parse") || text.includes("json") || text.includes("protocol")) {
    return "protocol";
  }
  return "unknown";
}

export function normalizeGatewayError(error, context = {}) {
  if (error instanceof GatewayRpcError) {
    return error;
  }
  const message = String(error?.message || error || "gateway rpc error");
  const remoteError = context.remoteError;
  return new GatewayRpcError(message, {
    type: categorizeErrorType(message, remoteError),
    code: trimString(remoteError?.code),
    method: trimString(context.method),
    attempt: toPositiveInt(context.attempt, 1),
    details: {
      url: trimString(context.url),
      closeCode: context.closeCode,
      closeReason: trimString(context.closeReason),
      remoteError
    },
    cause: error
  });
}

function isRetryable(error) {
  const type = error instanceof GatewayRpcError ? error.type : "unknown";
  return type === "timeout" || type === "network" || type === "protocol";
}

function buildConnectParams({ token, password, nonce, role, scopes, deviceIdentity }) {
  const auth = {};
  if (trimString(token)) {
    auth.token = trimString(token);
  }
  if (trimString(password)) {
    auth.password = trimString(password);
  }
  const hasAuth = Object.keys(auth).length > 0;
  return {
    minProtocol: PROTOCOL_VERSION,
    maxProtocol: PROTOCOL_VERSION,
    client: {
      id: "cli",
      displayName: "openclaw-panel",
      version: "0.1.1",
      platform: process.platform,
      mode: "cli",
      instanceId: randomUUID()
    },
    caps: [],
    role,
    scopes,
    device: buildConnectDevice({
      deviceIdentity,
      token,
      role,
      scopes,
      nonce
    }),
    ...(hasAuth ? { auth } : {})
  };
}

function resolveGatewayAuthContext(panelConfig, token, role) {
  const identityPath = resolveGatewayIdentityPath(panelConfig);
  const deviceIdentity = loadOrCreateDeviceIdentity(identityPath);
  const tokenWithFallback = trimString(token) || loadStoredDeviceToken(identityPath, role);
  return {
    identityPath,
    deviceIdentity,
    tokenWithFallback
  };
}

async function requestGatewayOnce({
  url,
  method,
  params,
  expectFinal,
  timeoutMs,
  token,
  password,
  role,
  scopes,
  deviceIdentity,
  attempt
}) {
  return await new Promise((resolve, reject) => {
    const ws = new WebSocket(url);
    const connectRequestIds = new Set();
    let rpcRequestId = "";
    let settled = false;
    let connected = false;
    let connectSent = false;
    let timeoutHandle = null;
    let connectDelayHandle = null;
    const connectDelayMs = Math.min(750, Math.max(0, Math.floor(timeoutMs / 5)));

    const clearTimers = () => {
      if (timeoutHandle) {
        clearTimeout(timeoutHandle);
      }
      timeoutHandle = null;
      if (connectDelayHandle) {
        clearTimeout(connectDelayHandle);
      }
      connectDelayHandle = null;
    };

    const finish = (error, payload) => {
      if (settled) {
        return;
      }
      settled = true;
      clearTimers();
      try {
        ws.close();
      } catch {
        // ignore close failure
      }
      if (error) {
        reject(normalizeGatewayError(error, { method, url, attempt }));
      } else {
        resolve(payload);
      }
    };

    const failWithContext = (error, context = {}) => {
      if (settled) {
        return;
      }
      settled = true;
      clearTimers();
      try {
        ws.close();
      } catch {
        // ignore close failure
      }
      reject(
        normalizeGatewayError(error, {
          method,
          url,
          attempt,
          ...context
        })
      );
    };

    const sendConnect = (nonce = "") => {
      if (settled || connected || connectSent || ws.readyState !== WebSocket.OPEN) {
        return;
      }
      connectSent = true;
      const id = randomUUID();
      connectRequestIds.add(id);
      ws.send(
        JSON.stringify({
          type: "req",
          id,
          method: "connect",
          params: buildConnectParams({
            token,
            password,
            nonce,
            role,
            scopes,
            deviceIdentity
          })
        })
      );
    };

    const sendRpc = () => {
      if (settled || !connected || ws.readyState !== WebSocket.OPEN) {
        return;
      }
      rpcRequestId = randomUUID();
      ws.send(
        JSON.stringify({
          type: "req",
          id: rpcRequestId,
          method,
          params: params ?? {}
        })
      );
    };

    timeoutHandle = setTimeout(() => {
      failWithContext(new Error(`gateway rpc timeout after ${timeoutMs}ms`));
    }, timeoutMs);

    ws.on("open", () => {
      connectDelayHandle = setTimeout(() => {
        sendConnect("");
      }, connectDelayMs);
    });

    ws.on("error", (error) => {
      failWithContext(new Error(`gateway socket error: ${error.message || String(error)}`));
    });

    ws.on("close", (code, reason) => {
      if (settled) {
        return;
      }
      failWithContext(new Error(`gateway closed (${code}): ${String(reason || "").trim() || "no reason"}`), {
        closeCode: code,
        closeReason: String(reason || "")
      });
    });

    ws.on("message", (raw) => {
      if (settled) {
        return;
      }

      let frame;
      try {
        frame = JSON.parse(String(raw || ""));
      } catch (error) {
        failWithContext(new Error(`gateway protocol parse error: ${error.message || String(error)}`));
        return;
      }

      const frameType = trimString(frame?.type).toLowerCase();

      if (frameType === "evt" || frameType === "event") {
        if (frame?.event === "connect.challenge") {
          const nonce = trimString(frame?.payload?.nonce);
          sendConnect(nonce);
        }
        return;
      }

      if (frameType !== "res") {
        return;
      }

      if (!connected && connectRequestIds.has(frame.id)) {
        if (!frame.ok) {
          failWithContext(new Error(frame?.error?.message || "gateway connect rejected"), {
            remoteError: frame?.error || {}
          });
          return;
        }
        connected = true;
        connectRequestIds.clear();
        sendRpc();
        return;
      }

      if (!rpcRequestId || frame.id !== rpcRequestId) {
        return;
      }

      if (!frame.ok) {
        failWithContext(new Error(frame?.error?.message || "gateway rpc failed"), {
          remoteError: frame?.error || {}
        });
        return;
      }

      if (expectFinal && frame?.payload?.status === "accepted") {
        return;
      }

      finish(null, frame.payload);
    });
  });
}

export async function callGatewayRpc({
  panelConfig,
  url,
  method,
  params = {},
  expectFinal = false,
  timeoutMs = DEFAULT_TIMEOUT_MS,
  retries = DEFAULT_RETRIES,
  retryDelayMs = DEFAULT_RETRY_DELAY_MS,
  token = "",
  password = "",
  role = "operator",
  scopes = ["operator.admin", "operator.approvals", "operator.pairing"]
}) {
  const targetUrl = trimString(url) || resolveGatewayWsUrl(panelConfig);
  const { deviceIdentity, tokenWithFallback } = resolveGatewayAuthContext(panelConfig, token, role);
  const maxAttempts = Math.max(1, toPositiveInt(retries, DEFAULT_RETRIES) + 1);
  const effectiveTimeoutMs = toPositiveInt(timeoutMs, DEFAULT_TIMEOUT_MS);
  const effectiveRetryDelayMs = toPositiveInt(retryDelayMs, DEFAULT_RETRY_DELAY_MS);

  let lastError;
  for (let attempt = 1; attempt <= maxAttempts; attempt++) {
    try {
      return await requestGatewayOnce({
        url: targetUrl,
        method,
        params,
        expectFinal: Boolean(expectFinal),
        timeoutMs: effectiveTimeoutMs,
        token: tokenWithFallback,
        password,
        role,
        scopes,
        deviceIdentity,
        attempt
      });
    } catch (error) {
      const normalized = normalizeGatewayError(error, {
        method,
        url: targetUrl,
        attempt
      });
      lastError = normalized;
      if (attempt >= maxAttempts || !isRetryable(normalized)) {
        throw normalized;
      }
      await wait(effectiveRetryDelayMs);
    }
  }

  throw lastError || new GatewayRpcError("gateway rpc failed", { type: "unknown", method });
}

export function subscribeGatewayEvents({
  panelConfig,
  url,
  token = "",
  password = "",
  role = "operator",
  scopes = ["operator.admin", "operator.approvals", "operator.pairing"],
  connectDelayMs = 750,
  onEvent,
  onError,
  onClose
}) {
  const targetUrl = trimString(url) || resolveGatewayWsUrl(panelConfig);
  const { deviceIdentity, tokenWithFallback } = resolveGatewayAuthContext(panelConfig, token, role);
  const connectRequestIds = new Set();
  let ws = null;
  let closed = false;
  let connected = false;
  let connectSent = false;
  let connectDelayHandle = null;
  let readySettled = false;
  let readyResolve;
  let readyReject;

  const ready = new Promise((resolve, reject) => {
    readyResolve = resolve;
    readyReject = reject;
  });

  const settleReady = (error) => {
    if (readySettled) {
      return;
    }
    readySettled = true;
    if (error) {
      readyReject(error);
      return;
    }
    readyResolve({
      url: targetUrl
    });
  };

  const clearTimers = () => {
    if (connectDelayHandle) {
      clearTimeout(connectDelayHandle);
      connectDelayHandle = null;
    }
  };

  const notifyError = (error, context = {}) => {
    const normalized = normalizeGatewayError(error, {
      url: targetUrl,
      method: "connect",
      ...context
    });
    onError?.(normalized);
    settleReady(normalized);
  };

  const sendConnect = (nonce = "") => {
    if (closed || connected || connectSent || !ws || ws.readyState !== WebSocket.OPEN) {
      return;
    }
    connectSent = true;
    const id = randomUUID();
    connectRequestIds.add(id);
    ws.send(
      JSON.stringify({
        type: "req",
        id,
        method: "connect",
        params: buildConnectParams({
          token: tokenWithFallback,
          password,
          nonce,
          role,
          scopes,
          deviceIdentity
        })
      })
    );
  };

  const close = () => {
    if (closed) {
      return;
    }
    closed = true;
    clearTimers();
    try {
      ws?.close();
    } catch {
      // ignore close failure
    }
  };

  ws = new WebSocket(targetUrl);
  ws.on("open", () => {
    if (closed) {
      return;
    }
    const effectiveConnectDelayMs = Math.max(0, Math.min(5000, toPositiveInt(connectDelayMs, 750)));
    connectDelayHandle = setTimeout(() => {
      sendConnect("");
    }, effectiveConnectDelayMs);
  });

  ws.on("error", (error) => {
    notifyError(new Error(`gateway socket error: ${error.message || String(error)}`));
  });

  ws.on("close", (code, reason) => {
    clearTimers();
    const reasonText = String(reason || "").trim() || "no reason";
    if (!connected && !closed) {
      settleReady(
        normalizeGatewayError(new Error(`gateway closed (${code}): ${reasonText}`), {
          url: targetUrl,
          method: "connect",
          closeCode: code,
          closeReason: reasonText
        })
      );
    }
    onClose?.({
      code,
      reason: reasonText
    });
  });

  ws.on("message", (raw) => {
    if (closed) {
      return;
    }

    let frame;
    try {
      frame = JSON.parse(String(raw || ""));
    } catch (error) {
      notifyError(new Error(`gateway protocol parse error: ${error.message || String(error)}`));
      return;
    }

    const frameType = trimString(frame?.type).toLowerCase();
    if (frameType === "evt" || frameType === "event") {
      if (frame?.event === "connect.challenge") {
        const nonce = trimString(frame?.payload?.nonce);
        connectSent = false;
        sendConnect(nonce);
        return;
      }
      if (connected) {
        onEvent?.(frame);
      }
      return;
    }

    if (frameType !== "res") {
      return;
    }
    if (!connectRequestIds.has(frame.id)) {
      return;
    }
    connectRequestIds.delete(frame.id);
    if (!frame.ok) {
      notifyError(new Error(frame?.error?.message || "gateway connect rejected"), {
        remoteError: frame?.error || {}
      });
      close();
      return;
    }

    connected = true;
    settleReady(null);
  });

  return {
    ready,
    close,
    get connected() {
      return connected;
    }
  };
}
</file>

<file path="src/logs.js">
import fs from "node:fs/promises";
import { spawn } from "node:child_process";
import { expandHome, toPositiveInt } from "./utils.js";

function splitLines(raw) {
  return String(raw || "")
    .split(/\r?\n/)
    .map((line) => line.trimEnd())
    .filter(Boolean);
}

function filterLines(lines, keyword) {
  if (!keyword) {
    return lines;
  }
  const lower = keyword.toLowerCase();
  return lines.filter((line) => line.toLowerCase().includes(lower));
}

async function readLastLinesFromFile(filePath, maxLines) {
  try {
    const raw = await fs.readFile(expandHome(filePath), "utf8");
    const lines = splitLines(raw);
    return lines.slice(-maxLines);
  } catch (error) {
    if (error.code === "ENOENT") {
      return [];
    }
    throw error;
  }
}

function runCapture(command, args) {
  return new Promise((resolve, reject) => {
    const child = spawn(command, args, { stdio: ["ignore", "pipe", "pipe"] });
    let stdout = "";
    let stderr = "";
    child.stdout.on("data", (chunk) => {
      stdout += chunk.toString();
    });
    child.stderr.on("data", (chunk) => {
      stderr += chunk.toString();
    });
    child.on("error", reject);
    child.on("close", () => resolve({ stdout, stderr }));
  });
}

export async function getTailLogs({ panelConfig, lines = 200, filter = "" }) {
  const maxLines = Math.min(5000, toPositiveInt(lines, 200));
  const source = panelConfig.log.source;
  const containerName =
    panelConfig?.openclaw?.container_name || panelConfig?.openclaw?.service_name || "openclaw-gateway";

  if (source === "docker") {
    const { stdout, stderr } = await runCapture("docker", ["logs", "--tail", String(maxLines), containerName]);
    const merged = `${stdout}\n${stderr}`;
    return filterLines(splitLines(merged), filter);
  }

  if (source === "journal" && process.platform === "linux") {
    const { stdout, stderr } = await runCapture("journalctl", [
      "-u",
      panelConfig.openclaw.service_name,
      "-n",
      String(maxLines),
      "--no-pager",
      "-o",
      "short-iso"
    ]);

    const merged = `${stdout}\n${stderr}`;
    return filterLines(splitLines(merged), filter);
  }

  return filterLines(await readLastLinesFromFile(panelConfig.log.file_path, maxLines), filter);
}

export async function getErrorSummary({ panelConfig, count = 20 }) {
  const lines = await getTailLogs({ panelConfig, lines: 1000, filter: "" });
  const errorPattern = /(error|fail|exception|panic|fatal|traceback)/i;
  const matched = lines.filter((line) => errorPattern.test(line));
  return matched.slice(-Math.min(200, toPositiveInt(count, 20)));
}

export function createLogStream({ panelConfig, onLine, onError }) {
  const source = panelConfig.log.source;
  const containerName =
    panelConfig?.openclaw?.container_name || panelConfig?.openclaw?.service_name || "openclaw-gateway";
  let child;

  if (source === "docker") {
    child = spawn("docker", ["logs", "-f", "--tail", "20", containerName]);
  } else if (source === "journal" && process.platform === "linux") {
    child = spawn("journalctl", [
      "-u",
      panelConfig.openclaw.service_name,
      "-f",
      "-n",
      "20",
      "--no-pager",
      "-o",
      "short-iso"
    ]);
  } else {
    child = spawn("tail", ["-n", "20", "-F", expandHome(panelConfig.log.file_path)]);
  }

  child.stdout.on("data", (chunk) => {
    const lines = splitLines(chunk.toString());
    for (const line of lines) {
      onLine(line);
    }
  });

  child.stderr.on("data", (chunk) => {
    const lines = splitLines(chunk.toString());
    for (const line of lines) {
      onError(line);
    }
  });

  child.on("error", (error) => {
    onError(error.message);
  });

  return () => {
    if (!child.killed) {
      child.kill("SIGTERM");
    }
  };
}
</file>

<file path="src/openclaw-config/apply.js">
import {
  normalizeModelDraft,
  parseDelimitedText,
  parseOptionalJson,
  resolveSecret,
  setOptionalNumber,
  setOptionalString
} from "./helpers.js";
import { settingsSchema } from "./schema.js";

function applySettings(currentConfig, payload) {
  const parsed = settingsSchema.parse(payload);
  const providerId = parsed.model.providerId.trim();
  const modelId = parsed.model.modelId.trim();
  const primaryRef = String(parsed.model.primary || "").trim() || `${providerId}/${modelId}`;

  const next = structuredClone(currentConfig || {});

  if (!next.models) {
    next.models = {};
  }
  if (!next.models.providers) {
    next.models.providers = {};
  }
  if (!next.models.providers[providerId]) {
    next.models.providers[providerId] = {};
  }

  const provider = next.models.providers[providerId];
  provider.baseUrl = parsed.model.providerBaseUrl;
  provider.api = parsed.model.providerApi;
  provider.apiKey = resolveSecret(parsed.model.providerApiKey, provider.apiKey);

  const existingProviderModels = Array.isArray(provider.models) ? [...provider.models] : [];
  const modelPatchList = Array.isArray(parsed.model.providerModels)
    ? parsed.model.providerModels.map((draft) => ({
        ...draft,
        id: String(draft.id || "").trim()
      }))
    : [];
  if (modelPatchList.length > 0) {
    const existingById = new Map(
      existingProviderModels
        .map((providerModel) => [String(providerModel?.id || "").trim(), providerModel])
        .filter(([id]) => Boolean(id))
    );
    const touchedIds = new Set();
    const mergedPatchedModels = modelPatchList
      .filter((draft) => draft.id)
      .map((draft) => {
        touchedIds.add(draft.id);
        return normalizeModelDraft(draft, existingById.get(draft.id) || {});
      });
    const untouchedModels = existingProviderModels.filter((providerModel) => {
      const id = String(providerModel?.id || "").trim();
      return id && !touchedIds.has(id);
    });
    provider.models = [...mergedPatchedModels, ...untouchedModels];
  } else {
    const existingModelIndex = existingProviderModels.findIndex((item) => String(item?.id || "") === modelId);
    const mergedModel = normalizeModelDraft(
      {
        id: modelId,
        name: parsed.model.modelName.trim(),
        contextWindow: parsed.model.contextWindow,
        maxTokens: parsed.model.maxTokens
      },
      existingModelIndex >= 0 ? existingProviderModels[existingModelIndex] : {}
    );
    if (existingModelIndex >= 0) {
      existingProviderModels[existingModelIndex] = mergedModel;
    } else {
      existingProviderModels.unshift(mergedModel);
    }
    provider.models = existingProviderModels;
  }

  if (!next.models.mode) {
    next.models.mode = "merge";
  }

  if (!next.agents) {
    next.agents = {};
  }
  if (!next.agents.defaults) {
    next.agents.defaults = {};
  }
  if (!next.agents.defaults.model) {
    next.agents.defaults.model = {};
  }
  next.agents.defaults.model.primary = primaryRef;

  if (parsed.channels) {
    if (!next.channels) {
      next.channels = {};
    }

    if (!next.channels.telegram) {
      next.channels.telegram = {};
    }
    const telegram = next.channels.telegram;
    telegram.enabled = parsed.channels.telegram.enabled;
    telegram.dmPolicy = parsed.channels.telegram.dmPolicy;
    telegram.groupPolicy = parsed.channels.telegram.groupPolicy;
    telegram.allowFrom = parseDelimitedText(parsed.channels.telegram.allowFrom);
    telegram.groupAllowFrom = parseDelimitedText(parsed.channels.telegram.groupAllowFrom);
    telegram.streamMode = parsed.channels.telegram.streamMode;
    telegram.chunkMode = parsed.channels.telegram.chunkMode;
    telegram.replyToMode = parsed.channels.telegram.replyToMode;
    telegram.linkPreview = parsed.channels.telegram.linkPreview;
    telegram.blockStreaming = parsed.channels.telegram.blockStreaming;
    telegram.configWrites = parsed.channels.telegram.configWrites;
    telegram.reactionLevel = parsed.channels.telegram.reactionLevel;
    telegram.reactionNotifications = parsed.channels.telegram.reactionNotifications;

    setOptionalString(telegram, "tokenFile", parsed.channels.telegram.tokenFile);
    setOptionalString(telegram, "webhookUrl", parsed.channels.telegram.webhookUrl);
    setOptionalString(telegram, "webhookPath", parsed.channels.telegram.webhookPath);
    setOptionalString(telegram, "proxy", parsed.channels.telegram.proxy);
    setOptionalNumber(telegram, "textChunkLimit", parsed.channels.telegram.textChunkLimit);
    setOptionalNumber(telegram, "timeoutSeconds", parsed.channels.telegram.timeoutSeconds);
    setOptionalNumber(telegram, "mediaMaxMb", parsed.channels.telegram.mediaMaxMb);
    setOptionalNumber(telegram, "dmHistoryLimit", parsed.channels.telegram.dmHistoryLimit, { allowZero: true });
    setOptionalNumber(telegram, "historyLimit", parsed.channels.telegram.historyLimit, { allowZero: true });

    const groupsOverride = parseOptionalJson(parsed.channels.telegram.groupsJson, "groupsJson", "object");
    if (groupsOverride !== null) {
      telegram.groups = groupsOverride;
    }
    const accountsOverride = parseOptionalJson(parsed.channels.telegram.accountsJson, "accountsJson", "object");
    if (accountsOverride !== null) {
      telegram.accounts = accountsOverride;
    } else {
      delete telegram.accounts;
    }
    const customCommandsOverride = parseOptionalJson(
      parsed.channels.telegram.customCommandsJson,
      "customCommandsJson",
      "array"
    );
    if (customCommandsOverride !== null) {
      telegram.customCommands = customCommandsOverride;
    } else {
      delete telegram.customCommands;
    }
    const draftChunkOverride = parseOptionalJson(parsed.channels.telegram.draftChunkJson, "draftChunkJson", "object");
    if (draftChunkOverride !== null) {
      telegram.draftChunk = draftChunkOverride;
    } else {
      delete telegram.draftChunk;
    }

    if (telegram.dmPolicy === "open") {
      const allowFrom = telegram.allowFrom || [];
      if (!allowFrom.includes("*")) {
        throw new Error('telegram 开放模式要求 allowFrom 至少包含 "*"');
      }
    }

    if (!telegram.groups || typeof telegram.groups !== "object" || Array.isArray(telegram.groups)) {
      telegram.groups = {};
    }
    if (!telegram.groups["*"] || typeof telegram.groups["*"] !== "object") {
      telegram.groups["*"] = {};
    }
    telegram.groups["*"].requireMention = parsed.channels.telegram.requireMention;

    if (!telegram.capabilities || typeof telegram.capabilities !== "object" || Array.isArray(telegram.capabilities)) {
      telegram.capabilities = {};
    }
    telegram.capabilities.inlineButtons = parsed.channels.telegram.inlineButtons;

    if (!telegram.actions || typeof telegram.actions !== "object") {
      telegram.actions = {};
    }
    telegram.actions.sendMessage = parsed.channels.telegram.actionSendMessage;
    telegram.actions.reactions = parsed.channels.telegram.actionReactions;
    telegram.actions.deleteMessage = parsed.channels.telegram.actionDeleteMessage;
    telegram.actions.sticker = parsed.channels.telegram.actionSticker;

    if (!telegram.commands || typeof telegram.commands !== "object") {
      telegram.commands = {};
    }
    if (parsed.channels.telegram.commandsNative === "default") {
      delete telegram.commands.native;
    } else if (parsed.channels.telegram.commandsNative === "auto") {
      telegram.commands.native = "auto";
    } else {
      telegram.commands.native = parsed.channels.telegram.commandsNative === "true";
    }
    if (Object.keys(telegram.commands).length === 0) {
      delete telegram.commands;
    }

    if (!telegram.network || typeof telegram.network !== "object") {
      telegram.network = {};
    }
    if (parsed.channels.telegram.networkAutoSelectFamily === null) {
      delete telegram.network.autoSelectFamily;
    } else {
      telegram.network.autoSelectFamily = parsed.channels.telegram.networkAutoSelectFamily;
    }
    if (Object.keys(telegram.network).length === 0) {
      delete telegram.network;
    }

    if (!telegram.retry || typeof telegram.retry !== "object") {
      telegram.retry = {};
    }
    setOptionalNumber(telegram.retry, "attempts", parsed.channels.telegram.retryAttempts);
    setOptionalNumber(telegram.retry, "minDelayMs", parsed.channels.telegram.retryMinDelayMs);
    setOptionalNumber(telegram.retry, "maxDelayMs", parsed.channels.telegram.retryMaxDelayMs);
    if (
      typeof parsed.channels.telegram.retryJitter === "number" &&
      Number.isFinite(parsed.channels.telegram.retryJitter) &&
      parsed.channels.telegram.retryJitter >= 0 &&
      parsed.channels.telegram.retryJitter <= 1
    ) {
      telegram.retry.jitter = parsed.channels.telegram.retryJitter;
    } else {
      delete telegram.retry.jitter;
    }

    const existingWebhookSecret = telegram.webhookSecret || "";
    const webhookSecret = resolveSecret(parsed.channels.telegram.webhookSecret, existingWebhookSecret);
    if (webhookSecret) {
      telegram.webhookSecret = webhookSecret;
    } else {
      delete telegram.webhookSecret;
    }

    const existingTelegramToken = telegram.botToken || telegram.token || "";
    const telegramToken = resolveSecret(parsed.channels.telegram.botToken, existingTelegramToken);
    if (telegramToken) {
      telegram.botToken = telegramToken;
      telegram.token = telegramToken;
    } else {
      delete telegram.botToken;
      delete telegram.token;
    }

    if (!next.channels.feishu || typeof next.channels.feishu !== "object") {
      next.channels.feishu = {};
    }
    const feishu = next.channels.feishu;
    feishu.enabled = parsed.channels.feishu.enabled;
    feishu.appId = parsed.channels.feishu.appId;
    feishu.appSecret = resolveSecret(parsed.channels.feishu.appSecret, feishu.appSecret);
    feishu.domain = parsed.channels.feishu.domain;
    feishu.connectionMode = parsed.channels.feishu.connectionMode;
    feishu.dmPolicy = parsed.channels.feishu.dmPolicy;
    feishu.groupPolicy = parsed.channels.feishu.groupPolicy;
    feishu.allowFrom = parseDelimitedText(parsed.channels.feishu.allowFrom);
    feishu.groupAllowFrom = parseDelimitedText(parsed.channels.feishu.groupAllowFrom);
    feishu.requireMention = parsed.channels.feishu.requireMention;

    if (feishu.dmPolicy === "open") {
      const allowFrom = feishu.allowFrom || [];
      if (!allowFrom.includes("*")) {
        throw new Error('feishu 开放模式要求 allowFrom 至少包含 "*"');
      }
    }

    if (feishu.accounts && typeof feishu.accounts === "object") {
      const accountId = feishu.accounts.main ? "main" : Object.keys(feishu.accounts)[0] || "main";
      if (!feishu.accounts[accountId] || typeof feishu.accounts[accountId] !== "object") {
        feishu.accounts[accountId] = {};
      }
      const account = feishu.accounts[accountId];
      account.enabled = parsed.channels.feishu.enabled;
      account.appId = parsed.channels.feishu.appId;
      account.appSecret = resolveSecret(parsed.channels.feishu.appSecret, account.appSecret);
      account.domain = parsed.channels.feishu.domain;
      account.connectionMode = parsed.channels.feishu.connectionMode;
      account.dmPolicy = parsed.channels.feishu.dmPolicy;
      account.groupPolicy = parsed.channels.feishu.groupPolicy;
      account.allowFrom = parseDelimitedText(parsed.channels.feishu.allowFrom);
      account.groupAllowFrom = parseDelimitedText(parsed.channels.feishu.groupAllowFrom);
      account.requireMention = parsed.channels.feishu.requireMention;
    }

    if (next.channels["feishu-china"] && typeof next.channels["feishu-china"] === "object") {
      next.channels["feishu-china"].enabled = parsed.channels.feishu.enabled;
      next.channels["feishu-china"].appId = parsed.channels.feishu.appId;
      next.channels["feishu-china"].appSecret = resolveSecret(
        parsed.channels.feishu.appSecret,
        next.channels["feishu-china"].appSecret
      );
    }

    if (!next.channels.discord || typeof next.channels.discord !== "object") {
      next.channels.discord = {};
    }
    const discord = next.channels.discord;
    const discordAllowFrom = parseDelimitedText(parsed.channels.discord.allowFrom);
    discord.enabled = parsed.channels.discord.enabled;
    discord.dmPolicy = parsed.channels.discord.dmPolicy;
    discord.allowFrom = discordAllowFrom;
    discord.groupPolicy = parsed.channels.discord.groupPolicy;
    discord.allowBots = parsed.channels.discord.allowBots;

    if (!discord.dm || typeof discord.dm !== "object") {
      discord.dm = {};
    }
    discord.dm.policy = parsed.channels.discord.dmPolicy;
    discord.dm.allowFrom = discordAllowFrom;

    if (discord.dmPolicy === "open" && !discordAllowFrom.includes("*")) {
      throw new Error('discord 开放模式要求 allowFrom 至少包含 "*"');
    }

    if (!discord.guilds || typeof discord.guilds !== "object") {
      discord.guilds = {};
    }
    if (!discord.guilds["*"] || typeof discord.guilds["*"] !== "object") {
      discord.guilds["*"] = {};
    }
    discord.guilds["*"].requireMention = parsed.channels.discord.requireMention;

    discord.token = resolveSecret(parsed.channels.discord.token, discord.token);

    if (discord.accounts && typeof discord.accounts === "object") {
      const accountId = discord.accounts.main ? "main" : Object.keys(discord.accounts)[0] || "main";
      if (!discord.accounts[accountId] || typeof discord.accounts[accountId] !== "object") {
        discord.accounts[accountId] = {};
      }
      const account = discord.accounts[accountId];
      account.enabled = parsed.channels.discord.enabled;
      account.dmPolicy = parsed.channels.discord.dmPolicy;
      account.allowFrom = discordAllowFrom;
      account.groupPolicy = parsed.channels.discord.groupPolicy;
      account.allowBots = parsed.channels.discord.allowBots;
      if (!account.dm || typeof account.dm !== "object") {
        account.dm = {};
      }
      account.dm.policy = parsed.channels.discord.dmPolicy;
      account.dm.allowFrom = discordAllowFrom;
      if (!account.guilds || typeof account.guilds !== "object") {
        account.guilds = {};
      }
      if (!account.guilds["*"] || typeof account.guilds["*"] !== "object") {
        account.guilds["*"] = {};
      }
      account.guilds["*"].requireMention = parsed.channels.discord.requireMention;
      account.token = resolveSecret(parsed.channels.discord.token, account.token);
    }

    if (!next.channels.slack || typeof next.channels.slack !== "object") {
      next.channels.slack = {};
    }
    const slack = next.channels.slack;
    const slackAllowFrom = parseDelimitedText(parsed.channels.slack.allowFrom);
    slack.enabled = parsed.channels.slack.enabled;
    slack.mode = parsed.channels.slack.mode;
    slack.dmPolicy = parsed.channels.slack.dmPolicy;
    slack.allowFrom = slackAllowFrom;
    slack.groupPolicy = parsed.channels.slack.groupPolicy;
    slack.allowBots = parsed.channels.slack.allowBots;
    slack.requireMention = parsed.channels.slack.requireMention;

    if (!slack.dm || typeof slack.dm !== "object") {
      slack.dm = {};
    }
    slack.dm.policy = parsed.channels.slack.dmPolicy;
    slack.dm.allowFrom = slackAllowFrom;

    if (slack.dmPolicy === "open" && !slackAllowFrom.includes("*")) {
      throw new Error('slack 开放模式要求 allowFrom 至少包含 "*"');
    }

    slack.botToken = resolveSecret(parsed.channels.slack.botToken, slack.botToken);
    slack.appToken = resolveSecret(parsed.channels.slack.appToken, slack.appToken);
    slack.signingSecret = resolveSecret(parsed.channels.slack.signingSecret, slack.signingSecret);

    if (slack.mode === "http" && !slack.signingSecret) {
      throw new Error('slack HTTP 模式要求 signingSecret 不能为空');
    }

    if (slack.accounts && typeof slack.accounts === "object") {
      const accountId = slack.accounts.main ? "main" : Object.keys(slack.accounts)[0] || "main";
      if (!slack.accounts[accountId] || typeof slack.accounts[accountId] !== "object") {
        slack.accounts[accountId] = {};
      }
      const account = slack.accounts[accountId];
      account.enabled = parsed.channels.slack.enabled;
      account.mode = parsed.channels.slack.mode;
      account.dmPolicy = parsed.channels.slack.dmPolicy;
      account.allowFrom = slackAllowFrom;
      account.groupPolicy = parsed.channels.slack.groupPolicy;
      account.allowBots = parsed.channels.slack.allowBots;
      account.requireMention = parsed.channels.slack.requireMention;
      if (!account.dm || typeof account.dm !== "object") {
        account.dm = {};
      }
      account.dm.policy = parsed.channels.slack.dmPolicy;
      account.dm.allowFrom = slackAllowFrom;
      account.botToken = resolveSecret(parsed.channels.slack.botToken, account.botToken);
      account.appToken = resolveSecret(parsed.channels.slack.appToken, account.appToken);
      account.signingSecret = resolveSecret(parsed.channels.slack.signingSecret, account.signingSecret);
      if (account.mode === "http" && !(account.signingSecret || slack.signingSecret)) {
        throw new Error(`slack 账号 ${accountId} 的 HTTP 模式需要 signingSecret`);
      }
    }
  }

  return next;
}

export { applySettings };
</file>

<file path="src/openclaw-config/helpers.js">
import { isLikelyMasked } from "../utils.js";

function pickChannel(config, key, fallback = {}) {
  return config?.channels?.[key] || fallback;
}

function toDelimitedList(input) {
  if (!Array.isArray(input)) {
    return "";
  }
  return input.map((v) => String(v).trim()).filter(Boolean).join("\n");
}

function parseDelimitedText(input) {
  const raw = String(input || "")
    .split(/[\n,]/)
    .map((v) => v.trim())
    .filter(Boolean);
  return [...new Set(raw)];
}

function toOptionalPositiveInt(value) {
  const parsed = Number(value);
  if (!Number.isFinite(parsed) || parsed <= 0) {
    return null;
  }
  return Math.floor(parsed);
}

function toOptionalNonNegativeInt(value) {
  const parsed = Number(value);
  if (!Number.isFinite(parsed) || parsed < 0) {
    return null;
  }
  return Math.floor(parsed);
}

function normalizeInlineButtons(rawCapabilities) {
  if (Array.isArray(rawCapabilities)) {
    return rawCapabilities.map((item) => String(item || "").trim()).includes("inlineButtons") ? "all" : "allowlist";
  }
  const value = String(rawCapabilities?.inlineButtons || "").trim();
  if (["off", "dm", "group", "all", "allowlist"].includes(value)) {
    return value;
  }
  return "allowlist";
}

function toPrettyJson(value) {
  if (!value || typeof value !== "object") {
    return "";
  }
  try {
    if (Array.isArray(value)) {
      return value.length > 0 ? JSON.stringify(value, null, 2) : "";
    }
    return Object.keys(value).length > 0 ? JSON.stringify(value, null, 2) : "";
  } catch {
    return "";
  }
}

function parseOptionalJson(value, fieldName, expectedType) {
  const displayNameMap = {
    groupsJson: "Telegram 群组覆盖（groupsJson）",
    accountsJson: "Telegram 账号映射（accountsJson）",
    customCommandsJson: "Telegram 自定义命令（customCommandsJson）",
    draftChunkJson: "Telegram 草稿分块（draftChunkJson）"
  };
  const displayName = displayNameMap[fieldName] || fieldName;
  const text = String(value || "").trim();
  if (!text) {
    return null;
  }
  let parsed;
  try {
    parsed = JSON.parse(text);
  } catch {
    throw new Error(`${displayName} 不是有效 JSON`);
  }
  if (expectedType === "array") {
    if (!Array.isArray(parsed)) {
      throw new Error(`${displayName} 必须是数组 JSON`);
    }
    return parsed;
  }
  if (!parsed || typeof parsed !== "object" || Array.isArray(parsed)) {
    throw new Error(`${displayName} 必须是对象 JSON`);
  }
  return parsed;
}

function firstNonEmptyString(values) {
  for (const value of values) {
    const text = String(value ?? "").trim();
    if (text) {
      return text;
    }
  }
  return "";
}

function pickDefaultAccount(channelConfig) {
  const accounts = channelConfig?.accounts;
  if (!accounts || typeof accounts !== "object") {
    return {
      accountId: "main",
      account: {}
    };
  }
  if (accounts.main && typeof accounts.main === "object") {
    return {
      accountId: "main",
      account: accounts.main
    };
  }
  const first = Object.entries(accounts).find(([, value]) => value && typeof value === "object");
  if (!first) {
    return {
      accountId: "main",
      account: {}
    };
  }
  return {
    accountId: first[0],
    account: first[1]
  };
}

function resolveSecret(nextValue, currentValue) {
  if (!nextValue || isLikelyMasked(nextValue)) {
    return currentValue || "";
  }
  return nextValue;
}

function toPositiveIntOrFallback(value, fallback) {
  const parsed = Number(value);
  if (!Number.isFinite(parsed) || parsed <= 0) {
    return fallback;
  }
  return Math.floor(parsed);
}

function normalizeInputList(input, fallback) {
  const raw = Array.isArray(input) ? input : Array.isArray(fallback) ? fallback : [];
  return [...new Set(raw.map((item) => String(item).trim()).filter(Boolean))];
}

function normalizeModelDraft(nextDraft, fallbackModel = {}) {
  const fallbackId = String(fallbackModel?.id || "").trim();
  const modelId = String(nextDraft?.id || fallbackId).trim();
  const modelName = String(nextDraft?.name || fallbackModel?.name || modelId).trim() || modelId;
  const normalized = {
    ...fallbackModel,
    ...nextDraft,
    id: modelId,
    name: modelName,
    contextWindow: toPositiveIntOrFallback(
      nextDraft?.contextWindow,
      toPositiveIntOrFallback(fallbackModel?.contextWindow, 200000)
    ),
    maxTokens: toPositiveIntOrFallback(nextDraft?.maxTokens, toPositiveIntOrFallback(fallbackModel?.maxTokens, 8192))
  };

  const normalizedInput = normalizeInputList(nextDraft?.input, fallbackModel?.input);
  if (normalizedInput.length > 0) {
    normalized.input = normalizedInput;
  } else {
    delete normalized.input;
  }

  if (nextDraft?.reasoning === undefined && fallbackModel?.reasoning !== undefined) {
    normalized.reasoning = Boolean(fallbackModel.reasoning);
  } else if (nextDraft?.reasoning !== undefined) {
    normalized.reasoning = Boolean(nextDraft.reasoning);
  }

  if (nextDraft?.cost === undefined && fallbackModel?.cost !== undefined) {
    normalized.cost = fallbackModel.cost;
  }

  return normalized;
}

function setOptionalString(target, key, value) {
  const text = String(value || "").trim();
  if (text) {
    target[key] = text;
    return;
  }
  delete target[key];
}

function setOptionalNumber(target, key, value, { allowZero = false } = {}) {
  const parsed = Number(value);
  const valid = Number.isFinite(parsed) && (allowZero ? parsed >= 0 : parsed > 0);
  if (!valid) {
    delete target[key];
    return;
  }
  target[key] = Math.floor(parsed);
}

export {
  pickChannel,
  toDelimitedList,
  parseDelimitedText,
  toOptionalPositiveInt,
  toOptionalNonNegativeInt,
  normalizeInlineButtons,
  toPrettyJson,
  parseOptionalJson,
  firstNonEmptyString,
  pickDefaultAccount,
  resolveSecret,
  toPositiveIntOrFallback,
  normalizeInputList,
  normalizeModelDraft,
  setOptionalString,
  setOptionalNumber
};
</file>

<file path="src/openclaw-config/schema.js">
import { z } from "zod";

const modelDraftSchema = z.object({
  id: z.string().min(1, "model.id 不能为空"),
  name: z.string().optional().default(""),
  api: z.string().optional(),
  reasoning: z.boolean().optional(),
  input: z.array(z.string()).optional(),
  cost: z.record(z.number()).optional(),
  contextWindow: z.number().int().positive().optional(),
  maxTokens: z.number().int().positive().optional()
});

const settingsSchema = z.object({
  model: z.object({
    primary: z.string().min(1, "model.primary 不能为空"),
    providerId: z.string().min(1, "model.providerId 不能为空"),
    providerApi: z.string().min(1, "model.providerApi 不能为空"),
    providerBaseUrl: z.string().min(1, "model.providerBaseUrl 不能为空"),
    providerApiKey: z.string().optional().default(""),
    modelId: z.string().min(1, "model.modelId 不能为空"),
    modelName: z.string().min(1, "model.modelName 不能为空"),
    contextWindow: z.number().int().positive().default(200000),
    maxTokens: z.number().int().positive().default(8192),
    providerModels: z.array(modelDraftSchema).optional().default([])
  }),
  channels: z
    .object({
      telegram: z.object({
        enabled: z.boolean().default(false),
        botToken: z.string().optional().default(""),
        tokenFile: z.string().optional().default(""),
        dmPolicy: z.enum(["open", "pairing", "allowlist", "disabled"]).default("pairing"),
        allowFrom: z.string().optional().default(""),
        groupPolicy: z.enum(["open", "allowlist", "disabled"]).default("allowlist"),
        groupAllowFrom: z.string().optional().default(""),
        requireMention: z.boolean().default(true),
        streamMode: z.enum(["off", "partial", "block"]).default("partial"),
        chunkMode: z.enum(["length", "newline"]).default("length"),
        textChunkLimit: z.number().int().positive().nullable().optional().default(null),
        replyToMode: z.enum(["off", "first", "all"]).default("off"),
        linkPreview: z.boolean().default(true),
        blockStreaming: z.boolean().default(false),
        timeoutSeconds: z.number().int().positive().nullable().optional().default(null),
        mediaMaxMb: z.number().int().positive().nullable().optional().default(null),
        dmHistoryLimit: z.number().int().nonnegative().nullable().optional().default(null),
        historyLimit: z.number().int().nonnegative().nullable().optional().default(null),
        webhookUrl: z.string().optional().default(""),
        webhookSecret: z.string().optional().default(""),
        webhookPath: z.string().optional().default("/telegram-webhook"),
        proxy: z.string().optional().default(""),
        configWrites: z.boolean().default(true),
        reactionLevel: z.enum(["off", "ack", "minimal", "extensive"]).default("minimal"),
        reactionNotifications: z.enum(["off", "own", "all"]).default("own"),
        inlineButtons: z.enum(["off", "dm", "group", "all", "allowlist"]).default("allowlist"),
        actionSendMessage: z.boolean().default(true),
        actionReactions: z.boolean().default(true),
        actionDeleteMessage: z.boolean().default(true),
        actionSticker: z.boolean().default(false),
        networkAutoSelectFamily: z.boolean().nullable().optional().default(null),
        retryAttempts: z.number().int().positive().nullable().optional().default(null),
        retryMinDelayMs: z.number().int().positive().nullable().optional().default(null),
        retryMaxDelayMs: z.number().int().positive().nullable().optional().default(null),
        retryJitter: z.number().min(0).max(1).nullable().optional().default(null),
        commandsNative: z.enum(["default", "auto", "true", "false"]).default("default"),
        groupsJson: z.string().optional().default(""),
        accountsJson: z.string().optional().default(""),
        customCommandsJson: z.string().optional().default(""),
        draftChunkJson: z.string().optional().default("")
      }),
      feishu: z.object({
        enabled: z.boolean().default(false),
        appId: z.string().optional().default(""),
        appSecret: z.string().optional().default(""),
        domain: z.string().optional().default("feishu"),
        connectionMode: z.enum(["websocket", "webhook"]).default("websocket"),
        dmPolicy: z.enum(["open", "pairing", "allowlist"]).default("pairing"),
        allowFrom: z.string().optional().default(""),
        groupPolicy: z.enum(["open", "allowlist", "disabled"]).default("allowlist"),
        groupAllowFrom: z.string().optional().default(""),
        requireMention: z.boolean().default(true)
      }),
      discord: z.object({
        enabled: z.boolean().default(false),
        token: z.string().optional().default(""),
        dmPolicy: z.enum(["open", "pairing", "allowlist", "disabled"]).default("pairing"),
        allowFrom: z.string().optional().default(""),
        groupPolicy: z.enum(["open", "allowlist", "disabled"]).default("allowlist"),
        allowBots: z.boolean().default(false),
        requireMention: z.boolean().default(true)
      }),
      slack: z.object({
        enabled: z.boolean().default(false),
        mode: z.enum(["socket", "http"]).default("socket"),
        botToken: z.string().optional().default(""),
        appToken: z.string().optional().default(""),
        signingSecret: z.string().optional().default(""),
        dmPolicy: z.enum(["open", "pairing", "allowlist", "disabled"]).default("pairing"),
        allowFrom: z.string().optional().default(""),
        groupPolicy: z.enum(["open", "allowlist", "disabled"]).default("allowlist"),
        allowBots: z.boolean().default(false),
        requireMention: z.boolean().default(true)
      })
    })
    .optional()
});

export { modelDraftSchema, settingsSchema };
export const openClawSettingsSchema = settingsSchema;
</file>

<file path="src/systemd.js">
import { execFile } from "node:child_process";

const DOCKER_STATUS_PROBE_DELAY_MS = 1100;
const DOCKER_ACTION_VERIFY_DELAY_MS = 1800;
const DOCKER_STOP_VERIFY_DELAY_MS = 500;

function run(command, args) {
  return new Promise((resolve) => {
    execFile(command, args, { timeout: 15000 }, (error, stdout, stderr) => {
      resolve({
        ok: !error,
        code: error?.code ?? 0,
        stdout: (stdout || "").trim(),
        stderr: (stderr || "").trim(),
        message: error?.message || ""
      });
    });
  });
}

function sleep(ms) {
  return new Promise((resolve) => {
    setTimeout(resolve, ms);
  });
}

async function runSystemdAction(action, serviceName) {
  if (process.platform !== "linux") {
    return {
      ok: false,
      action,
      runtimeMode: "systemd",
      serviceName,
      output: "仅 Linux + systemd 环境支持服务控制。"
    };
  }

  if (action === "status") {
    const active = await run("systemctl", ["is-active", serviceName]);
    const details = await run("systemctl", ["status", serviceName, "--no-pager", "-n", "30"]);
    return {
      ok: active.ok,
      action,
      runtimeMode: "systemd",
      serviceName,
      active: active.stdout === "active",
      output: [active.stdout, details.stdout, details.stderr].filter(Boolean).join("\n")
    };
  }

  const result = await run("systemctl", [action, serviceName]);
  return {
    ok: result.ok,
    action,
    runtimeMode: "systemd",
    serviceName,
    output: [result.stdout, result.stderr, result.message].filter(Boolean).join("\n")
  };
}

function composeContainerName(panelConfig) {
  return panelConfig?.openclaw?.container_name || panelConfig?.openclaw?.service_name || "openclaw-gateway";
}

function parseDockerInspectResult(stdout) {
  try {
    const parsed = JSON.parse(stdout || "[]");
    if (!Array.isArray(parsed) || parsed.length === 0) {
      return null;
    }
    return parsed[0];
  } catch {
    return null;
  }
}

async function inspectDockerState(containerName) {
  const inspect = await run("docker", ["inspect", containerName]);
  if (!inspect.ok) {
    return {
      ok: false,
      message: [inspect.stdout, inspect.stderr, inspect.message].filter(Boolean).join("\n").trim() || "容器不存在或不可访问。"
    };
  }

  const firstEntry = parseDockerInspectResult(inspect.stdout);
  if (!firstEntry) {
    return {
      ok: false,
      message: "docker inspect 返回内容无法解析。"
    };
  }

  const state = firstEntry?.State && typeof firstEntry.State === "object" ? firstEntry.State : {};
  const status = String(state.Status || "unknown").trim() || "unknown";
  const restartCount = Number(firstEntry?.RestartCount ?? 0);
  const numericRestartCount = Number.isFinite(restartCount) ? restartCount : 0;
  const exitCode = Number(state?.ExitCode);

  return {
    ok: true,
    status,
    active: status === "running",
    restarting: Boolean(state?.Restarting),
    running: Boolean(state?.Running),
    restartCount: numericRestartCount,
    exitCode: Number.isFinite(exitCode) ? exitCode : null,
    error: String(state?.Error || "").trim(),
    startedAt: String(state?.StartedAt || ""),
    finishedAt: String(state?.FinishedAt || "")
  };
}

function buildDockerStateLines(snapshot) {
  const lines = [
    `state: ${snapshot.status}`,
    `running: ${snapshot.running ? "true" : "false"}`,
    `restarting: ${snapshot.restarting ? "true" : "false"}`,
    `restartCount: ${snapshot.restartCount}`
  ];
  if (snapshot.exitCode !== null) {
    lines.push(`exitCode: ${snapshot.exitCode}`);
  }
  if (snapshot.error) {
    lines.push(`error: ${snapshot.error}`);
  }
  if (snapshot.startedAt) {
    lines.push(`startedAt: ${snapshot.startedAt}`);
  }
  if (snapshot.finishedAt) {
    lines.push(`finishedAt: ${snapshot.finishedAt}`);
  }
  return lines;
}

async function runDockerStatus(
  containerName,
  { includeFailureLogs = true, probeRestartLoop = true } = {}
) {
  const detail = await run("docker", ["ps", "-a", "--filter", `name=^/${containerName}$`]);
  const firstSnapshot = await inspectDockerState(containerName);
  if (!firstSnapshot.ok) {
    const outputParts = [firstSnapshot.message];
    if (detail.stdout) {
      outputParts.push(detail.stdout);
    }
    return {
      ok: false,
      action: "status",
      runtimeMode: "docker",
      containerName,
      active: false,
      state: "not-found",
      output: outputParts.filter(Boolean).join("\n").trim() || "容器不存在或不可访问。"
    };
  }

  let snapshot = firstSnapshot;
  let instabilityReason = "";
  if (probeRestartLoop && firstSnapshot.status === "running") {
    await sleep(DOCKER_STATUS_PROBE_DELAY_MS);
    const secondSnapshot = await inspectDockerState(containerName);
    if (secondSnapshot.ok) {
      snapshot = secondSnapshot;
      if (secondSnapshot.status === "restarting") {
        instabilityReason = "容器处于重启中状态。";
      } else if (secondSnapshot.restartCount > firstSnapshot.restartCount) {
        instabilityReason = `检测到容器在短时间内重启次数增长（${firstSnapshot.restartCount} -> ${secondSnapshot.restartCount}）。`;
      }
    }
  }

  const active = snapshot.status === "running" && !instabilityReason;
  const outputParts = [];
  outputParts.push(...buildDockerStateLines(snapshot));
  if (instabilityReason) {
    outputParts.push(`statusHint: ${instabilityReason}`);
  }
  if (detail.stdout) {
    outputParts.push(detail.stdout);
  }

  if (!active && includeFailureLogs) {
    const logs = await run("docker", ["logs", "--tail", "60", containerName]);
    const combinedLogs = [logs.stdout, logs.stderr].filter(Boolean).join("\n").trim();
    if (combinedLogs) {
      outputParts.push("---- recent logs ----");
      outputParts.push(combinedLogs);
    } else if (!logs.ok && logs.message) {
      outputParts.push(`logs error: ${logs.message}`);
    }
  }

  return {
    ok: true,
    action: "status",
    runtimeMode: "docker",
    containerName,
    active,
    state: snapshot.status,
    restartCount: snapshot.restartCount,
    exitCode: snapshot.exitCode,
    instabilityReason,
    output: outputParts.join("\n").trim() || "容器不存在或不可访问。"
  };
}

async function runDockerAction(action, containerName) {
  if (action === "status") {
    return runDockerStatus(containerName);
  }

  const result = await run("docker", [action, containerName]);
  if (!result.ok) {
    return {
      ok: false,
      action,
      runtimeMode: "docker",
      containerName,
      output: [result.stdout, result.stderr, result.message].filter(Boolean).join("\n")
    };
  }

  if (action === "start" || action === "restart" || action === "stop") {
    await sleep(action === "stop" ? DOCKER_STOP_VERIFY_DELAY_MS : DOCKER_ACTION_VERIFY_DELAY_MS);
    const statusResult = await runDockerStatus(containerName, {
      includeFailureLogs: action !== "stop",
      probeRestartLoop: action !== "stop"
    });
    const shouldBeActive = action !== "stop";
    const stateMatchesExpectation = shouldBeActive ? statusResult.active : !statusResult.active;
    if (!stateMatchesExpectation) {
      const actionText = action === "stop" ? "停止" : "启动";
      return {
        ok: false,
        action,
        runtimeMode: "docker",
        containerName,
        active: statusResult.active,
        state: statusResult.state,
        output: [
          [result.stdout, result.stderr, result.message].filter(Boolean).join("\n").trim(),
          `${actionText}后状态校验失败：当前状态 ${statusResult.state || "unknown"}。`,
          statusResult.output
        ]
          .filter(Boolean)
          .join("\n")
      };
    }

    return {
      ok: true,
      action,
      runtimeMode: "docker",
      containerName,
      active: statusResult.active,
      state: statusResult.state,
      output: [
        [result.stdout, result.stderr, result.message].filter(Boolean).join("\n").trim(),
        `状态校验通过：${statusResult.state || "unknown"}。`,
        statusResult.output
      ]
        .filter(Boolean)
        .join("\n")
    };
  }

  return {
    ok: true,
    action,
    runtimeMode: "docker",
    containerName,
    output: [result.stdout, result.stderr, result.message].filter(Boolean).join("\n")
  };
}

export async function runServiceAction(action, panelConfig) {
  const runtimeMode = panelConfig?.runtime?.mode || "systemd";
  if (runtimeMode === "docker") {
    const containerName = composeContainerName(panelConfig);
    return runDockerAction(action, containerName);
  }
  return runSystemdAction(action, panelConfig?.openclaw?.service_name || "openclaw-gateway");
}
</file>

<file path="deploy/docker-rollback.sh">
#!/usr/bin/env bash
set -euo pipefail

ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
cd "$ROOT_DIR"
export COMPOSE_PROJECT_NAME="openclawpanel"

pull_with_retry() {
  local image="$1"
  local max_attempts="${2:-5}"
  local sleep_base="${RETRY_SLEEP_SECONDS:-3}"
  local attempt

  for ((attempt=1; attempt<=max_attempts; attempt++)); do
    echo "拉取镜像 ${image}（第 ${attempt}/${max_attempts} 次）..."
    if docker pull "$image"; then
      return 0
    fi
    if (( attempt < max_attempts )); then
      sleep $((attempt * sleep_base))
    fi
  done

  return 1
}

set_env_image() {
  local image="$1"
  if grep -q '^OPENCLAW_IMAGE=' ./.env; then
    sed -i "s|^OPENCLAW_IMAGE=.*$|OPENCLAW_IMAGE=${image}|g" ./.env
  else
    echo "OPENCLAW_IMAGE=${image}" >> ./.env
  fi
}

extract_image_repo() {
  local image_ref="$1"
  local without_digest="${image_ref%@*}"
  local last_segment="${without_digest##*/}"

  # Only remove tag if ':' appears in the last path segment.
  if [[ "$last_segment" == *:* ]]; then
    printf '%s\n' "${without_digest%:*}"
    return
  fi

  printf '%s\n' "$without_digest"
}

if [[ $# -lt 1 ]]; then
  echo "用法: bash deploy/docker-rollback.sh <tag>"
  echo "示例: bash deploy/docker-rollback.sh v2026.2.14"
  exit 1
fi

if [[ ! -f ./.env ]]; then
  echo ".env 不存在，请先执行 bash deploy/docker-init.sh"
  exit 1
fi

tag="$1"
tag="${tag#v}"
old_image="$(grep -E '^OPENCLAW_IMAGE=' ./.env | head -n1 | cut -d'=' -f2- || true)"
if [[ -z "$old_image" ]]; then
  old_image="ghcr.io/openclaw/openclaw:2026.2.14"
fi
image_repo="$(extract_image_repo "$old_image")"
if [[ -z "$image_repo" ]]; then
  image_repo="ghcr.io/openclaw/openclaw"
fi
image="${image_repo}:${tag}"
backup_env="./.env.bak.$(date +%Y%m%d%H%M%S)"
cp ./.env "$backup_env"

echo "准备回滚:"
echo "  old: ${old_image}"
echo "  new: ${image}"
if ! pull_with_retry "$image" 5; then
  echo "回滚镜像拉取失败，请稍后重试。"
  exit 1
fi

set_env_image "$image"
if ! docker compose up -d openclaw-gateway; then
  echo "回滚启动失败，恢复旧镜像。"
  set_env_image "$old_image"
  pull_with_retry "$old_image" 3 || true
  docker compose up -d openclaw-gateway || true
  exit 1
fi

sleep 4
running="$(docker inspect --format '{{.State.Running}}' openclaw-gateway 2>/dev/null || true)"
if [[ "$running" != "true" ]]; then
  echo "回滚后容器未运行，恢复旧镜像。"
  set_env_image "$old_image"
  pull_with_retry "$old_image" 3 || true
  docker compose up -d openclaw-gateway || true
  exit 1
fi

docker inspect --format '{{.Name}} {{.State.Status}}' openclaw-gateway
echo "回滚成功: ${image}"
echo "环境备份: ${backup_env}"
</file>

<file path="public/config-generator.js">
const AICODECAT_PROVIDER = "aicodecat";

const AICODECAT_BASE_URL_BY_MODE = Object.freeze({
  gpt: "https://aicode.cat/v1",
  claude: "https://aicode.cat",
  gemini: "https://aicode.cat/v1beta"
});

const API_MODE_TO_FAMILY = Object.freeze({
  "openai-responses": "gpt",
  "openai-completions": "gpt",
  "anthropic-messages": "claude",
  "google-generative-ai": "gemini"
});

const MODEL_DEFAULTS_BY_FAMILY = Object.freeze({
  gpt: {
    contextWindow: 400000,
    maxTokens: 128000,
    reasoning: true
  },
  claude: {
    contextWindow: 200000,
    maxTokens: 64000,
    reasoning: true
  },
  gemini: {
    contextWindow: 1048576,
    maxTokens: 65536,
    reasoning: false
  }
});

function toTrimmedString(value) {
  return String(value ?? "").trim();
}

function toBoolean(value) {
  if (typeof value === "boolean") {
    return value;
  }
  return toTrimmedString(value).toLowerCase() === "true";
}

function toPositiveInt(value, fallback) {
  const parsed = Number(value);
  if (!Number.isFinite(parsed) || parsed <= 0) {
    return fallback;
  }
  return Math.floor(parsed);
}

function isRecord(value) {
  return Boolean(value) && typeof value === "object" && !Array.isArray(value);
}

export function apiModeFamily(apiMode) {
  return API_MODE_TO_FAMILY[toTrimmedString(apiMode)] || "gpt";
}

export function resolveAicodecatBaseUrl(apiMode) {
  return AICODECAT_BASE_URL_BY_MODE[apiModeFamily(apiMode)];
}

export function resolveProviderId(provider, apiMode) {
  const providerValue = toTrimmedString(provider);
  if (providerValue !== AICODECAT_PROVIDER) {
    return providerValue;
  }

  const family = apiModeFamily(apiMode);
  if (family === "claude") {
    return "aicodecat-claude";
  }
  if (family === "gemini") {
    return "aicodecat-gemini";
  }
  return "aicodecat-gpt";
}

export function convertConfig(payload) {
  let userConfig;
  try {
    userConfig = JSON.parse(toTrimmedString(payload.config));
  } catch (error) {
    throw new Error(`配置 JSON 格式错误: ${error.message}`);
  }

  const provider = toTrimmedString(payload.provider);
  const providerId = resolveProviderId(provider, payload.apimode);
  const modelId = toTrimmedString(payload.model_id);
  const modelFamily = apiModeFamily(payload.apimode);
  const modelDefaults = MODEL_DEFAULTS_BY_FAMILY[modelFamily] || MODEL_DEFAULTS_BY_FAMILY.gpt;
  const modelRef = `${providerId}/${modelId}`;
  const modelContextWindow = toPositiveInt(payload.context_window, modelDefaults.contextWindow);
  const modelMaxTokens = toPositiveInt(payload.max_tokens, modelDefaults.maxTokens);
  const modelReasoning = payload.reasoning === undefined ? modelDefaults.reasoning : toBoolean(payload.reasoning);
  const inheritExisting = toBoolean(payload.inherit_existing);
  const sourceConfig = isRecord(userConfig) ? userConfig : {};
  const existingAgents = isRecord(sourceConfig.agents) ? sourceConfig.agents : {};
  const existingDefaults = isRecord(existingAgents.defaults) ? existingAgents.defaults : {};
  const existingDefaultModel = isRecord(existingDefaults.model) ? existingDefaults.model : {};
  const existingDefaultModels = isRecord(existingDefaults.models) ? existingDefaults.models : {};
  const existingGateway = isRecord(sourceConfig.gateway) ? sourceConfig.gateway : {};
  const defaultModels = inheritExisting ? { ...existingDefaultModels } : {};
  if (!isRecord(defaultModels[modelRef])) {
    defaultModels[modelRef] = {};
  }

  const agents = inheritExisting
    ? {
        ...existingAgents,
        defaults: {
          ...existingDefaults,
          model: {
            ...existingDefaultModel,
            primary: modelRef
          },
          models: defaultModels
        }
      }
    : {
        defaults: {
          model: {
            primary: modelRef
          },
          models: defaultModels
        }
      };

  const result = {
    ...(inheritExisting ? sourceConfig : {}),
    gateway: {
      ...(inheritExisting ? existingGateway : {}),
      mode: toTrimmedString(existingGateway.mode) || "local"
    },
    models: {
      mode: "merge",
      providers: {
        [providerId]: {
          baseUrl: toTrimmedString(payload.baseurl),
          apiKey: toTrimmedString(payload.apikey),
          api: toTrimmedString(payload.apimode),
          models: [
            {
              id: modelId,
              name: modelId,
              reasoning: modelReasoning,
              contextWindow: modelContextWindow,
              maxTokens: modelMaxTokens
            }
          ]
        }
      }
    },
    agents
  };

  delete result.auth;
  return result;
}

export { AICODECAT_PROVIDER };
</file>

<file path="public/pages/channels-discord.html">
<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>OpenClaw 龙虾控制台</title>
    <script>
      (function initThemeEarly() {
        var theme = "light";
        try {
          var saved = window.localStorage.getItem("openclaw-panel-theme");
          theme = saved === "dark" ? "dark" : "light";
        } catch (_error) {
          theme = "light";
        }
        var root = document.documentElement;
        root.dataset.theme = theme;
        root.classList.toggle("sl-theme-dark", theme === "dark");
        root.classList.toggle("sl-theme-light", theme !== "dark");
      })();
    </script>
    <link rel="stylesheet" href="/shoelace/themes/light.css" />
    <link rel="stylesheet" href="/shoelace/themes/dark.css" />
    <link rel="stylesheet" href="/styles.css" />
    <script type="module" src="/shoelace/shoelace-autoloader.js"></script>
    <style>
      .channel-page-status {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin: 10px 0 4px;
      }

      .channel-page-summary {
        margin: 0;
        color: var(--muted);
        font-size: 12px;
      }

      .channel-page-header-left {
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .channel-back-link {
        width: 34px;
        height: 34px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        border: 1px solid var(--border);
        border-radius: 9px;
        background: var(--soft-button);
        color: var(--text);
        text-decoration: none;
        font-size: 18px;
        line-height: 1;
      }

      .channel-back-link:hover {
        background: var(--soft-button-hover);
      }
    </style>
  </head>
  <body data-theme="light">
    <div class="layout">
      <aside class="sidebar">
        <div class="brand">
          <p class="eyebrow">OpenClaw</p>
          <h1>龙虾控制台</h1>
          <p class="sub">管理你的 AI 助手：模型、渠道、技能，一站搞定。</p>
        </div>

        <nav class="tabs sidebar-tabs">
          <a class="tab" data-tab-target="panel-dashboard" href="/dashboard">仪表盘</a>
          <a class="tab" data-tab-target="panel-model" href="/model">模型配置</a>
          <a class="tab" data-tab-target="panel-chat-console" href="/chat-console">智能对话</a>
          <a class="tab" data-tab-target="panel-skills" href="/skills">技能管理</a>
          <a class="tab" data-tab-target="panel-config-generator" href="/config-generator">配置生成器</a>
          <a class="tab is-active" data-tab-target="panel-channel" href="/channels">平台接入</a>
          <a class="tab" data-tab-target="panel-update" href="/update">版本更新</a>
          <a class="tab" data-tab-target="panel-service" href="/service">服务控制</a>
          <a class="tab" data-tab-target="panel-logs" href="/logs">运行日志</a>
        </nav>
      </aside>

      <main class="content">
        <header class="page-header">
          <div class="channel-page-header-left">
            <a class="channel-back-link" href="/channels" aria-label="返回平台列表" title="返回平台列表">←</a>
            <div>
              <h2 class="page-title">龙虾控制台</h2>
              <p class="page-subtitle">你的 AI 助手管理中心</p>
            </div>
          </div>
          <button id="theme_toggle" class="btn-soft" type="button">切换到深夜模式</button>
        </header>

        <section class="panel is-visible" data-panel="panel-channel">
          <article class="card">
            <h2>Discord 接入配置</h2>
            <p class="muted-line">填写 Discord Bot Token 与权限策略，保存后即可在 Discord 使用龙虾 Bot。</p>
            <div class="channel-page-status">
              <sl-tag id="channel_status_discord_enabled" size="small" pill>未启用</sl-tag>
              <sl-tag id="channel_status_discord_configured" size="small" pill variant="warning">未配置</sl-tag>
            </div>
            <p class="channel-page-summary" id="channel_status_discord_summary">点击保存后会刷新状态。</p>
            <div class="actions" style="margin-top: 12px">
              <button id="save_settings" type="button">保存配置</button>
              <button id="test_discord" class="btn-soft" type="button">测试连接</button>
            </div>
          </article>

          <article class="card">
            <h2>Discord</h2>
            <label class="inline-check" style="margin-bottom: 12px">
              启用 Discord
              <input id="dc_enabled" type="checkbox" />
            </label>
            <div class="grid">
              <label>
                Bot Token
                <input id="dc_token" type="password" autocomplete="off" />
              </label>
            </div>
            <div class="grid" style="margin-top: 12px">
              <label>
                谁能私聊机器人
                <select id="dc_dm_policy">
                  <option value="pairing">需要验证身份（推荐）</option>
                  <option value="allowlist">仅指定用户</option>
                  <option value="open">所有人都能用</option>
                  <option value="disabled">禁止</option>
                </select>
              </label>
              <label>
                谁能在群里用机器人
                <select id="dc_group_policy">
                  <option value="allowlist">仅指定用户</option>
                  <option value="open">所有人都能用</option>
                  <option value="disabled">禁止</option>
                </select>
              </label>
              <label class="inline-check">
                允许其他 Bot 触发
                <input id="dc_allow_bots" type="checkbox" />
              </label>
              <label class="inline-check">
                群里必须 @ 才回复
                <input id="dc_require_mention" type="checkbox" />
              </label>
            </div>
            <sl-details summary="允许使用的用户 ID" style="margin-top: 12px">
              <div class="grid">
                <label>
                  允许使用的用户 ID（每行一个）
                  <textarea id="dc_allow_from" rows="4"></textarea>
                </label>
              </div>
            </sl-details>
            <p id="dc_test_result" class="muted-line">还没测试过</p>
          </article>
        </section>

        <section class="card">
          <h2>操作记录</h2>
          <p class="muted-line">每次点击后的结果都会记录在这里，方便你定位问题。</p>
          <pre id="messages" class="output"></pre>
        </section>
      </main>
    </div>

    <script type="module" src="/app.js"></script>
  </body>
</html>
</file>

<file path="public/pages/channels-feishu.html">
<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>OpenClaw 龙虾控制台</title>
    <script>
      (function initThemeEarly() {
        var theme = "light";
        try {
          var saved = window.localStorage.getItem("openclaw-panel-theme");
          theme = saved === "dark" ? "dark" : "light";
        } catch (_error) {
          theme = "light";
        }
        var root = document.documentElement;
        root.dataset.theme = theme;
        root.classList.toggle("sl-theme-dark", theme === "dark");
        root.classList.toggle("sl-theme-light", theme !== "dark");
      })();
    </script>
    <link rel="stylesheet" href="/shoelace/themes/light.css" />
    <link rel="stylesheet" href="/shoelace/themes/dark.css" />
    <link rel="stylesheet" href="/styles.css" />
    <script type="module" src="/shoelace/shoelace-autoloader.js"></script>
    <style>
      .channel-page-status {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin: 10px 0 4px;
      }

      .channel-page-summary {
        margin: 0;
        color: var(--muted);
        font-size: 12px;
      }

      .channel-page-header-left {
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .channel-back-link {
        width: 34px;
        height: 34px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        border: 1px solid var(--border);
        border-radius: 9px;
        background: var(--soft-button);
        color: var(--text);
        text-decoration: none;
        font-size: 18px;
        line-height: 1;
      }

      .channel-back-link:hover {
        background: var(--soft-button-hover);
      }
    </style>
  </head>
  <body data-theme="light">
    <div class="layout">
      <aside class="sidebar">
        <div class="brand">
          <p class="eyebrow">OpenClaw</p>
          <h1>龙虾控制台</h1>
          <p class="sub">管理你的 AI 助手：模型、渠道、技能，一站搞定。</p>
        </div>

        <nav class="tabs sidebar-tabs">
          <a class="tab" data-tab-target="panel-dashboard" href="/dashboard">仪表盘</a>
          <a class="tab" data-tab-target="panel-model" href="/model">模型配置</a>
          <a class="tab" data-tab-target="panel-chat-console" href="/chat-console">智能对话</a>
          <a class="tab" data-tab-target="panel-skills" href="/skills">技能管理</a>
          <a class="tab" data-tab-target="panel-config-generator" href="/config-generator">配置生成器</a>
          <a class="tab is-active" data-tab-target="panel-channel" href="/channels">平台接入</a>
          <a class="tab" data-tab-target="panel-update" href="/update">版本更新</a>
          <a class="tab" data-tab-target="panel-service" href="/service">服务控制</a>
          <a class="tab" data-tab-target="panel-logs" href="/logs">运行日志</a>
        </nav>
      </aside>

      <main class="content">
        <header class="page-header">
          <div class="channel-page-header-left">
            <a class="channel-back-link" href="/channels" aria-label="返回平台列表" title="返回平台列表">←</a>
            <div>
              <h2 class="page-title">龙虾控制台</h2>
              <p class="page-subtitle">你的 AI 助手管理中心</p>
            </div>
          </div>
          <button id="theme_toggle" class="btn-soft" type="button">切换到深夜模式</button>
        </header>

        <section class="panel is-visible" data-panel="panel-channel">
          <article class="card">
            <h2>飞书接入配置</h2>
            <p class="muted-line">填写 App 信息和连接模式，保存后即可在飞书使用龙虾 Bot。</p>
            <div class="channel-page-status">
              <sl-tag id="channel_status_feishu_enabled" size="small" pill>未启用</sl-tag>
              <sl-tag id="channel_status_feishu_configured" size="small" pill variant="warning">未配置</sl-tag>
            </div>
            <p class="channel-page-summary" id="channel_status_feishu_summary">点击保存后会刷新状态。</p>
            <div class="actions" style="margin-top: 12px">
              <button id="save_settings" type="button">保存配置</button>
              <button id="save_and_test_feishu" class="btn-soft" type="button">保存并测试</button>
            </div>
          </article>

          <article class="card">
            <h2>飞书</h2>
            <label class="inline-check" style="margin-bottom: 12px">
              启用飞书
              <input id="fs_enabled" type="checkbox" />
            </label>
            <div class="grid">
              <label>
                App ID
                <input id="fs_app_id" type="text" />
              </label>
              <label>
                App Secret
                <input id="fs_app_secret" type="password" autocomplete="off" />
              </label>
              <label>
                Domain
                <select id="fs_domain">
                  <option value="feishu">feishu</option>
                  <option value="lark">lark</option>
                </select>
              </label>
              <label>
                连接方式
                <select id="fs_connection_mode">
                  <option value="websocket">长连接（推荐，更稳定）</option>
                  <option value="webhook">Webhook 回调</option>
                </select>
              </label>
            </div>
            <div class="grid" style="margin-top: 12px">
              <label>
                谁能私聊机器人
                <select id="fs_dm_policy">
                  <option value="pairing">需要验证身份（推荐）</option>
                  <option value="allowlist">仅指定用户</option>
                  <option value="open">所有人都能用</option>
                </select>
              </label>
              <label>
                谁能在群里用机器人
                <select id="fs_group_policy">
                  <option value="allowlist">仅指定用户</option>
                  <option value="open">所有人都能用</option>
                  <option value="disabled">禁止</option>
                </select>
              </label>
              <label class="inline-check">
                群里必须 @ 才回复
                <input id="fs_require_mention" type="checkbox" />
              </label>
            </div>
            <sl-details summary="允许使用的用户 / 群组 ID" style="margin-top: 12px">
              <div class="grid">
                <label>
                  允许使用的用户 ID（每行一个）
                  <textarea id="fs_allow_from" rows="4"></textarea>
                </label>
                <label>
                  允许使用的群组 ID（每行一个）
                  <textarea id="fs_group_allow_from" rows="4"></textarea>
                </label>
              </div>
            </sl-details>
            <div class="actions" style="margin-top: 12px">
              <button id="test_feishu" class="btn-soft" type="button">测试连接</button>
            </div>
            <p id="fs_test_result" class="muted-line">还没测试过</p>
          </article>
        </section>

        <section class="card">
          <h2>操作记录</h2>
          <p class="muted-line">每次点击后的结果都会记录在这里，方便你定位问题。</p>
          <pre id="messages" class="output"></pre>
        </section>
      </main>
    </div>

    <script type="module" src="/app.js"></script>
  </body>
</html>
</file>

<file path="public/pages/channels-slack.html">
<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>OpenClaw 龙虾控制台</title>
    <script>
      (function initThemeEarly() {
        var theme = "light";
        try {
          var saved = window.localStorage.getItem("openclaw-panel-theme");
          theme = saved === "dark" ? "dark" : "light";
        } catch (_error) {
          theme = "light";
        }
        var root = document.documentElement;
        root.dataset.theme = theme;
        root.classList.toggle("sl-theme-dark", theme === "dark");
        root.classList.toggle("sl-theme-light", theme !== "dark");
      })();
    </script>
    <link rel="stylesheet" href="/shoelace/themes/light.css" />
    <link rel="stylesheet" href="/shoelace/themes/dark.css" />
    <link rel="stylesheet" href="/styles.css" />
    <script type="module" src="/shoelace/shoelace-autoloader.js"></script>
    <style>
      .channel-page-status {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin: 10px 0 4px;
      }

      .channel-page-summary {
        margin: 0;
        color: var(--muted);
        font-size: 12px;
      }

      .channel-page-header-left {
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .channel-back-link {
        width: 34px;
        height: 34px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        border: 1px solid var(--border);
        border-radius: 9px;
        background: var(--soft-button);
        color: var(--text);
        text-decoration: none;
        font-size: 18px;
        line-height: 1;
      }

      .channel-back-link:hover {
        background: var(--soft-button-hover);
      }
    </style>
  </head>
  <body data-theme="light">
    <div class="layout">
      <aside class="sidebar">
        <div class="brand">
          <p class="eyebrow">OpenClaw</p>
          <h1>龙虾控制台</h1>
          <p class="sub">管理你的 AI 助手：模型、渠道、技能，一站搞定。</p>
        </div>

        <nav class="tabs sidebar-tabs">
          <a class="tab" data-tab-target="panel-dashboard" href="/dashboard">仪表盘</a>
          <a class="tab" data-tab-target="panel-model" href="/model">模型配置</a>
          <a class="tab" data-tab-target="panel-chat-console" href="/chat-console">智能对话</a>
          <a class="tab" data-tab-target="panel-skills" href="/skills">技能管理</a>
          <a class="tab" data-tab-target="panel-config-generator" href="/config-generator">配置生成器</a>
          <a class="tab is-active" data-tab-target="panel-channel" href="/channels">平台接入</a>
          <a class="tab" data-tab-target="panel-update" href="/update">版本更新</a>
          <a class="tab" data-tab-target="panel-service" href="/service">服务控制</a>
          <a class="tab" data-tab-target="panel-logs" href="/logs">运行日志</a>
        </nav>
      </aside>

      <main class="content">
        <header class="page-header">
          <div class="channel-page-header-left">
            <a class="channel-back-link" href="/channels" aria-label="返回平台列表" title="返回平台列表">←</a>
            <div>
              <h2 class="page-title">龙虾控制台</h2>
              <p class="page-subtitle">你的 AI 助手管理中心</p>
            </div>
          </div>
          <button id="theme_toggle" class="btn-soft" type="button">切换到深夜模式</button>
        </header>

        <section class="panel is-visible" data-panel="panel-channel">
          <article class="card">
            <h2>Slack 接入配置</h2>
            <p class="muted-line">填写 Slack 凭证并选择连接模式，保存后就能在 Slack 使用龙虾 Bot。</p>
            <div class="channel-page-status">
              <sl-tag id="channel_status_slack_enabled" size="small" pill>未启用</sl-tag>
              <sl-tag id="channel_status_slack_configured" size="small" pill variant="warning">未配置</sl-tag>
            </div>
            <p class="channel-page-summary" id="channel_status_slack_summary">点击保存后会刷新状态。</p>
            <div class="actions" style="margin-top: 12px">
              <button id="save_settings" type="button">保存配置</button>
              <button id="test_slack" class="btn-soft" type="button">测试连接</button>
            </div>
          </article>

          <article class="card">
            <h2>Slack</h2>
            <label class="inline-check" style="margin-bottom: 12px">
              启用 Slack
              <input id="sl_enabled" type="checkbox" />
            </label>
            <div class="grid">
              <label>
                连接模式
                <select id="sl_mode">
                  <option value="socket">Socket</option>
                  <option value="http">HTTP</option>
                </select>
              </label>
              <label>
                Bot Token（xoxb- 开头）
                <input id="sl_bot_token" type="password" autocomplete="off" />
              </label>
              <label>
                App Token（xapp- 开头）
                <input id="sl_app_token" type="password" autocomplete="off" />
              </label>
              <label>
                Signing Secret（Webhook 模式必填）
                <input id="sl_signing_secret" type="password" autocomplete="off" />
              </label>
            </div>
            <div class="grid" style="margin-top: 12px">
              <label>
                谁能私聊机器人
                <select id="sl_dm_policy">
                  <option value="pairing">需要验证身份（推荐）</option>
                  <option value="allowlist">仅指定用户</option>
                  <option value="open">所有人都能用</option>
                  <option value="disabled">禁止</option>
                </select>
              </label>
              <label>
                谁能在群里用机器人
                <select id="sl_group_policy">
                  <option value="allowlist">仅指定用户</option>
                  <option value="open">所有人都能用</option>
                  <option value="disabled">禁止</option>
                </select>
              </label>
              <label class="inline-check">
                允许其他 Bot 触发
                <input id="sl_allow_bots" type="checkbox" />
              </label>
              <label class="inline-check">
                群里必须 @ 才回复
                <input id="sl_require_mention" type="checkbox" />
              </label>
            </div>
            <sl-details summary="允许使用的用户 ID" style="margin-top: 12px">
              <div class="grid">
                <label>
                  允许使用的用户 ID（每行一个）
                  <textarea id="sl_allow_from" rows="4"></textarea>
                </label>
              </div>
            </sl-details>
            <p id="sl_test_result" class="muted-line">还没测试过</p>
          </article>
        </section>

        <section class="card">
          <h2>操作记录</h2>
          <p class="muted-line">每次点击后的结果都会记录在这里，方便你定位问题。</p>
          <pre id="messages" class="output"></pre>
        </section>
      </main>
    </div>

    <script type="module" src="/app.js"></script>
  </body>
</html>
</file>

<file path="public/pages/model-add.html">
<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>OpenClaw 龙虾控制台</title>
    <script>
      (function initThemeEarly() {
        var theme = "light";
        try {
          var saved = window.localStorage.getItem("openclaw-panel-theme");
          theme = saved === "dark" ? "dark" : "light";
        } catch (_error) {
          theme = "light";
        }
        var root = document.documentElement;
        root.dataset.theme = theme;
        root.classList.toggle("sl-theme-dark", theme === "dark");
        root.classList.toggle("sl-theme-light", theme !== "dark");
      })();
    </script>
    <link rel="stylesheet" href="/shoelace/themes/light.css" />
    <link rel="stylesheet" href="/shoelace/themes/dark.css" />
    <link rel="stylesheet" href="/styles.css" />
    <script type="module" src="/shoelace/shoelace-autoloader.js"></script>
  </head>
  <body data-theme="light">
    <div class="layout">
      <aside class="sidebar">
        <div class="brand">
          <p class="eyebrow">OpenClaw</p>
          <h1>龙虾控制台</h1>
          <p class="sub">管理你的 AI 助手：模型、渠道、技能，一站搞定。</p>
        </div>

        <nav class="tabs sidebar-tabs">
          <a class="tab" data-tab-target="panel-dashboard" href="/dashboard">仪表盘</a>
          <a class="tab is-active" data-tab-target="panel-model-add" href="/model/add">模型配置</a>
          <a class="tab" data-tab-target="panel-chat-console" href="/chat-console">智能对话</a>
          <a class="tab" data-tab-target="panel-skills" href="/skills">技能管理</a>
          <a class="tab" data-tab-target="panel-config-generator" href="/config-generator">配置生成器</a>
          <a class="tab" data-tab-target="panel-channel" href="/channels">平台接入</a>
          <a class="tab" data-tab-target="panel-update" href="/update">版本更新</a>
          <a class="tab" data-tab-target="panel-service" href="/service">服务控制</a>
          <a class="tab" data-tab-target="panel-logs" href="/logs">运行日志</a>
        </nav>
      </aside>

      <main class="content">
        <header class="page-header">
          <div class="page-header-left">
            <a class="page-back-link" href="/model" aria-label="返回模型列表" title="返回模型列表">←</a>
            <div>
              <h2 class="page-title">模型配置</h2>
              <p class="page-subtitle">添加模型与供应商</p>
            </div>
          </div>
          <div class="page-header-actions">
            <button id="theme_toggle" class="btn-soft" type="button">切换到深夜模式</button>
          </div>
        </header>

        <section class="panel is-visible" data-panel="panel-model-add">
          <article id="model_provider_mode_section" class="card">
            <h2>添加模型</h2>
            <p class="muted-line">选择一种添加路径后填写即可。</p>
            <div class="model-provider-mode-switch">
              <button
                class="btn-soft model-provider-mode-btn is-active"
                type="button"
                data-model-provider-mode="template"
                aria-pressed="true"
              >
                直接添加模型
              </button>
              <button class="btn-soft model-provider-mode-btn" type="button" data-model-provider-mode="custom" aria-pressed="false">
                新增供应商并添加模型
              </button>
              <button class="btn-soft model-provider-mode-btn" type="button" data-model-provider-mode="existing" aria-pressed="false">
                基于已有供应商添加
              </button>
            </div>
            <p id="model_provider_mode_hint" class="muted-line">直接添加模型：选择或自定义模型 ID，每次只写入一个模型。</p>
          </article>

          <article id="model_provider_template_section" class="card model-add-workspace" data-model-provider-mode-panel="template">
            <h2>直接添加模型</h2>
            <p class="muted-line">选模型系列后指定一个模型 ID，只写入这一个模型。</p>
            <div class="grid">
              <label>
                模型系列
                <select id="model_template_key">
                  <option value="aicodecat-gpt">GPT 系列</option>
                  <option value="aicodecat-claude">Claude 系列</option>
                  <option value="aicodecat-gemini">Gemini 系列</option>
                </select>
              </label>
              <label>
                提供商名称
                <input id="template_provider_id" type="text" />
              </label>
              <label>
                模型 ID
                <div class="field-stack">
                  <select id="template_model_id"></select>
                  <input id="template_model_id_custom" class="custom-field" type="text" placeholder="输入自定义模型 ID" />
                </div>
              </label>
              <label>
                模型名称（可选）
                <input id="template_model_name" type="text" placeholder="不填则默认使用模型 ID" />
              </label>
              <label>
                API 地址
                <input id="template_base_url" type="url" />
              </label>
              <label>
                API 密钥
                <input id="template_api_key" type="password" autocomplete="off" />
              </label>
            </div>
            <details>
              <summary>高级参数（通常不用改）</summary>
              <div class="grid">
                <label>
                  接口协议
                  <div class="field-stack">
                    <select id="template_api">
                      <option value="openai-responses">openai-responses（GPT Responses）</option>
                      <option value="openai-completions">openai-completions（GPT 兼容）</option>
                      <option value="anthropic-messages">anthropic-messages（Claude）</option>
                      <option value="google-generative-ai">google-generative-ai（Gemini）</option>
                      <option value="custom">自定义</option>
                    </select>
                    <input id="template_api_custom" class="custom-field" type="text" placeholder="输入自定义 API 模式" />
                  </div>
                </label>
                <label class="inline-check">
                  保存后设为当前默认模型
                  <input id="template_set_as_primary" type="checkbox" />
                </label>
              </div>
            </details>
            <label>
              将写入的模型（单个）
              <pre id="template_model_preview" class="output"></pre>
            </label>
            <div class="actions">
              <button id="save_provider_template">保存</button>
            </div>
            <p id="save_provider_template_status" class="model-add-save-status" role="status" aria-live="polite">
              填写后点击“保存”，这里会显示结果。
            </p>
          </article>

          <article
            id="model_provider_existing_section"
            class="card model-add-workspace is-hidden"
            data-model-provider-mode-panel="existing"
          >
            <h2>基于已有供应商添加模型</h2>
            <p class="muted-line">先选已有供应商，再填模型信息。</p>
            <div class="grid">
              <label>
                已有供应商
                <select id="existing_provider_id"></select>
              </label>
              <label>
                接口协议（只读）
                <input id="existing_provider_api" type="text" readonly />
              </label>
              <label>
                API 地址（只读）
                <input id="existing_provider_baseurl" type="text" readonly />
              </label>
              <label>
                模型 ID
                <div class="field-stack">
                  <select id="existing_model_id"></select>
                  <input id="existing_model_id_custom" class="custom-field" type="text" placeholder="输入自定义模型 ID" />
                </div>
              </label>
              <label>
                模型名称
                <input id="existing_model_name" type="text" placeholder="例如 GPT-5.2 Mini" />
              </label>
              <label>
                上下文长度
                <input id="existing_model_context_window" type="number" min="1" step="1" placeholder="例如 200000" />
              </label>
              <label>
                最大输出长度
                <input id="existing_model_max_tokens" type="number" min="1" step="1" placeholder="例如 8192" />
              </label>
              <label class="inline-check">
                保存后设为当前默认模型
                <input id="existing_set_as_primary" type="checkbox" />
              </label>
            </div>
            <div class="actions">
              <button id="save_provider_existing">保存</button>
            </div>
            <p id="save_provider_existing_status" class="model-add-save-status" role="status" aria-live="polite">
              填写后点击“保存”，这里会显示结果。
            </p>
          </article>

          <article id="model_provider_custom_section" class="card model-add-workspace is-hidden" data-model-provider-mode-panel="custom">
            <h2>新增供应商并添加模型</h2>
            <p class="muted-line">新增供应商后，指定一个模型 ID 进行写入。</p>
            <div class="grid">
              <label>
                供应商名称
                <input id="custom_provider_id" type="text" placeholder="例如 my-provider" />
              </label>
              <label>
                API 地址
                <input id="custom_base_url" type="url" placeholder="例如 https://api.example.com/v1" />
              </label>
              <label>
                API 密钥
                <input id="custom_api_key" type="password" autocomplete="off" />
              </label>
              <label>
                模型 ID
                <div class="field-stack">
                  <select id="custom_model_id"></select>
                  <input id="custom_model_id_custom" class="custom-field" type="text" placeholder="输入自定义模型 ID" />
                </div>
              </label>
              <label>
                模型名称（可选）
                <input id="custom_model_name" type="text" placeholder="不填则默认使用模型 ID" />
              </label>
              <label>
                上下文长度（可选）
                <input id="custom_model_context_window" type="number" min="1" step="1" placeholder="例如 200000" />
              </label>
              <label>
                最大输出长度（可选）
                <input id="custom_model_max_tokens" type="number" min="1" step="1" placeholder="例如 8192" />
              </label>
            </div>
            <details>
              <summary>高级参数（通常不用改）</summary>
              <div class="grid">
                <label>
                  接口协议
                  <div class="field-stack">
                    <select id="custom_api">
                      <option value="openai-responses">openai-responses（GPT Responses）</option>
                      <option value="openai-completions">openai-completions（GPT 兼容）</option>
                      <option value="anthropic-messages">anthropic-messages（Claude）</option>
                      <option value="google-generative-ai">google-generative-ai（Gemini）</option>
                      <option value="custom">自定义</option>
                    </select>
                    <input id="custom_api_custom" class="custom-field" type="text" placeholder="输入自定义 API 模式" />
                  </div>
                </label>
                <label class="inline-check">
                  保存后设为当前默认模型
                  <input id="custom_set_as_primary" type="checkbox" />
                </label>
              </div>
            </details>
            <div class="actions">
              <button id="save_provider_custom">保存</button>
            </div>
            <p id="save_provider_custom_status" class="model-add-save-status" role="status" aria-live="polite">
              填写后点击“保存”，这里会显示结果。
            </p>
          </article>
        </section>

        <section class="card">
          <h2>操作记录</h2>
          <p class="muted-line">每次操作的结果都会记录在这里。</p>
          <pre id="messages" class="output"></pre>
        </section>
      </main>
    </div>

    <script type="module" src="/app.js"></script>
  </body>
</html>
</file>

<file path="src/channel-onboarding.js">
import { execFile } from "node:child_process";

const DEFAULT_TIMEOUT_MS = 30_000;
const DEFAULT_DOCKER_CLI_PREFIXES = [
  ["openclaw"],
  ["node", "/app/openclaw.mjs"]
];
const DEFAULT_SETUP_STEP_RETRY_ATTEMPTS = 3;
const DEFAULT_SETUP_STEP_RETRY_DELAY_MS = 400;

function trimText(value) {
  return String(value || "").trim();
}

function toPositiveInt(value, fallback) {
  const parsed = Number(value);
  if (!Number.isFinite(parsed) || parsed <= 0) {
    return fallback;
  }
  return Math.floor(parsed);
}

function composeContainerName(panelConfig) {
  return trimText(panelConfig?.openclaw?.container_name || panelConfig?.openclaw?.service_name || "openclaw-gateway");
}

function shellEscape(value) {
  const text = String(value ?? "");
  if (!text) {
    return "''";
  }
  if (/^[A-Za-z0-9_./:=-]+$/.test(text)) {
    return text;
  }
  return `'${text.replace(/'/g, "'\\''")}'`;
}

function normalizeDockerCliPrefix(prefix) {
  if (!Array.isArray(prefix)) {
    return [];
  }
  return prefix.map((part) => trimText(part)).filter(Boolean);
}

function buildInvocation(panelConfig, openclawArgs, dockerCliPrefix = []) {
  const runtimeMode = trimText(panelConfig?.runtime?.mode) || "systemd";
  if (runtimeMode === "docker") {
    const containerName = composeContainerName(panelConfig);
    const cliPrefix = normalizeDockerCliPrefix(dockerCliPrefix);
    const normalizedCliPrefix = cliPrefix.length > 0 ? cliPrefix : [...DEFAULT_DOCKER_CLI_PREFIXES[0]];
    return {
      runtimeMode,
      containerName,
      dockerCliPrefix: normalizedCliPrefix,
      command: "docker",
      args: ["exec", containerName, ...normalizedCliPrefix, ...openclawArgs],
      openclawArgStartIndex: 2 + normalizedCliPrefix.length
    };
  }
  return {
    runtimeMode,
    containerName: "",
    dockerCliPrefix: [],
    command: "openclaw",
    args: [...openclawArgs],
    openclawArgStartIndex: 0
  };
}

function maskSecrets(text, secrets = []) {
  const raw = String(text || "");
  if (!raw) {
    return "";
  }
  return secrets
    .map((item) => trimText(item))
    .filter(Boolean)
    .reduce((current, secret) => current.split(secret).join("***"), raw);
}

function formatCommand(invocation, redactOpenclawArgIndices = []) {
  const redactSet = new Set(
    (Array.isArray(redactOpenclawArgIndices) ? redactOpenclawArgIndices : [])
      .map((index) => Number(index))
      .filter((index) => Number.isInteger(index) && index >= 0)
  );
  const renderedArgs = invocation.args.map((arg, index) => {
    const openclawIndex = index - invocation.openclawArgStartIndex;
    if (openclawIndex >= 0 && redactSet.has(openclawIndex)) {
      return "***";
    }
    return shellEscape(arg);
  });
  return [invocation.command, ...renderedArgs].join(" ");
}

async function runCommand(command, args, timeoutMs, exec = execFile) {
  return await new Promise((resolve) => {
    exec(command, args, { timeout: timeoutMs, maxBuffer: 10 * 1024 * 1024 }, (error, stdout, stderr) => {
      resolve({
        ok: !error,
        code: error?.code ?? 0,
        stdout: String(stdout || ""),
        stderr: String(stderr || ""),
        message: String(error?.message || "")
      });
    });
  });
}

function normalizeCommandResult(result, invocation, { secrets = [], redactOpenclawArgIndices = [] } = {}) {
  const stdout = maskSecrets(trimText(result?.stdout), secrets);
  const stderr = maskSecrets(trimText(result?.stderr), secrets);
  const message = maskSecrets(trimText(result?.message), secrets);
  const output = [stdout, stderr, message].filter(Boolean).join("\n").trim();
  return {
    ok: Boolean(result?.ok),
    code: Number.isFinite(Number(result?.code)) ? Number(result.code) : 0,
    runtimeMode: invocation.runtimeMode,
    containerName: invocation.containerName,
    command: formatCommand(invocation, redactOpenclawArgIndices),
    stdout,
    stderr,
    message,
    output
  };
}

function isAlreadyEnabledOutput(output) {
  const text = String(output || "").toLowerCase();
  return text.includes("already enabled") || text.includes("已经启用") || text.includes("已启用");
}

function isMissingExecutableResult(rawResult, executableName) {
  const executable = trimText(executableName).toLowerCase();
  if (!executable) {
    return false;
  }
  const text = [trimText(rawResult?.stdout), trimText(rawResult?.stderr), trimText(rawResult?.message)]
    .filter(Boolean)
    .join("\n")
    .toLowerCase();
  if (!text) {
    return false;
  }
  const hasExecName = text.includes(`exec: "${executable}"`) || text.includes(`exec: ${executable}`);
  if (!hasExecName) {
    return false;
  }
  return (
    text.includes("executable file not found") ||
    text.includes("not found in $path") ||
    text.includes("no such file or directory")
  );
}

function prependFallbackHint(output, fromPrefix, toPrefix) {
  const hint = `检测到容器内未找到 '${fromPrefix.join(" ")}'，已自动改用 '${toPrefix.join(" ")}'。`;
  const normalizedOutput = trimText(output);
  return [hint, normalizedOutput].filter(Boolean).join("\n");
}

function parseJsonOutput(text, label = "命令") {
  const raw = trimText(text);
  if (!raw) {
    throw new Error(`${label} 返回为空，无法解析 JSON`);
  }
  try {
    return JSON.parse(raw);
  } catch (error) {
    throw new Error(`${label} 返回非 JSON：${error.message || String(error)}`);
  }
}

function pickRequestId(pendingItem = {}) {
  const candidates = [pendingItem.requestId, pendingItem.request, pendingItem.id, pendingItem.request_id];
  for (const item of candidates) {
    const value = trimText(item);
    if (value) {
      return value;
    }
  }
  return "";
}

function normalizePendingEntry(pendingItem = {}) {
  return {
    requestId: pickRequestId(pendingItem),
    deviceId: trimText(pendingItem.deviceId || pendingItem.device),
    role: trimText(pendingItem.role || (Array.isArray(pendingItem.roles) ? pendingItem.roles[0] : "")),
    clientId: trimText(pendingItem.clientId),
    clientMode: trimText(pendingItem.clientMode)
  };
}

export async function runOpenClawCli({
  panelConfig,
  openclawArgs,
  dockerCliPrefix = [],
  timeoutMs = DEFAULT_TIMEOUT_MS,
  redactOpenclawArgIndices = [],
  secrets = [],
  deps = {}
}) {
  const normalizedArgs = Array.isArray(openclawArgs) ? openclawArgs.map((arg) => String(arg)) : [];
  if (normalizedArgs.length === 0) {
    throw new Error("openclawArgs 不能为空");
  }

  const runFn = deps.runCommand || runCommand;
  const runtimeMode = trimText(panelConfig?.runtime?.mode) || "systemd";
  if (runtimeMode !== "docker") {
    const invocation = buildInvocation(panelConfig, normalizedArgs, dockerCliPrefix);
    const raw = await runFn(invocation.command, invocation.args, timeoutMs);
    const normalized = normalizeCommandResult(raw, invocation, {
      secrets,
      redactOpenclawArgIndices
    });
    return {
      ...normalized,
      dockerCliPrefix: []
    };
  }

  const requestedDockerCliPrefix = normalizeDockerCliPrefix(dockerCliPrefix);
  const dockerCliCandidates = requestedDockerCliPrefix.length > 0 ? [requestedDockerCliPrefix] : DEFAULT_DOCKER_CLI_PREFIXES;
  let previousMissingPrefix = [];

  for (let index = 0; index < dockerCliCandidates.length; index += 1) {
    const currentPrefix = dockerCliCandidates[index];
    const invocation = buildInvocation(panelConfig, normalizedArgs, currentPrefix);
    const raw = await runFn(invocation.command, invocation.args, timeoutMs);
    const normalized = normalizeCommandResult(raw, invocation, {
      secrets,
      redactOpenclawArgIndices
    });
    const canFallback = index < dockerCliCandidates.length - 1;
    const missingExecutable = !normalized.ok && isMissingExecutableResult(raw, currentPrefix[0]);

    if (missingExecutable && canFallback) {
      previousMissingPrefix = currentPrefix;
      continue;
    }

    if (previousMissingPrefix.length > 0) {
      normalized.output = prependFallbackHint(normalized.output, previousMissingPrefix, currentPrefix);
    }

    return {
      ...normalized,
      dockerCliPrefix: [...currentPrefix]
    };
  }

  const fallbackPrefix = normalizeDockerCliPrefix(dockerCliPrefix);
  return {
    ok: false,
    code: 1,
    runtimeMode: "docker",
    containerName: composeContainerName(panelConfig),
    command: formatCommand(buildInvocation(panelConfig, normalizedArgs, fallbackPrefix.length > 0 ? fallbackPrefix : ["openclaw"])),
    output: "未找到可用的 OpenClaw CLI 入口。请检查容器内 openclaw 可执行文件或 /app/openclaw.mjs 是否存在。",
    dockerCliPrefix: fallbackPrefix
  };
}

export async function setupTelegramBasic({ panelConfig, botToken, deps = {} }) {
  const token = trimText(botToken);
  if (!token) {
    throw new Error("Bot Token 不能为空");
  }
  const setupRetryAttempts = toPositiveInt(deps.setupStepRetryAttempts, DEFAULT_SETUP_STEP_RETRY_ATTEMPTS);
  const setupRetryDelayMs = toPositiveInt(deps.setupStepRetryDelayMs, DEFAULT_SETUP_STEP_RETRY_DELAY_MS);
  const wait =
    typeof deps.sleep === "function"
      ? deps.sleep
      : async (ms) =>
          await new Promise((resolve) => {
            setTimeout(resolve, ms);
          });

  let activeDockerCliPrefix = [];

  const stepDefs = [
    {
      label: "启用 Telegram 插件",
      openclawArgs: ["plugins", "enable", "telegram"],
      allowAlreadyEnabled: true
    },
    {
      label: "启用 Telegram 渠道",
      openclawArgs: ["config", "set", "channels.telegram.enabled", "true"]
    },
    {
      label: "写入 Telegram Bot Token",
      openclawArgs: ["config", "set", "channels.telegram.botToken", token],
      redactOpenclawArgIndices: [3],
      secrets: [token]
    }
  ];

  const steps = [];
  for (const definition of stepDefs) {
    let accepted = false;
    for (let attempt = 1; attempt <= setupRetryAttempts; attempt += 1) {
      const { dockerCliPrefix: resolvedDockerCliPrefix, ...result } = await runOpenClawCli({
        panelConfig,
        openclawArgs: definition.openclawArgs,
        dockerCliPrefix: activeDockerCliPrefix,
        redactOpenclawArgIndices: definition.redactOpenclawArgIndices || [],
        secrets: definition.secrets || [],
        deps
      });
      if (Array.isArray(resolvedDockerCliPrefix) && resolvedDockerCliPrefix.length > 0) {
        activeDockerCliPrefix = [...resolvedDockerCliPrefix];
      }
      accepted =
        Boolean(result.ok) || (definition.allowAlreadyEnabled === true && isAlreadyEnabledOutput(result.output));
      const retryWaitMs = setupRetryDelayMs * attempt;
      const needsRetryHint = !accepted && attempt < setupRetryAttempts;
      const output = needsRetryHint
        ? [result.output, `步骤失败，${retryWaitMs}ms 后自动重试`].filter(Boolean).join("\n")
        : result.output;
      const step = {
        ...result,
        ok: accepted,
        label: setupRetryAttempts > 1 ? `${definition.label}（尝试 ${attempt}/${setupRetryAttempts}）` : definition.label,
        output
      };
      steps.push(step);

      if (accepted) {
        break;
      }
      if (needsRetryHint) {
        await wait(retryWaitMs);
      }
    }

    if (!accepted) {
      return {
        ok: false,
        failedStep: definition.label,
        message: `${definition.label}失败（已重试 ${setupRetryAttempts} 次）`,
        steps
      };
    }
  }

  return {
    ok: true,
    message: "Telegram 已保存并启用，可继续验证码配对",
    steps
  };
}

export async function approveTelegramPairing({ panelConfig, code, deps = {} }) {
  const pairingCode = trimText(code);
  if (!pairingCode) {
    throw new Error("验证码不能为空");
  }

  const { dockerCliPrefix: _ignoredDockerCliPrefix, ...result } = await runOpenClawCli({
    panelConfig,
    openclawArgs: ["pairing", "approve", "telegram", pairingCode],
    redactOpenclawArgIndices: [3],
    secrets: [pairingCode],
    deps
  });
  if (!result.ok) {
    return {
      ok: false,
      message: "验证码验证失败",
      step: {
        ...result,
        label: "验证码验证"
      }
    };
  }
  return {
    ok: true,
    message: "验证码验证成功，Telegram 已完成配对",
    step: {
      ...result,
      label: "验证码验证"
    }
  };
}

export async function approvePendingGatewayPairings({ panelConfig, deps = {} }) {
  const steps = [];

  const { dockerCliPrefix: resolvedDockerCliPrefix, ...listResult } = await runOpenClawCli({
    panelConfig,
    openclawArgs: ["devices", "list", "--json"],
    deps
  });
  const activeDockerCliPrefix =
    Array.isArray(resolvedDockerCliPrefix) && resolvedDockerCliPrefix.length > 0 ? [...resolvedDockerCliPrefix] : [];
  steps.push({
    ...listResult,
    label: "读取待处理设备配对列表"
  });

  if (!listResult.ok) {
    return {
      ok: false,
      message: "读取待处理设备配对列表失败",
      pendingCount: 0,
      approvedCount: 0,
      failedCount: 0,
      pending: [],
      approvals: [],
      steps
    };
  }

  let pendingList;
  try {
    const payload = parseJsonOutput(listResult.stdout, "openclaw devices list --json");
    const pendingRaw = Array.isArray(payload?.pending) ? payload.pending : [];
    pendingList = pendingRaw.map((item) => normalizePendingEntry(item));
  } catch (error) {
    const detail = error.message || String(error);
    steps.push({
      ok: false,
      code: 1,
      runtimeMode: listResult.runtimeMode,
      containerName: listResult.containerName,
      command: listResult.command,
      stdout: "",
      stderr: "",
      message: detail,
      output: detail,
      label: "解析待处理设备配对列表"
    });
    return {
      ok: false,
      message: detail,
      pendingCount: 0,
      approvedCount: 0,
      failedCount: 0,
      pending: [],
      approvals: [],
      steps
    };
  }

  if (pendingList.length === 0) {
    return {
      ok: true,
      message: "当前没有待批准的设备配对请求",
      pendingCount: 0,
      approvedCount: 0,
      failedCount: 0,
      pending: [],
      approvals: [],
      steps
    };
  }

  const approvals = [];
  let dockerCliPrefixForApprove = activeDockerCliPrefix;
  for (const pending of pendingList) {
    const requestId = trimText(pending.requestId);
    if (!requestId) {
      const detail = "待处理项缺少 requestId，无法批准";
      const failedStep = {
        ok: false,
        code: 1,
        runtimeMode: listResult.runtimeMode,
        containerName: listResult.containerName,
        command: "openclaw devices approve <missing-requestId>",
        stdout: "",
        stderr: "",
        message: detail,
        output: detail,
        label: "批准待处理设备配对"
      };
      approvals.push({
        requestId: "",
        deviceId: pending.deviceId,
        role: pending.role,
        ok: false,
        output: detail
      });
      steps.push(failedStep);
      continue;
    }

    const { dockerCliPrefix: nextDockerCliPrefix, ...approveResult } = await runOpenClawCli({
      panelConfig,
      openclawArgs: ["devices", "approve", requestId],
      dockerCliPrefix: dockerCliPrefixForApprove,
      deps
    });
    if (Array.isArray(nextDockerCliPrefix) && nextDockerCliPrefix.length > 0) {
      dockerCliPrefixForApprove = [...nextDockerCliPrefix];
    }

    approvals.push({
      requestId,
      deviceId: pending.deviceId,
      role: pending.role,
      ok: approveResult.ok,
      output: approveResult.output
    });
    steps.push({
      ...approveResult,
      label: `批准待处理设备配对 ${requestId}`
    });
  }

  const approvedCount = approvals.filter((item) => item.ok).length;
  const failedCount = approvals.length - approvedCount;
  const allSucceeded = failedCount === 0;

  return {
    ok: allSucceeded,
    message: allSucceeded
      ? `已批准 ${approvedCount} 个待处理设备配对请求`
      : `待处理设备配对共 ${pendingList.length} 个，成功 ${approvedCount} 个，失败 ${failedCount} 个`,
    pendingCount: pendingList.length,
    approvedCount,
    failedCount,
    pending: pendingList,
    approvals,
    steps
  };
}
</file>

<file path="src/openclaw-config/extract.js">
import { maskSecret } from "../utils.js";
import {
  firstNonEmptyString,
  normalizeInlineButtons,
  pickChannel,
  pickDefaultAccount,
  toDelimitedList,
  toOptionalNonNegativeInt,
  toOptionalPositiveInt,
  toPrettyJson
} from "./helpers.js";

function readOptionalProbability(value) {
  if (typeof value !== "number" || !Number.isFinite(value)) {
    return null;
  }
  return value >= 0 && value <= 1 ? value : null;
}

function extractSettings(openclawConfig) {
  const providers = openclawConfig?.models?.providers || {};
  const agentDefaults = openclawConfig?.agents?.defaults || {};
  const agentModelOverrides = agentDefaults?.models && typeof agentDefaults.models === "object" ? agentDefaults.models : {};
  const globalThinkingDefault = String(agentDefaults?.thinkingDefault || "").trim();
  const primaryRef = String(openclawConfig?.agents?.defaults?.model?.primary || "").trim();
  const [primaryProviderId, primaryModelId] = primaryRef.includes("/") ? primaryRef.split("/", 2) : ["", ""];

  const providerIds = Object.keys(providers);
  const hasPrimaryProvider = Boolean(primaryProviderId && Object.prototype.hasOwnProperty.call(providers, primaryProviderId));
  const providerId = hasPrimaryProvider ? primaryProviderId : providerIds[0] || "";
  const provider = providerId ? providers[providerId] || {} : {};
  const providerModels = Array.isArray(provider.models) ? provider.models : [];
  const model =
    providerModels.find((item) => String(item?.id || "") === String(primaryModelId || "")) || providerModels[0] || {};

  const telegram = pickChannel(openclawConfig, "telegram", {});
  const rawFeishu = pickChannel(openclawConfig, "feishu", pickChannel(openclawConfig, "feishu-china", {}));
  const feishuAccount = pickDefaultAccount(rawFeishu);
  const feishu = {
    ...rawFeishu,
    ...(feishuAccount.account || {})
  };
  const rawDiscord = pickChannel(openclawConfig, "discord", {});
  const discordAccount = pickDefaultAccount(rawDiscord);
  const discord = {
    ...rawDiscord,
    ...(discordAccount.account || {})
  };
  const rawSlack = pickChannel(openclawConfig, "slack", {});
  const slackAccount = pickDefaultAccount(rawSlack);
  const slack = {
    ...rawSlack,
    ...(slackAccount.account || {})
  };
  const telegramWildcardGroup = telegram?.groups?.["*"] || {};
  const telegramActions = telegram?.actions && typeof telegram.actions === "object" ? telegram.actions : {};
  const telegramRetry = telegram?.retry && typeof telegram.retry === "object" ? telegram.retry : {};
  const telegramRetryJitterValue = readOptionalProbability(telegramRetry.jitter);
  const telegramNetwork = telegram?.network && typeof telegram.network === "object" ? telegram.network : {};
  const telegramInlineButtons = normalizeInlineButtons(telegram?.capabilities);
  const telegramCommands = telegram?.commands && typeof telegram.commands === "object" ? telegram.commands : {};
  const telegramCommandsNative =
    typeof telegramCommands.native === "boolean"
      ? String(telegramCommands.native)
      : String(telegramCommands.native || "").trim() === "auto"
        ? "auto"
        : "default";
  const discordWildcardGuild = discord?.guilds?.["*"] || {};
  const discordDmPolicy = discord.dmPolicy || discord?.dm?.policy || "pairing";
  const discordAllowFrom = discord.allowFrom ?? discord?.dm?.allowFrom ?? [];
  const slackDmPolicy = slack.dmPolicy || slack?.dm?.policy || "pairing";
  const slackAllowFrom = slack.allowFrom ?? slack?.dm?.allowFrom ?? [];
  const providerEntries = Object.entries(providers).map(([id, item]) => {
    const models = Array.isArray(item?.models) ? item.models : [];
    return {
      id,
      api: String(item?.api || ""),
      baseUrl: String(item?.baseUrl || ""),
      modelCount: models.length,
      models: models.map((providerModel) => {
        const modelId = String(providerModel?.id || "");
        const modelRef = `${id}/${modelId}`;
        const modelOverride = agentModelOverrides?.[modelRef] || {};
        const thinkingStrength =
          firstNonEmptyString([
            modelOverride?.thinkingStrength,
            modelOverride?.thinking,
            modelOverride?.thinkingLevel,
            modelOverride?.reasoningEffort,
            providerModel?.thinkingStrength,
            providerModel?.thinking,
            providerModel?.thinkingLevel,
            providerModel?.reasoningEffort,
            globalThinkingDefault
          ]) || "无";

        return {
          id: modelId,
          name: String(providerModel?.name || providerModel?.id || ""),
          reasoning: Boolean(providerModel?.reasoning),
          input: Array.isArray(providerModel?.input) ? providerModel.input.map((inputType) => String(inputType)) : [],
          contextWindow: Number(providerModel?.contextWindow || 0) || undefined,
          maxTokens: Number(providerModel?.maxTokens || 0) || undefined,
          thinkingStrength
        };
      })
    };
  });
  const modelRefs = providerEntries.flatMap((entry) =>
    entry.models.map((providerModel) => ({
      ref: `${entry.id}/${providerModel.id}`,
      providerId: entry.id,
      providerApi: entry.api,
      providerBaseUrl: entry.baseUrl,
      modelId: providerModel.id,
      modelName: providerModel.name || providerModel.id,
      contextWindow: providerModel.contextWindow,
      maxTokens: providerModel.maxTokens,
      thinkingStrength: providerModel.thinkingStrength || "无"
    }))
  );
  const currentModelRef = primaryRef || (providerId && model.id ? `${providerId}/${model.id}` : "");
  const currentModelRefEntry = modelRefs.find((entry) => entry.ref === currentModelRef);

  return {
    model: {
      primary: currentModelRef,
      providerId,
      providerApi: String(provider.api || ""),
      providerBaseUrl: String(provider.baseUrl || ""),
      providerApiKey: maskSecret(provider.apiKey || ""),
      modelId: String(model.id || ""),
      modelName: String(model.name || model.id || ""),
      contextWindow: Number(model.contextWindow || 0) || undefined,
      maxTokens: Number(model.maxTokens || 0) || undefined,
      thinkingStrength: currentModelRefEntry?.thinkingStrength || globalThinkingDefault || "无",
      catalog: {
        providers: providerEntries,
        modelRefs
      }
    },
    channels: {
      telegram: {
        enabled: Boolean(telegram.enabled),
        botToken: maskSecret(telegram.botToken || telegram.token || ""),
        tokenFile: telegram.tokenFile || "",
        dmPolicy: telegram.dmPolicy || "pairing",
        allowFrom: toDelimitedList(telegram.allowFrom || []),
        groupPolicy: telegram.groupPolicy || "allowlist",
        groupAllowFrom: toDelimitedList(telegram.groupAllowFrom || []),
        requireMention: telegramWildcardGroup.requireMention !== false,
        streamMode: telegram.streamMode || "partial",
        chunkMode: telegram.chunkMode || "length",
        textChunkLimit: toOptionalPositiveInt(telegram.textChunkLimit),
        replyToMode: telegram.replyToMode || "off",
        linkPreview: telegram.linkPreview !== false,
        blockStreaming: telegram.blockStreaming === true,
        timeoutSeconds: toOptionalPositiveInt(telegram.timeoutSeconds),
        mediaMaxMb: toOptionalPositiveInt(telegram.mediaMaxMb),
        dmHistoryLimit: toOptionalNonNegativeInt(telegram.dmHistoryLimit),
        historyLimit: toOptionalNonNegativeInt(telegram.historyLimit),
        webhookUrl: telegram.webhookUrl || "",
        webhookSecret: maskSecret(telegram.webhookSecret || ""),
        webhookPath: telegram.webhookPath || "/telegram-webhook",
        proxy: telegram.proxy || "",
        configWrites: telegram.configWrites !== false,
        reactionLevel: telegram.reactionLevel || "minimal",
        reactionNotifications: telegram.reactionNotifications || "own",
        inlineButtons: telegramInlineButtons,
        actionSendMessage: telegramActions.sendMessage !== false,
        actionReactions: telegramActions.reactions !== false,
        actionDeleteMessage: telegramActions.deleteMessage !== false,
        actionSticker: telegramActions.sticker === true,
        networkAutoSelectFamily:
          typeof telegramNetwork.autoSelectFamily === "boolean" ? telegramNetwork.autoSelectFamily : null,
        retryAttempts: toOptionalPositiveInt(telegramRetry.attempts),
        retryMinDelayMs: toOptionalPositiveInt(telegramRetry.minDelayMs),
        retryMaxDelayMs: toOptionalPositiveInt(telegramRetry.maxDelayMs),
        retryJitter: telegramRetryJitterValue,
        commandsNative: telegramCommandsNative,
        groupsJson: toPrettyJson(telegram.groups),
        accountsJson: toPrettyJson(telegram.accounts),
        customCommandsJson: toPrettyJson(telegram.customCommands),
        draftChunkJson: toPrettyJson(telegram.draftChunk)
      },
      feishu: {
        enabled: Boolean(feishu.enabled),
        appId: feishu.appId || "",
        appSecret: maskSecret(feishu.appSecret || ""),
        domain: feishu.domain || "feishu",
        connectionMode: feishu.connectionMode || "websocket",
        dmPolicy: feishu.dmPolicy || "pairing",
        allowFrom: toDelimitedList(feishu.allowFrom || []),
        groupPolicy: feishu.groupPolicy || "allowlist",
        groupAllowFrom: toDelimitedList(feishu.groupAllowFrom || []),
        requireMention: feishu.requireMention !== false
      },
      discord: {
        enabled: Boolean(discord.enabled),
        token: maskSecret(discord.token || ""),
        dmPolicy: discordDmPolicy,
        allowFrom: toDelimitedList(discordAllowFrom),
        groupPolicy: discord.groupPolicy || "allowlist",
        allowBots: Boolean(discord.allowBots),
        requireMention: discordWildcardGuild.requireMention !== false
      },
      slack: {
        enabled: Boolean(slack.enabled),
        mode: slack.mode || "socket",
        botToken: maskSecret(slack.botToken || ""),
        appToken: maskSecret(slack.appToken || ""),
        signingSecret: maskSecret(slack.signingSecret || ""),
        dmPolicy: slackDmPolicy,
        allowFrom: toDelimitedList(slackAllowFrom),
        groupPolicy: slack.groupPolicy || "allowlist",
        allowBots: Boolean(slack.allowBots),
        requireMention: slack.requireMention !== false
      }
    }
  };
}

export { extractSettings };
</file>

<file path="src/openclaw-config/storage.js">
import fs from "node:fs/promises";
import { expandHome, nowIso, readJsonFile, writeJsonFileAtomic } from "../utils.js";

function toNonNegativeInt(value, fallback) {
  const parsed = Number.parseInt(String(value ?? ""), 10);
  if (!Number.isFinite(parsed) || parsed < 0) {
    return fallback;
  }
  return parsed;
}

function resolveExpectedOwner() {
  const rawUid = String(process.env.OPENCLAW_CONFIG_OWNER_UID ?? "").trim();
  const rawGid = String(process.env.OPENCLAW_CONFIG_OWNER_GID ?? "").trim();
  const hasUid = rawUid.length > 0;
  const hasGid = rawGid.length > 0;
  if (!hasUid && !hasGid) {
    return null;
  }
  const uid = toNonNegativeInt(rawUid, NaN);
  const gid = toNonNegativeInt(rawGid, NaN);
  if (!Number.isFinite(uid) || !Number.isFinite(gid)) {
    throw new Error("OPENCLAW_CONFIG_OWNER_UID / OPENCLAW_CONFIG_OWNER_GID 必须同时为非负整数");
  }
  return { uid, gid };
}

function isRootRuntime() {
  return typeof process.getuid === "function" && process.getuid() === 0;
}

async function ensureOpenClawConfigPermissions(configPath) {
  const realPath = expandHome(configPath);
  let stats;
  try {
    stats = await fs.stat(realPath);
  } catch (error) {
    if (error.code === "ENOENT") {
      return {
        path: realPath,
        exists: false,
        changed: false,
        ownerFixed: false,
        modeFixed: false
      };
    }
    throw error;
  }

  const expected = resolveExpectedOwner();
  const currentMode = stats.mode & 0o777;
  let modeFixed = false;
  if (currentMode !== 0o600) {
    await fs.chmod(realPath, 0o600);
    modeFixed = true;
  }

  let ownerFixed = false;
  if (isRootRuntime() && expected) {
    if (stats.uid !== expected.uid || stats.gid !== expected.gid) {
      await fs.chown(realPath, expected.uid, expected.gid);
      ownerFixed = true;
    }
  }

  return {
    path: realPath,
    exists: true,
    changed: modeFixed || ownerFixed,
    ownerFixed,
    modeFixed
  };
}

async function loadOpenClawConfig(configPath) {
  return readJsonFile(expandHome(configPath), {});
}

async function saveOpenClawConfig(configPath, content) {
  const realPath = expandHome(configPath);
  const backupPath = `${realPath}.bak.${nowIso().replaceAll(":", "-")}`;
  try {
    await fs.copyFile(realPath, backupPath);
  } catch (error) {
    if (error.code !== "ENOENT") {
      throw error;
    }
  }
  await writeJsonFileAtomic(realPath, content, 0o600);
  const permissionSync = await ensureOpenClawConfigPermissions(realPath);
  return {
    path: realPath,
    backupPath,
    permissionSync
  };
}

export { ensureOpenClawConfigPermissions, loadOpenClawConfig, saveOpenClawConfig };
</file>

<file path="src/skills-service.js">
import { callGatewayRpc } from "./gateway-client.js";
import { loadOpenClawConfig } from "./openclaw-config.js";
import { maskSecret } from "./utils.js";

const SKILLS_GATEWAY_TIMEOUT_MS = 1_000;
const SKILLS_GATEWAY_RETRIES = 6;
const SKILLS_GATEWAY_RETRY_DELAY_MS = 1_000;

function trimString(value) {
  return String(value || "").trim();
}

function normalizeSkillItem(skill = {}) {
  const updatedAt = trimString(
    skill?.updatedAt || skill?.updated_at || skill?.lastUpdatedAt || skill?.last_updated_at || skill?.mtime
  );
  return {
    key: trimString(skill?.skillKey || skill?.name),
    name: trimString(skill?.name),
    description: trimString(skill?.description),
    updatedAt,
    enabled: skill?.disabled !== true,
    eligible: skill?.eligible === true,
    blocked: skill?.blockedByAllowlist === true,
    source: trimString(skill?.source),
    bundled: skill?.bundled === true,
    missing: skill?.missing && typeof skill.missing === "object" ? skill.missing : {},
    requirements: skill?.requirements && typeof skill.requirements === "object" ? skill.requirements : {}
  };
}

function normalizeSkillListPayload(payload) {
  const workspaceDir = trimString(payload?.workspaceDir);
  const managedSkillsDir = trimString(payload?.managedSkillsDir);
  const skillsRaw = Array.isArray(payload?.skills) ? payload.skills : [];
  const skills = skillsRaw
    .map((item) => normalizeSkillItem(item))
    .filter((item) => item.key);
  const enabled = skills.filter((item) => item.enabled).length;
  return {
    workspaceDir,
    managedSkillsDir,
    total: skills.length,
    enabled,
    disabled: skills.length - enabled,
    skills
  };
}

function buildSkillMap(skills) {
  return new Map(skills.map((skill) => [skill.key, skill]));
}

function normalizeSkillConfigEntry(skillKey, rawConfig) {
  const config = rawConfig && typeof rawConfig === "object" ? rawConfig : {};
  const rawEnv = config.env && typeof config.env === "object" ? config.env : {};
  const env = Object.fromEntries(
    Object.entries(rawEnv).map(([key, value]) => [key, maskSecret(trimString(value))])
  );
  return {
    skillKey,
    enabled: typeof config.enabled === "boolean" ? config.enabled : null,
    hasApiKey: Boolean(trimString(config.apiKey)),
    apiKeyMasked: maskSecret(trimString(config.apiKey)),
    env
  };
}

async function callSkillsRpc(panelConfig, params, deps = {}) {
  const callRpc = deps.callGatewayRpc || callGatewayRpc;
  const gatewayToken = trimString(deps.gatewayToken ?? process.env.OPENCLAW_GATEWAY_TOKEN);
  return await callRpc({
    panelConfig,
    method: params.method,
    params: params.payload || {},
    timeoutMs: SKILLS_GATEWAY_TIMEOUT_MS,
    retries: SKILLS_GATEWAY_RETRIES,
    retryDelayMs: SKILLS_GATEWAY_RETRY_DELAY_MS,
    token: gatewayToken
  });
}

function ensureKnownSkill(skillsMap, skillKey) {
  if (skillsMap.has(skillKey)) {
    return;
  }
  throw new Error(`未知技能：${skillKey}`);
}

export async function listSkillsStatus({ panelConfig, deps = {} }) {
  const payload = await callSkillsRpc(
    panelConfig,
    {
      method: "skills.status",
      payload: {}
    },
    deps
  );
  return normalizeSkillListPayload(payload);
}

export async function getSkillConfig({ panelConfig, skillKey, deps = {} }) {
  const normalizedSkillKey = trimString(skillKey);
  if (!normalizedSkillKey) {
    throw new Error("skillKey 不能为空");
  }
  const loadConfig = deps.loadOpenClawConfig || loadOpenClawConfig;
  const config = await loadConfig(panelConfig?.openclaw?.config_path);
  const rawEntry = config?.skills?.entries?.[normalizedSkillKey];
  return normalizeSkillConfigEntry(normalizedSkillKey, rawEntry);
}

function normalizeEnvPatch(rawEnvPatch) {
  if (!rawEnvPatch || typeof rawEnvPatch !== "object" || Array.isArray(rawEnvPatch)) {
    return {};
  }
  return Object.fromEntries(
    Object.entries(rawEnvPatch)
      .map(([key, value]) => [trimString(key), trimString(value)])
      .filter(([key]) => Boolean(key))
  );
}

export async function prepareSkillConfigUpdate({ panelConfig, skillKey, patch = {}, deps = {} }) {
  const normalizedSkillKey = trimString(skillKey);
  if (!normalizedSkillKey) {
    throw new Error("skillKey 不能为空");
  }

  const status = await listSkillsStatus({ panelConfig, deps });
  const skillsMap = buildSkillMap(status.skills);
  ensureKnownSkill(skillsMap, normalizedSkillKey);

  const loadConfig = deps.loadOpenClawConfig || loadOpenClawConfig;
  const currentConfig = await loadConfig(panelConfig?.openclaw?.config_path);
  const nextConfig = structuredClone(currentConfig || {});
  if (!nextConfig.skills || typeof nextConfig.skills !== "object") {
    nextConfig.skills = {};
  }
  if (!nextConfig.skills.entries || typeof nextConfig.skills.entries !== "object") {
    nextConfig.skills.entries = {};
  }

  const currentEntryRaw = nextConfig.skills.entries[normalizedSkillKey];
  const previousEntry = currentEntryRaw && typeof currentEntryRaw === "object" ? structuredClone(currentEntryRaw) : {};
  const nextEntry = previousEntry && typeof previousEntry === "object" ? { ...previousEntry } : {};

  if (typeof patch.enabled === "boolean") {
    nextEntry.enabled = patch.enabled;
  }

  const clearApiKey = patch.clearApiKey === true;
  const apiKey = trimString(patch.apiKey);
  if (clearApiKey) {
    delete nextEntry.apiKey;
  } else if (apiKey) {
    nextEntry.apiKey = apiKey;
  }

  const envPatch = normalizeEnvPatch(patch.env);
  if (Object.keys(envPatch).length > 0) {
    const nextEnv = nextEntry.env && typeof nextEntry.env === "object" && !Array.isArray(nextEntry.env) ? { ...nextEntry.env } : {};
    for (const [key, value] of Object.entries(envPatch)) {
      if (!value) {
        delete nextEnv[key];
      } else {
        nextEnv[key] = value;
      }
    }
    if (Object.keys(nextEnv).length > 0) {
      nextEntry.env = nextEnv;
    } else {
      delete nextEntry.env;
    }
  }

  nextConfig.skills.entries[normalizedSkillKey] = nextEntry;
  return {
    skillKey: normalizedSkillKey,
    nextConfig,
    previousEntry,
    nextEntry
  };
}

export async function setSkillEnabled({ panelConfig, skillKey, enabled, deps = {} }) {
  const normalizedSkillKey = trimString(skillKey);
  if (!normalizedSkillKey) {
    throw new Error("skillKey 不能为空");
  }

  const status = await listSkillsStatus({ panelConfig, deps });
  const skillsMap = buildSkillMap(status.skills);
  ensureKnownSkill(skillsMap, normalizedSkillKey);

  await callSkillsRpc(
    panelConfig,
    {
      method: "skills.update",
      payload: {
        skillKey: normalizedSkillKey,
        enabled: enabled === true
      }
    },
    deps
  );

  const nextConfig = await getSkillConfig({
    panelConfig,
    skillKey: normalizedSkillKey,
    deps
  });

  return {
    skillKey: normalizedSkillKey,
    enabled: enabled === true,
    config: nextConfig
  };
}
</file>

<file path="src/chat-service.js">
import { randomUUID } from "node:crypto";
import { existsSync, readFileSync } from "node:fs";
import { mkdir, writeFile } from "node:fs/promises";
import path from "node:path";
import { callGatewayRpc, subscribeGatewayEvents } from "./gateway-client.js";
import { expandHome } from "./utils.js";

const CHAT_GATEWAY_TIMEOUT_MS = 1_000;
const CHAT_GATEWAY_RETRIES = 6;
const CHAT_GATEWAY_RETRY_DELAY_MS = 1_000;
const CHAT_ATTACHMENT_TIMEOUT_MS = 120_000;
const ATTACHMENT_PREVIEW_MAX_BYTES = 2 * 1024 * 1024;
const VISION_MIME_TYPES = new Set([
  "image/png",
  "image/jpeg",
  "image/jpg",
  "image/bmp",
  "image/webp",
  "image/gif"
]);

const MIME_EXTENSION_MAP = Object.freeze({
  "image/png": ".png",
  "image/jpeg": ".jpg",
  "image/jpg": ".jpg",
  "image/webp": ".webp",
  "image/gif": ".gif",
  "image/bmp": ".bmp",
  "application/pdf": ".pdf",
  "application/json": ".json",
  "text/plain": ".txt",
  "text/markdown": ".md"
});

function trimString(value) {
  return String(value || "").trim();
}

function toPositiveInt(value, fallback) {
  const parsed = Number(value);
  if (!Number.isFinite(parsed) || parsed <= 0) {
    return fallback;
  }
  return Math.floor(parsed);
}

function inferExtension(fileName, mimeType) {
  const ext = path.extname(String(fileName || "").trim());
  if (ext) {
    return ext;
  }
  const byMime = MIME_EXTENSION_MAP[String(mimeType || "").trim().toLowerCase()];
  if (byMime) {
    return byMime;
  }
  return "";
}

function sanitizeFileName(fileName, fallback = "file") {
  const raw = String(fileName || "").trim();
  if (!raw) {
    return fallback;
  }
  const base = path.basename(raw).replace(/[<>:"/\\|?*\u0000-\u001F]/g, "_");
  return base || fallback;
}

function normalizeBase64(input) {
  const value = String(input || "").trim();
  if (!value) {
    return "";
  }
  const maybeDataUrl = value.match(/^data:[^;]+;base64,(.+)$/i);
  return maybeDataUrl ? maybeDataUrl[1].trim() : value;
}

function resolveOutboundMediaDir(panelConfig) {
  const configPath = expandHome(String(panelConfig?.openclaw?.config_path || "~/.openclaw/openclaw.json"));
  const openclawRoot = path.dirname(configPath);
  return path.join(openclawRoot, "media", "outbound");
}

function toPosixPath(value) {
  return String(value || "").replace(/\\/g, "/");
}

function resolveGatewayMediaRoot(panelConfig) {
  const explicit = trimString(
    panelConfig?.openclaw?.gateway_media_root || process.env.OPENCLAW_GATEWAY_MEDIA_ROOT || ""
  );
  if (explicit) {
    return explicit;
  }
  const configPath = expandHome(String(panelConfig?.openclaw?.config_path || "~/.openclaw/openclaw.json"));
  return path.dirname(configPath);
}

function mapLocalPathToGatewayPath(panelConfig, absoluteLocalPath) {
  const localOpenclawRoot = path.resolve(path.dirname(expandHome(String(panelConfig?.openclaw?.config_path || "~/.openclaw/openclaw.json"))));
  const relative = path.relative(localOpenclawRoot, absoluteLocalPath);
  if (!relative || relative.startsWith("..") || path.isAbsolute(relative)) {
    return toPosixPath(absoluteLocalPath);
  }
  const gatewayRoot = toPosixPath(resolveGatewayMediaRoot(panelConfig)).replace(/\/+$/, "");
  const relativePosix = toPosixPath(relative).replace(/^\/+/, "");
  return `${gatewayRoot}/${relativePosix}`;
}

function buildMediaSendPayload(panelConfig, attachments = [], deps = {}) {
  const list = Array.isArray(attachments) ? attachments : [];
  if (list.length === 0) {
    return {
      imageAttachments: [],
      fileReferences: []
    };
  }

  const checkExists = deps.existsSync || existsSync;
  const readBuffer = deps.readFileSync || readFileSync;
  const allowedOutboundDir = path.resolve(resolveOutboundMediaDir(panelConfig));
  const imageAttachments = [];
  const fileReferences = [];

  list.forEach((item, index) => {
    if (!item || typeof item !== "object") {
      throw new Error(`附件 #${index + 1} 格式错误`);
    }

    const filePath = trimString(item.stagedPath || item.filePath);
    const fileName = sanitizeFileName(item.fileName, `file-${index + 1}`);
    const mimeType = trimString(item.mimeType).toLowerCase() || "application/octet-stream";

    if (!filePath) {
      throw new Error(`附件缺少 stagedPath：${fileName}`);
    }
    const resolvedFilePath = path.resolve(filePath);
    const normalizedAllowed = process.platform === "win32" ? allowedOutboundDir.toLowerCase() : allowedOutboundDir;
    const normalizedResolved = process.platform === "win32" ? resolvedFilePath.toLowerCase() : resolvedFilePath;
    const allowedPrefix = `${normalizedAllowed}${path.sep}`;
    if (normalizedResolved !== normalizedAllowed && !normalizedResolved.startsWith(allowedPrefix)) {
      throw new Error(`附件路径非法：${fileName}`);
    }
    if (!checkExists(resolvedFilePath)) {
      throw new Error(`附件文件不存在：${fileName}`);
    }

    const gatewayFilePath = mapLocalPathToGatewayPath(panelConfig, resolvedFilePath);
    fileReferences.push(`[media attached: ${gatewayFilePath} (${mimeType}) | ${gatewayFilePath}]`);

    if (!VISION_MIME_TYPES.has(mimeType)) {
      return;
    }
    const fileBuffer = readBuffer(resolvedFilePath);
    imageAttachments.push({
      content: fileBuffer.toString("base64"),
      mimeType,
      fileName
    });
  });

  return {
    imageAttachments,
    fileReferences
  };
}

async function callChatRpc(panelConfig, method, params, deps = {}, options = {}) {
  const callRpc = deps.callGatewayRpc || callGatewayRpc;
  const gatewayToken = trimString(deps.gatewayToken ?? process.env.OPENCLAW_GATEWAY_TOKEN);
  return await callRpc({
    panelConfig,
    method,
    params: params || {},
    expectFinal: options.expectFinal === true,
    timeoutMs: toPositiveInt(options.timeoutMs, CHAT_GATEWAY_TIMEOUT_MS),
    retries: toPositiveInt(options.retries, CHAT_GATEWAY_RETRIES),
    retryDelayMs: toPositiveInt(options.retryDelayMs, CHAT_GATEWAY_RETRY_DELAY_MS),
    token: gatewayToken
  });
}

function normalizeSessionItem(item) {
  return {
    key: trimString(item?.key),
    displayName: trimString(item?.displayName || item?.key),
    kind: trimString(item?.kind),
    updatedAt: Number(item?.updatedAt || 0) || 0,
    sessionId: trimString(item?.sessionId),
    modelProvider: trimString(item?.modelProvider),
    model: trimString(item?.model),
    contextTokens: Number(item?.contextTokens || 0) || null,
    totalTokens: Number(item?.totalTokens || 0) || null,
    abortedLastRun: item?.abortedLastRun === true
  };
}

function getCanonicalSessionPrefix(sessions) {
  const list = Array.isArray(sessions) ? sessions : [];
  const canonical = list.find((item) => trimString(item?.key).startsWith("agent:"));
  if (!canonical) {
    return "";
  }
  const parts = trimString(canonical.key).split(":");
  if (parts.length < 2) {
    return "";
  }
  return `${parts[0]}:${parts[1]}`;
}

function normalizeSessionPrefix(value) {
  const raw = trimString(value).replace(/:+$/, "");
  if (!raw) {
    return "";
  }
  if (raw.includes(":")) {
    return raw;
  }
  return `agent:${raw}`;
}

function buildSessionKey(prefix) {
  const finalPrefix = normalizeSessionPrefix(prefix) || "agent:main";
  return `${finalPrefix}:session-${Date.now()}-${randomUUID().slice(0, 8)}`;
}

function normalizeChatEventPayload(eventFrame) {
  const payload = eventFrame?.payload && typeof eventFrame.payload === "object" ? eventFrame.payload : {};
  return {
    type: "chat",
    event: "chat",
    seq: Number(eventFrame?.seq || 0) || null,
    at: Date.now(),
    runId: trimString(payload?.runId),
    sessionKey: trimString(payload?.sessionKey),
    state: trimString(payload?.state),
    stopReason: trimString(payload?.stopReason),
    errorMessage: trimString(payload?.errorMessage),
    message: payload?.message && typeof payload.message === "object" ? payload.message : payload?.message ?? null
  };
}

function normalizeAgentEventPayload(eventFrame) {
  const payload = eventFrame?.payload && typeof eventFrame.payload === "object" ? eventFrame.payload : {};
  const data = payload?.data && typeof payload.data === "object" ? payload.data : {};
  return {
    type: "agent",
    event: "agent",
    seq: Number(eventFrame?.seq || 0) || null,
    at: Date.now(),
    runId: trimString(payload?.runId),
    sessionKey: trimString(payload?.sessionKey),
    stream: trimString(payload?.stream),
    phase: trimString(data?.phase),
    data
  };
}

function isTerminalChatState(state) {
  return state === "final" || state === "error" || state === "aborted";
}

export async function listChatSessions({ panelConfig, deps = {} }) {
  const payload = await callChatRpc(panelConfig, "sessions.list", {}, deps);
  const sessions = Array.isArray(payload?.sessions) ? payload.sessions.map((item) => normalizeSessionItem(item)) : [];
  return {
    total: Number(payload?.count || sessions.length) || sessions.length,
    sessions
  };
}

export async function getChatHistory({
  panelConfig,
  sessionKey,
  limit = 200,
  deps = {}
}) {
  const normalizedSessionKey = trimString(sessionKey);
  if (!normalizedSessionKey) {
    throw new Error("sessionKey 不能为空");
  }

  const payload = await callChatRpc(
    panelConfig,
    "chat.history",
    {
      sessionKey: normalizedSessionKey,
      limit: toPositiveInt(limit, 200)
    },
    deps
  );

  return {
    sessionKey: normalizedSessionKey,
    sessionId: trimString(payload?.sessionId),
    thinkingLevel: trimString(payload?.thinkingLevel),
    verboseLevel: trimString(payload?.verboseLevel),
    messages: Array.isArray(payload?.messages) ? payload.messages : []
  };
}

export async function sendChatMessage({
  panelConfig,
  sessionKey,
  message,
  thinking = "",
  attachments = [],
  idempotencyKey = "",
  timeoutMs,
  deps = {}
}) {
  const normalizedSessionKey = trimString(sessionKey);
  const normalizedMessage = trimString(message);
  if (!normalizedSessionKey) {
    throw new Error("sessionKey 不能为空");
  }
  if (!normalizedMessage && (!Array.isArray(attachments) || attachments.length === 0)) {
    throw new Error("message 或 attachments 至少填一个");
  }

  const finalIdempotencyKey = trimString(idempotencyKey) || randomUUID();
  const { imageAttachments, fileReferences } = buildMediaSendPayload(panelConfig, attachments, deps);
  const refs = fileReferences.join("\n");
  const finalMessage = refs ? (normalizedMessage ? `${normalizedMessage}\n\n${refs}` : refs) : normalizedMessage;
  const resolvedTimeout = toPositiveInt(timeoutMs, imageAttachments.length > 0 ? CHAT_ATTACHMENT_TIMEOUT_MS : CHAT_GATEWAY_TIMEOUT_MS);

  const payload = await callChatRpc(
    panelConfig,
    "chat.send",
    {
      sessionKey: normalizedSessionKey,
      message: finalMessage,
      thinking: trimString(thinking),
      attachments: imageAttachments,
      idempotencyKey: finalIdempotencyKey
    },
    deps,
    {
      timeoutMs: resolvedTimeout
    }
  );

  return {
    sessionKey: normalizedSessionKey,
    runId: trimString(payload?.runId),
    status: trimString(payload?.status),
    idempotencyKey: finalIdempotencyKey
  };
}

export async function stageChatAttachment({
  panelConfig,
  fileName,
  mimeType = "application/octet-stream",
  base64,
  deps = {}
}) {
  const normalizedBase64 = normalizeBase64(base64);
  if (!normalizedBase64) {
    throw new Error("base64 不能为空");
  }

  let buffer;
  try {
    buffer = Buffer.from(normalizedBase64, "base64");
  } catch {
    throw new Error("base64 格式无效");
  }
  if (!buffer || buffer.length === 0) {
    throw new Error("附件内容为空");
  }

  const safeName = sanitizeFileName(fileName);
  const normalizedMimeType = trimString(mimeType).toLowerCase() || "application/octet-stream";
  const ext = inferExtension(safeName, normalizedMimeType);
  const id = randomUUID();
  const outboundDir = resolveOutboundMediaDir(panelConfig);
  const stagedPath = path.join(outboundDir, `${id}${ext}`);

  const makeDir = deps.mkdir || mkdir;
  const write = deps.writeFile || writeFile;
  await makeDir(outboundDir, { recursive: true });
  await write(stagedPath, buffer, { mode: 0o644 });

  const preview = normalizedMimeType.startsWith("image/") && buffer.length <= ATTACHMENT_PREVIEW_MAX_BYTES
    ? `data:${normalizedMimeType};base64,${normalizedBase64}`
    : null;

  return {
    id,
    fileName: safeName,
    mimeType: normalizedMimeType,
    fileSize: buffer.length,
    stagedPath,
    preview
  };
}

export async function createChatSession({
  panelConfig,
  keyPrefix = "",
  deps = {}
}) {
  let resolvedPrefix = normalizeSessionPrefix(keyPrefix);
  if (!resolvedPrefix) {
    try {
      const listed = await listChatSessions({ panelConfig, deps });
      resolvedPrefix = getCanonicalSessionPrefix(listed?.sessions);
    } catch {
      resolvedPrefix = "";
    }
  }
  const sessionKey = buildSessionKey(resolvedPrefix || "agent:main");
  const result = await resetChatSession({
    panelConfig,
    sessionKey,
    reason: "new",
    deps
  });
  return {
    key: trimString(result?.key || sessionKey),
    entry: result?.entry && typeof result.entry === "object" ? result.entry : {}
  };
}

export async function abortChatRun({
  panelConfig,
  sessionKey,
  runId = "",
  deps = {}
}) {
  const normalizedSessionKey = trimString(sessionKey);
  if (!normalizedSessionKey) {
    throw new Error("sessionKey 不能为空");
  }

  const payload = await callChatRpc(
    panelConfig,
    "chat.abort",
    {
      sessionKey: normalizedSessionKey,
      ...(trimString(runId) ? { runId: trimString(runId) } : {})
    },
    deps
  );

  return {
    sessionKey: normalizedSessionKey,
    aborted: payload?.aborted === true,
    runIds: Array.isArray(payload?.runIds) ? payload.runIds : []
  };
}

export async function resetChatSession({
  panelConfig,
  sessionKey,
  reason = "new",
  deps = {}
}) {
  const normalizedSessionKey = trimString(sessionKey);
  if (!normalizedSessionKey) {
    throw new Error("sessionKey 不能为空");
  }
  const normalizedReason = reason === "reset" ? "reset" : "new";

  const payload = await callChatRpc(
    panelConfig,
    "sessions.reset",
    {
      key: normalizedSessionKey,
      reason: normalizedReason
    },
    deps
  );

  return {
    key: trimString(payload?.key || normalizedSessionKey),
    entry: payload?.entry && typeof payload.entry === "object" ? payload.entry : {}
  };
}

export function createChatEventSubscription({
  panelConfig,
  sessionKey,
  includeAgent = true,
  deps = {},
  onEvent,
  onError,
  onClose
}) {
  const subscribeEvents = deps.subscribeGatewayEvents || subscribeGatewayEvents;
  const gatewayToken = trimString(deps.gatewayToken ?? process.env.OPENCLAW_GATEWAY_TOKEN);
  const normalizedSessionKey = trimString(sessionKey);
  if (!normalizedSessionKey) {
    throw new Error("sessionKey 不能为空");
  }

  return subscribeEvents({
    panelConfig,
    token: gatewayToken,
    onEvent: (eventFrame) => {
      const eventName = trimString(eventFrame?.event);
      if (!eventName) {
        return;
      }

      if (eventName === "chat") {
        const normalized = normalizeChatEventPayload(eventFrame);
        if (normalized.sessionKey !== normalizedSessionKey) {
          return;
        }
        onEvent?.(normalized);
        if (isTerminalChatState(normalized.state)) {
          onEvent?.({
            type: "terminal",
            event: "terminal",
            at: Date.now(),
            runId: normalized.runId,
            sessionKey: normalized.sessionKey,
            state: normalized.state
          });
        }
        return;
      }

      if (includeAgent && eventName === "agent") {
        const normalized = normalizeAgentEventPayload(eventFrame);
        if (normalized.sessionKey !== normalizedSessionKey) {
          return;
        }
        onEvent?.(normalized);
      }
    },
    onError,
    onClose
  });
}
</file>

<file path="deploy/install.sh">
#!/usr/bin/env bash
set -euo pipefail

APP_DIR="/opt/openclaw-panel"
CONFIG_DIR="/etc/openclaw-panel"
SERVICE_FILE="/etc/systemd/system/openclaw-panel.service"

if ! command -v node >/dev/null 2>&1; then
  echo "node 未安装，请先安装 Node.js 22+"
  exit 1
fi

mkdir -p "$APP_DIR"
mkdir -p "$CONFIG_DIR"

cp -r ./* "$APP_DIR"/
cd "$APP_DIR"
npm install --omit=dev

if [ ! -f "$CONFIG_DIR/panel.config.json" ]; then
  mkdir -p "$CONFIG_DIR"
  cat > "$CONFIG_DIR/panel.config.json" <<EOF
{
  "panel": {
    "listen_host": "127.0.0.1",
    "listen_port": 18080,
    "container_name": "openclaw-panel",
    "image_repo": "ghcr.io/bianshumeng/openclaw-panel"
  },
  "reverse_proxy": {
    "enabled": false,
    "public_scheme": "http",
    "public_host": "",
    "panel_public_port": 18080,
    "gateway_public_port": 18789,
    "panel_public_base_url": "",
    "webhook_public_base_url": ""
  },
  "openclaw": {
    "config_path": "~/.openclaw/openclaw.json",
    "service_name": "openclaw-gateway",
    "container_name": "openclaw-gateway",
    "image_repo": "ghcr.io/bianshumeng/openclaw-mymy",
    "gateway_port": 18789,
    "gateway_ws_url": ""
  },
  "update": {
    "github_token": "",
    "bot_release_repo": "openclaw/openclaw",
    "panel_release_repo": "Bianshumeng/openclaw-panel-public",
    "panel_service_name": "openclaw-panel",
    "panel_app_dir": "/opt/openclaw-panel"
  },
  "log": {
    "source": "journal",
    "file_path": "~/.openclaw/logs/gateway.log"
  }
}
EOF
  chmod 600 "$CONFIG_DIR/panel.config.json"
fi

cp "$APP_DIR/deploy/openclaw-panel.service" "$SERVICE_FILE"

systemctl daemon-reload
systemctl enable openclaw-panel
systemctl restart openclaw-panel
systemctl status openclaw-panel --no-pager -n 20
</file>

<file path="deploy/panel.config.docker.json">
{
  "panel": {
    "listen_host": "0.0.0.0",
    "listen_port": 18080,
    "container_name": "openclaw-panel",
    "image_repo": "ghcr.io/bianshumeng/openclaw-panel"
  },
  "runtime": {
    "mode": "docker"
  },
  "reverse_proxy": {
    "enabled": false,
    "public_scheme": "http",
    "public_host": "",
    "panel_public_port": 18080,
    "gateway_public_port": 18789,
    "panel_public_base_url": "",
    "webhook_public_base_url": ""
  },
  "openclaw": {
    "config_path": "/data/openclaw/openclaw.json",
    "service_name": "openclaw-gateway",
    "container_name": "openclaw-gateway",
    "image_repo": "ghcr.io/bianshumeng/openclaw-mymy",
    "gateway_port": 18789,
    "gateway_ws_url": "",
    "gateway_media_root": "/home/node/.openclaw"
  },
  "docker": {
    "enabled": true
  },
  "update": {
    "github_token": ""
  },
  "log": {
    "source": "docker",
    "file_path": "/data/openclaw/logs/gateway.log"
  }
}
</file>

<file path="public/js/pages/model-dashboard-page.js">
import {
  AICODECAT_PROVIDER,
  DASHBOARD_CONTEXT_KEY,
  DEFAULT_MODEL_OPTIONS,
  MODEL_PROFILE_BY_FAMILY,
  MODEL_TEMPLATE_MAP,
  api,
  buildDefaultModelEntry,
  buildModelPayload,
  createDashboardStatusTag,
  dashboardSummaryState,
  formatLocalTime,
  getDashboardContextTokens,
  getInputValue,
  modelEditorState,
  modelFamilyById,
  normalizeModelDraft,
  parseModelRef,
  setInput,
  setMessage,
  setStackListEmpty,
  setText,
  toNonNegativeInt
} from "../core/panel-core.js";
import { resolveAicodecatBaseUrl, resolveProviderId } from "../../config-generator.js";

function buildModelEntryFromProvider(providerEntry, providerModel) {
  return {
    ref: `${providerEntry.id}/${providerModel.id}`,
    providerId: providerEntry.id,
    providerApi: providerEntry.api,
    providerBaseUrl: providerEntry.baseUrl,
    modelId: providerModel.id,
    modelName: providerModel.name || providerModel.id,
    contextWindow: Number(providerModel.contextWindow || 0) || undefined,
    maxTokens: Number(providerModel.maxTokens || 0) || undefined,
    thinkingStrength: String(providerModel?.thinkingStrength || "").trim() || "无"
  };
}

function collectCatalogModelEntries(modelSettings) {
  const providers = Array.isArray(modelSettings?.catalog?.providers) ? modelSettings.catalog.providers : [];
  const entries = [];
  providers.forEach((providerEntry) => {
    const models = Array.isArray(providerEntry?.models) ? providerEntry.models : [];
    models.forEach((providerModel) => {
      entries.push(buildModelEntryFromProvider(providerEntry, providerModel));
    });
  });
  return entries;
}

function findModelEntryByRef(modelSettings, modelRef) {
  const targetRef = String(modelRef || "").trim();
  if (!targetRef) {
    return null;
  }

  const matched = collectCatalogModelEntries(modelSettings).find((entry) => entry.ref === targetRef);
  if (matched) {
    return matched;
  }

  if (String(modelSettings?.primary || "").trim() === targetRef) {
    return {
      ref: targetRef,
      providerId: modelSettings?.providerId,
      providerApi: modelSettings?.providerApi,
      providerBaseUrl: modelSettings?.providerBaseUrl,
      modelId: modelSettings?.modelId,
      modelName: modelSettings?.modelName || modelSettings?.modelId,
      contextWindow: Number(modelSettings?.contextWindow || 0) || undefined,
      maxTokens: Number(modelSettings?.maxTokens || 0) || undefined,
      thinkingStrength: String(modelSettings?.thinkingStrength || "").trim() || "无"
    };
  }

  return null;
}

function confirmModelSwitchRisk(modelSettings, modelEntry) {
  const currentModelContext = Number(modelSettings?.contextWindow || 0) || undefined;
  const targetContext = Number(modelEntry?.contextWindow || 0) || undefined;
  const currentContextTokens = getDashboardContextTokens();

  if (targetContext && currentContextTokens !== null && currentContextTokens > targetContext) {
    return window.confirm(
      `当前会话上下文约 ${currentContextTokens.toLocaleString()}，目标模型上限为 ${targetContext.toLocaleString()}。\n切换后可能因上下文超限报错，确认继续切换吗？`
    );
  }

  if (targetContext && currentContextTokens === null && currentModelContext && currentModelContext > targetContext) {
    return window.confirm(
      `目标模型上下文上限更小（${targetContext.toLocaleString()}），但你还没填写“当前会话上下文”。\n如果当前会话已超过目标上限，切换后会报错。确认继续切换吗？`
    );
  }

  return true;
}

function resolveProviderSavePrimaryRef(targetPrimaryRef, toggleInputId) {
  const targetRef = String(targetPrimaryRef || "").trim();
  const currentPrimary = String(
    modelEditorState.currentModelSettings?.primary || modelEditorState.currentModelPayload?.primary || ""
  ).trim();
  const shouldSwitchPrimary = Boolean(getInputValue(toggleInputId));
  if (shouldSwitchPrimary) {
    return targetRef || currentPrimary;
  }
  return currentPrimary || targetRef;
}

async function switchDefaultModelByEntry(modelSettings, modelEntry, successPrefix = "已切换默认模型到") {
  if (!modelEntry?.ref || !modelEntry?.modelId) {
    throw new Error("目标模型无效，请重新选择");
  }
  if (!confirmModelSwitchRisk(modelSettings, modelEntry)) {
    return;
  }

  const payload = buildModelPayload({
    primary: modelEntry.ref,
    providerId: modelEntry.providerId,
    providerApi: modelEntry.providerApi,
    providerBaseUrl: modelEntry.providerBaseUrl,
    providerApiKey: "",
    modelId: modelEntry.modelId,
    modelName: modelEntry.modelName || modelEntry.modelId,
    contextWindow: modelEntry.contextWindow || 200000,
    maxTokens: modelEntry.maxTokens || 8192,
    providerModels: []
  });

  await saveModelSettings(payload, `${successPrefix} ${modelEntry.modelId}`);
}

function renderDashboardQuickSwitchHint(modelEntry) {
  if (!modelEntry) {
    setText("dashboard_quick_switch_hint", "请选择目标模型后再切换。");
    return;
  }
  const parsedRef = parseModelRef(modelEntry.ref);
  const modelId = String(modelEntry?.modelId || parsedRef.modelId || modelEntry?.modelName || "-").trim() || "-";
  const providerId = String(modelEntry?.providerId || parsedRef.providerId || "-").trim() || "-";
  setText(
    "dashboard_quick_switch_hint",
    `将切换到：${modelId}（${providerId}）`
  );
}

function fillDashboardQuickSwitch(modelSettings) {
  const select = document.querySelector("#dashboard_quick_model_ref");
  if (!(select instanceof HTMLSelectElement)) {
    return;
  }

  const entries = [];
  const seen = new Set();
  modelEditorState.defaultModelRefs.forEach((entry) => {
    const ref = String(entry?.ref || "").trim();
    if (!ref || seen.has(ref)) {
      return;
    }
    const fullEntry = findModelEntryByRef(modelSettings, ref) || entry;
    entries.push(fullEntry);
    seen.add(ref);
  });

  const currentPrimary = String(modelSettings?.primary || "").trim();
  if (entries.length === 0 && currentPrimary) {
    const fallbackEntry = findModelEntryByRef(modelSettings, currentPrimary);
    if (fallbackEntry) {
      entries.push(fallbackEntry);
    }
  }

  select.innerHTML = "";
  entries.forEach((entry) => {
    const option = document.createElement("option");
    option.value = entry.ref;
    const parsedRef = parseModelRef(entry.ref);
    const modelId = String(entry?.modelId || parsedRef.modelId || entry?.modelName || entry.ref || "").trim();
    const providerId = String(entry?.providerId || parsedRef.providerId || "-").trim() || "-";
    option.textContent = `${modelId || "-"}（${providerId}）`;
    select.appendChild(option);
  });

  if (entries.some((entry) => entry.ref === currentPrimary)) {
    select.value = currentPrimary;
  } else if (entries.length > 0) {
    select.selectedIndex = 0;
  }

  const selectedEntry = entries.find((entry) => entry.ref === select.value) || entries[0] || null;
  renderDashboardQuickSwitchHint(selectedEntry);
}

function resolveModelFamilyKey(modelEntry = {}) {
  const modelId = String(modelEntry?.modelId || "").trim().toLowerCase();
  const modelName = String(modelEntry?.modelName || "").trim().toLowerCase();
  const source = `${modelId} ${modelName}`.trim();
  if (source.startsWith("claude") || source.includes(" claude")) {
    return "claude";
  }
  if (source.startsWith("gemini") || source.includes(" gemini")) {
    return "gemini";
  }
  if (source.startsWith("gpt") || source.includes(" gpt")) {
    return "gpt";
  }
  return "other";
}

function setModelAddWorkspaceVisible(visible) {
  const workspace = document.querySelector("#model_add_workspace");
  const toggle = document.querySelector("#model_add_toggle");
  if (!workspace || !toggle) {
    return;
  }

  const nextVisible = Boolean(visible);
  workspace.classList.toggle("is-hidden", !nextVisible);
  workspace.setAttribute("aria-hidden", nextVisible ? "false" : "true");
  toggle.setAttribute("aria-expanded", nextVisible ? "true" : "false");
  toggle.classList.toggle("is-active", nextVisible);
  toggle.title = nextVisible ? "关闭添加模型面板" : "添加模型";
  const symbol = toggle.querySelector("span");
  if (symbol) {
    symbol.textContent = nextVisible ? "×" : "+";
  }
}

const modelMutationState = {
  pending: false,
  providerEditId: "",
  modelEditProviderId: "",
  modelEditId: "",
  dialogBound: false
};

const modelRawConfigState = {
  bound: false,
  pending: false,
  lastSyncMtimeMs: null
};

function getShoelaceDialog(id) {
  const dialog = document.querySelector(`#${id}`);
  if (!dialog || typeof dialog.show !== "function" || typeof dialog.hide !== "function") {
    return null;
  }
  return dialog;
}

function openShoelaceDialog(id) {
  const dialog = getShoelaceDialog(id);
  if (!dialog) {
    return;
  }
  dialog.show();
}

function closeShoelaceDialog(id) {
  const dialog = getShoelaceDialog(id);
  if (!dialog) {
    return;
  }
  dialog.hide();
}

function parseOptionalPositiveIntInput(rawValue, label) {
  const text = String(rawValue || "").trim();
  if (!text) {
    return undefined;
  }
  const parsed = Number(text);
  if (!Number.isFinite(parsed) || parsed <= 0) {
    throw new Error(`${label} 必须是正整数`);
  }
  return Math.floor(parsed);
}

async function runModelMutation(task) {
  if (modelMutationState.pending) {
    setMessage("模型配置正在写入，请稍等片刻再操作", "info");
    return;
  }
  modelMutationState.pending = true;
  try {
    await task();
  } finally {
    modelMutationState.pending = false;
  }
}

function setModelRawConfigStatus(message, type = "info") {
  const statusEl = document.querySelector("#model_raw_config_status");
  if (!statusEl) {
    return;
  }
  statusEl.textContent = String(message || "").trim();
  statusEl.classList.toggle("is-fail", type === "error");
  statusEl.classList.toggle("is-done", type === "ok");
}

function setModelAddSaveStatus(statusId, message, type = "info") {
  const statusEl = document.querySelector(`#${statusId}`);
  if (!statusEl) {
    return;
  }
  statusEl.textContent = String(message || "").trim();
  statusEl.classList.toggle("is-working", type === "working");
  statusEl.classList.toggle("is-done", type === "ok");
  statusEl.classList.toggle("is-fail", type === "error");
}

function setModelRawConfigBusy(busy) {
  const isBusy = Boolean(busy);
  document.querySelector("#model_raw_config_reload")?.toggleAttribute("disabled", isBusy);
  document.querySelector("#model_raw_config_save")?.toggleAttribute("disabled", isBusy);
}

function applyModelRawConfigPayload(payload = {}) {
  const editor = document.querySelector("#model_raw_config_editor");
  if (!(editor instanceof HTMLTextAreaElement)) {
    return;
  }
  editor.value = String(payload.rawText || "");
  modelRawConfigState.lastSyncMtimeMs = Number.isFinite(Number(payload.mtimeMs)) ? Number(payload.mtimeMs) : null;
  setText("model_raw_config_mtime", payload.mtimeMs ? formatLocalTime(payload.mtimeMs) : "-");
  setText("model_raw_config_size", Number.isFinite(payload.size) ? `${payload.size} bytes` : "-");
}

async function loadModelRawConfig({ silent = false } = {}) {
  const editor = document.querySelector("#model_raw_config_editor");
  if (!(editor instanceof HTMLTextAreaElement)) {
    return;
  }
  if (modelRawConfigState.pending) {
    return;
  }

  modelRawConfigState.pending = true;
  setModelRawConfigBusy(true);
  setModelRawConfigStatus("正在读取真实配置文件...", "info");
  try {
    const result = await api("/api/openclaw-config/raw");
    applyModelRawConfigPayload(result);
    if (result.exists === false) {
      setModelRawConfigStatus("配置文件当前不存在，你可以粘贴 JSON 后直接保存创建。", "info");
    } else {
      setModelRawConfigStatus("已与真实配置文件同步。", "ok");
    }
    if (!silent && result.path) {
      setMessage(`已读取真实配置文件：${result.path}`, "ok");
    }
  } catch (error) {
    setModelRawConfigStatus(`读取失败：${error.message || String(error)}`, "error");
    if (!silent) {
      setMessage(error.message || String(error), "error");
    }
  } finally {
    modelRawConfigState.pending = false;
    setModelRawConfigBusy(false);
  }
}

async function saveModelRawConfig() {
  const editor = document.querySelector("#model_raw_config_editor");
  if (!(editor instanceof HTMLTextAreaElement)) {
    return;
  }
  if (modelRawConfigState.pending) {
    setMessage("配置文件正在处理，请稍后重试", "info");
    return;
  }

  const rawText = String(editor.value || "").trim();
  if (!rawText) {
    throw new Error("配置 JSON 不能为空");
  }

  modelRawConfigState.pending = true;
  setModelRawConfigBusy(true);
  setModelRawConfigStatus("正在写入真实配置文件...", "info");
  try {
    const payload = {
      rawText
    };
    if (Number.isFinite(modelRawConfigState.lastSyncMtimeMs) && modelRawConfigState.lastSyncMtimeMs > 0) {
      payload.expectedMtimeMs = modelRawConfigState.lastSyncMtimeMs;
    }
    const result = await api("/api/openclaw-config/raw", {
      method: "PUT",
      body: JSON.stringify(payload)
    });
    applyModelRawConfigPayload(result);
    setModelRawConfigStatus("保存成功，已同步真实配置文件。", "ok");
    setMessage(`配置文件写入成功：${result.path}`, "ok");
    const modelSettings = result?.settings?.model;
    if (modelSettings && typeof modelSettings === "object") {
      renderDashboardModelCards(modelSettings);
      fillModelEditor(modelSettings);
    }
  } finally {
    modelRawConfigState.pending = false;
    setModelRawConfigBusy(false);
  }
}

function bindModelRawConfigEditor() {
  if (modelRawConfigState.bound) {
    return;
  }

  const editor = document.querySelector("#model_raw_config_editor");
  if (!(editor instanceof HTMLTextAreaElement)) {
    return;
  }

  modelRawConfigState.bound = true;
  document.querySelector("#model_raw_config_reload")?.addEventListener("click", () => {
    loadModelRawConfig({ silent: false }).catch((error) => {
      setMessage(error.message || String(error), "error");
    });
  });
  document.querySelector("#model_raw_config_save")?.addEventListener("click", () => {
    saveModelRawConfig().catch((error) => {
      setModelRawConfigStatus(`保存失败：${error.message || String(error)}`, "error");
      setMessage(error.message || String(error), "error");
    });
  });
}

async function refreshModelSettingsFromServer(successMessage = "") {
  const result = await api("/api/settings");
  const modelSettings = result?.settings?.model;
  if (!modelSettings || typeof modelSettings !== "object") {
    throw new Error("模型配置刷新失败，请手动刷新页面");
  }
  renderDashboardModelCards(modelSettings);
  fillModelEditor(modelSettings);
  if (successMessage) {
    setMessage(successMessage, "ok");
  }
}

function openProviderEditDialog(providerEntry = {}) {
  const providerId = String(providerEntry?.id || "").trim();
  if (!providerId) {
    setMessage("供应商数据无效，无法编辑", "error");
    return;
  }
  modelMutationState.providerEditId = providerId;
  setInput("model_provider_edit_id", providerId);
  setInput("model_provider_edit_api", String(providerEntry?.api || "").trim());
  setInput("model_provider_edit_baseurl", String(providerEntry?.baseUrl || "").trim());
  setInput("model_provider_edit_apikey", "");
  openShoelaceDialog("model_provider_edit_dialog");
}

async function submitProviderEditDialog() {
  const providerId = String(modelMutationState.providerEditId || "").trim();
  if (!providerId) {
    throw new Error("未找到待编辑的供应商");
  }

  const nextProviderId = String(getInputValue("model_provider_edit_id") || "").trim();
  const nextApi = String(getInputValue("model_provider_edit_api") || "").trim();
  const nextBaseUrl = String(getInputValue("model_provider_edit_baseurl") || "").trim();
  const nextApiKey = String(getInputValue("model_provider_edit_apikey") || "").trim();
  if (!nextProviderId || !nextApi || !nextBaseUrl) {
    throw new Error("请完整填写供应商名称、API 模式和 API 地址");
  }

  const payload = {
    nextProviderId,
    api: nextApi,
    baseUrl: nextBaseUrl
  };
  if (nextApiKey) {
    payload.apiKey = nextApiKey;
  }

  await api(`/api/models/providers/${encodeURIComponent(providerId)}`, {
    method: "PUT",
    body: JSON.stringify(payload)
  });

  closeShoelaceDialog("model_provider_edit_dialog");
  modelMutationState.providerEditId = "";
  setInput("model_provider_edit_apikey", "");
  const actionText =
    nextProviderId === providerId
      ? `供应商 ${nextProviderId} 已更新`
      : `供应商已从 ${providerId} 更新为 ${nextProviderId}`;
  await refreshModelSettingsFromServer(actionText);
}

function openModelEditDialog(providerEntry = {}, modelEntry = {}) {
  const providerId = String(providerEntry?.id || modelEntry?.providerId || "").trim();
  const modelId = String(modelEntry?.modelId || modelEntry?.id || "").trim();
  if (!providerId || !modelId) {
    setMessage("模型数据无效，无法编辑", "error");
    return;
  }

  modelMutationState.modelEditProviderId = providerId;
  modelMutationState.modelEditId = modelId;
  setInput("model_item_edit_provider", providerId);
  setInput("model_item_edit_id", modelId);
  setInput("model_item_edit_name", String(modelEntry?.modelName || modelEntry?.name || modelId).trim() || modelId);
  setInput("model_item_edit_context_window", modelEntry?.contextWindow || "");
  setInput("model_item_edit_max_tokens", modelEntry?.maxTokens || "");
  openShoelaceDialog("model_item_edit_dialog");
}

async function submitModelEditDialog() {
  const providerId = String(modelMutationState.modelEditProviderId || "").trim();
  const sourceModelId = String(modelMutationState.modelEditId || "").trim();
  if (!providerId || !sourceModelId) {
    throw new Error("未找到待编辑的模型");
  }

  const nextModelId = String(getInputValue("model_item_edit_id") || "").trim();
  const nextModelName = String(getInputValue("model_item_edit_name") || "").trim();
  if (!nextModelId) {
    throw new Error("模型 ID 不能为空");
  }

  const contextWindow = parseOptionalPositiveIntInput(
    getInputValue("model_item_edit_context_window"),
    "模型最大上下文"
  );
  const maxTokens = parseOptionalPositiveIntInput(getInputValue("model_item_edit_max_tokens"), "模型最大输出");

  const payload = {
    nextModelId,
    name: nextModelName || nextModelId
  };
  if (contextWindow !== undefined) {
    payload.contextWindow = contextWindow;
  }
  if (maxTokens !== undefined) {
    payload.maxTokens = maxTokens;
  }

  await api(`/api/models/providers/${encodeURIComponent(providerId)}/models/${encodeURIComponent(sourceModelId)}`, {
    method: "PUT",
    body: JSON.stringify(payload)
  });

  closeShoelaceDialog("model_item_edit_dialog");
  modelMutationState.modelEditProviderId = "";
  modelMutationState.modelEditId = "";
  const actionText =
    nextModelId === sourceModelId
      ? `模型 ${providerId}/${nextModelId} 已更新`
      : `模型已从 ${providerId}/${sourceModelId} 更新为 ${providerId}/${nextModelId}`;
  await refreshModelSettingsFromServer(actionText);
}

async function deleteProviderWithConfirm(providerEntry = {}) {
  const providerId = String(providerEntry?.id || "").trim();
  if (!providerId) {
    throw new Error("供应商标识无效");
  }
  const models = Array.isArray(providerEntry?.models) ? providerEntry.models : [];
  const confirmed = window.confirm(`确认删除供应商 ${providerId} 吗？\n将连带删除其下 ${models.length} 个模型。`);
  if (!confirmed) {
    return;
  }

  await api(`/api/models/providers/${encodeURIComponent(providerId)}`, {
    method: "DELETE"
  });
  await refreshModelSettingsFromServer(`供应商 ${providerId} 已删除`);
}

async function deleteModelWithConfirm(providerEntry = {}, modelEntry = {}) {
  const providerId = String(providerEntry?.id || modelEntry?.providerId || "").trim();
  const modelId = String(modelEntry?.modelId || modelEntry?.id || "").trim();
  if (!providerId || !modelId) {
    throw new Error("模型标识无效");
  }
  const confirmed = window.confirm(`确认删除模型 ${providerId}/${modelId} 吗？\n删除后将无法自动恢复。`);
  if (!confirmed) {
    return;
  }

  await api(`/api/models/providers/${encodeURIComponent(providerId)}/models/${encodeURIComponent(modelId)}`, {
    method: "DELETE"
  });
  await refreshModelSettingsFromServer(`模型 ${providerId}/${modelId} 已删除`);
}

function getProviderEntries(modelSettings) {
  const providers = Array.isArray(modelSettings?.catalog?.providers) ? modelSettings.catalog.providers : [];
  if (providers.length > 0) {
    return providers;
  }

  const fallbackModelId = String(modelSettings?.modelId || "").trim();
  if (!fallbackModelId) {
    return [];
  }

  return [
    {
      id: String(modelSettings?.providerId || "").trim(),
      api: String(modelSettings?.providerApi || "").trim(),
      baseUrl: String(modelSettings?.providerBaseUrl || "").trim(),
      models: [
        {
          id: fallbackModelId,
          name: String(modelSettings?.modelName || fallbackModelId).trim() || fallbackModelId,
          contextWindow: Number(modelSettings?.contextWindow || 0) || undefined,
          maxTokens: Number(modelSettings?.maxTokens || 0) || undefined,
          thinkingStrength: String(modelSettings?.thinkingStrength || "").trim() || "无"
        }
      ]
    }
  ];
}

function setModelProviderMode(mode) {
  const rawMode = String(mode || "").trim();
  const normalizedMode = rawMode === "custom" || rawMode === "existing" ? rawMode : "template";
  modelEditorState.providerMode = normalizedMode;

  const hintByMode = {
    template: "直接添加模型：选择或自定义模型 ID，每次只写入一个模型。",
    custom: "新增供应商并添加模型：创建供应商并只写入一个模型。",
    existing: "基于已有供应商添加：不会新建供应商，每次只写入一个模型。"
  };
  const hintText = hintByMode[normalizedMode] || hintByMode.template;
  setText("model_provider_mode_hint", hintText);

  document.querySelectorAll("[data-model-provider-mode]").forEach((button) => {
    const buttonMode = String(button.getAttribute("data-model-provider-mode") || "").trim();
    const isActive = buttonMode === normalizedMode;
    button.classList.toggle("is-active", isActive);
    button.setAttribute("aria-pressed", isActive ? "true" : "false");
  });

  document.querySelectorAll("[data-model-provider-mode-panel]").forEach((section) => {
    const panelMode = String(section.getAttribute("data-model-provider-mode-panel") || "").trim();
    section.classList.toggle("is-hidden", panelMode !== normalizedMode);
  });
}

function renderModelSummary(entry, primary) {
  const fallback = entry || {};
  setInput("model_current_primary", primary || "");
  setInput("model_current_provider", fallback.providerId || "");
  setInput("model_current_api", fallback.providerApi || "");
  setInput("model_current_baseurl", fallback.providerBaseUrl || "");
  setInput("model_current_id", fallback.modelId || "");
  setInput("model_current_name", fallback.modelName || fallback.modelId || "");
  setInput("model_current_context_window", fallback.contextWindow || "");
  setInput("model_current_max_tokens", fallback.maxTokens || "");
}

function renderDashboardModelCards(modelSettings) {
  const container = document.querySelector("#model_provider_cards");
  if (!container) {
    return;
  }

  const providers = getProviderEntries(modelSettings);
  const primaryRef = String(modelSettings?.primary || "").trim();
  const currentRefParts = parseModelRef(primaryRef);
  container.innerHTML = "";

  if (providers.length === 0) {
    const emptyCard = document.createElement("article");
    emptyCard.className = "model-provider-group model-provider-group-empty";

    const emptyBody = document.createElement("div");
    emptyBody.className = "model-provider-empty-body";

    const emptyTitle = document.createElement("p");
    emptyTitle.className = "model-provider-empty-title";
    emptyTitle.textContent = "当前配置没有可用提供商和模型";

    const emptyHint = document.createElement("p");
    emptyHint.className = "model-provider-empty-hint";
    emptyHint.textContent = "你可以先添加一个供应商和模型，然后回到这里管理。";

    const emptyAction = document.createElement("a");
    emptyAction.className = "model-provider-empty-action";
    emptyAction.href = "/model/add";
    emptyAction.textContent = "点击添加";
    emptyAction.setAttribute("aria-label", "点击添加模型");

    emptyBody.appendChild(emptyTitle);
    emptyBody.appendChild(emptyHint);
    emptyBody.appendChild(emptyAction);
    emptyCard.appendChild(emptyBody);
    container.appendChild(emptyCard);
    setInput("dashboard_current_model", "-");
    setInput("dashboard_current_provider", "-");
    setInput("dashboard_current_context_window", "-");
    setInput("dashboard_current_thinking_strength", "无");
    return;
  }

  providers.forEach((providerEntry) => {
    const models = Array.isArray(providerEntry?.models) ? providerEntry.models : [];
    if (models.length === 0) {
      return;
    }

    const group = document.createElement("article");
    group.className = "model-provider-group";
    const providerId = String(providerEntry?.id || "").trim();

    if (providerId) {
      const header = document.createElement("div");
      header.className = "model-provider-group-head";
      const headRow = document.createElement("div");
      headRow.className = "model-provider-group-head-row";
      const title = document.createElement("h3");
      title.className = "model-provider-group-title";
      title.textContent = providerId;
      headRow.appendChild(title);

      const providerActions = document.createElement("div");
      providerActions.className = "model-provider-group-actions";

      const providerEditButton = document.createElement("button");
      providerEditButton.type = "button";
      providerEditButton.className = "model-provider-action-btn";
      providerEditButton.textContent = "编辑供应商";
      providerEditButton.addEventListener("click", () => {
        openProviderEditDialog(providerEntry);
      });
      providerActions.appendChild(providerEditButton);

      const providerDeleteButton = document.createElement("button");
      providerDeleteButton.type = "button";
      providerDeleteButton.className = "model-provider-action-btn model-provider-action-btn-danger";
      providerDeleteButton.textContent = "删除供应商";
      providerDeleteButton.addEventListener("click", () => {
        runModelMutation(async () => {
          await deleteProviderWithConfirm(providerEntry);
        }).catch((error) => {
          setMessage(error.message || String(error), "error");
        });
      });
      providerActions.appendChild(providerDeleteButton);

      headRow.appendChild(providerActions);
      const meta = document.createElement("p");
      meta.className = "model-provider-group-meta";
      meta.textContent = `API: ${providerEntry.api || "-"} | Base URL: ${providerEntry.baseUrl || "-"}`;
      header.appendChild(headRow);
      header.appendChild(meta);
      group.appendChild(header);
    }

    const modelList = document.createElement("div");
    modelList.className = "model-chip-grid";
    models.forEach((providerModel) => {
      const modelEntry = buildModelEntryFromProvider(providerEntry, providerModel);
      const fallbackRef = `${String(providerEntry?.id || "").trim()}/${String(providerModel?.id || "").trim()}`.replace(/^\/+/, "");
      const normalizedRef = String(modelEntry.ref || fallbackRef).trim();
      modelEntry.ref = normalizedRef;
      const hasValidRef = Boolean(modelEntry.ref && String(modelEntry.providerId || "").trim() && String(modelEntry.modelId || "").trim());
      const isCurrent =
        normalizedRef === primaryRef ||
        (String(modelEntry.modelId || "").trim() === String(modelSettings?.modelId || "").trim() &&
          String(modelEntry.providerId || "").trim() === String(modelSettings?.providerId || "").trim());

      const family = resolveModelFamilyKey(modelEntry);
      const card = document.createElement("article");
      card.className = `model-chip family-${family}${isCurrent ? " is-current" : ""}`;
      card.classList.toggle("is-disabled", !hasValidRef);
      card.title = hasValidRef ? "点击卡片编辑模型" : "模型信息不完整，暂不可编辑";
      if (hasValidRef) {
        card.tabIndex = 0;
        card.setAttribute("role", "button");
      }

      const label = document.createElement("span");
      label.className = "model-chip-name";
      label.textContent = String(modelEntry.modelName || modelEntry.modelId || "-").trim() || "-";
      card.appendChild(label);

      const detail = document.createElement("span");
      detail.className = "model-chip-meta";
      const contextText =
        modelEntry.contextWindow && modelEntry.contextWindow > 0
          ? `Context ${Number(modelEntry.contextWindow).toLocaleString()}`
          : "Context -";
      const maxText =
        modelEntry.maxTokens && modelEntry.maxTokens > 0 ? `Max ${Number(modelEntry.maxTokens).toLocaleString()}` : "Max -";
      detail.textContent = `${modelEntry.modelId || "-"} | ${contextText} | ${maxText}`;
      card.appendChild(detail);

      if (isCurrent) {
        const currentTag = document.createElement("span");
        currentTag.className = "model-chip-current";
        currentTag.textContent = "当前使用";
        card.appendChild(currentTag);
      }

      const actionRow = document.createElement("div");
      actionRow.className = "model-chip-actions";

      const editButton = document.createElement("button");
      editButton.type = "button";
      editButton.className = "model-chip-action";
      editButton.textContent = "编辑";
      editButton.disabled = !hasValidRef;
      editButton.addEventListener("click", (event) => {
        event.stopPropagation();
        if (!hasValidRef) {
          return;
        }
        openModelEditDialog(providerEntry, modelEntry);
      });
      actionRow.appendChild(editButton);

      if (!isCurrent) {
        const switchButton = document.createElement("button");
        switchButton.type = "button";
        switchButton.className = "model-chip-action";
        switchButton.textContent = "设为默认";
        switchButton.disabled = !hasValidRef;
        switchButton.addEventListener("click", (event) => {
          event.stopPropagation();
          if (!hasValidRef) {
            return;
          }
          runModelMutation(async () => {
            await switchDefaultModelByEntry(modelSettings, modelEntry);
          }).catch((error) => {
            setMessage(error.message || String(error), "error");
          });
        });
        actionRow.appendChild(switchButton);
      }

      const deleteButton = document.createElement("button");
      deleteButton.type = "button";
      deleteButton.className = "model-chip-action model-chip-action-danger";
      deleteButton.textContent = "删除";
      deleteButton.disabled = !hasValidRef;
      deleteButton.addEventListener("click", (event) => {
        event.stopPropagation();
        if (!hasValidRef) {
          return;
        }
        runModelMutation(async () => {
          await deleteModelWithConfirm(providerEntry, modelEntry);
        }).catch((error) => {
          setMessage(error.message || String(error), "error");
        });
      });
      actionRow.appendChild(deleteButton);

      card.appendChild(actionRow);

      if (hasValidRef) {
        card.addEventListener("click", (event) => {
          if (event.target instanceof HTMLElement && event.target.closest(".model-chip-action")) {
            return;
          }
          openModelEditDialog(providerEntry, modelEntry);
        });
        card.addEventListener("keydown", (event) => {
          if (event.key !== "Enter" && event.key !== " ") {
            return;
          }
          if (event.target instanceof HTMLElement && event.target.closest(".model-chip-action")) {
            return;
          }
          event.preventDefault();
          openModelEditDialog(providerEntry, modelEntry);
        });
      }

      modelList.appendChild(card);
    });

    group.appendChild(modelList);
    container.appendChild(group);
  });

  const currentModelLabel = modelSettings.modelId || currentRefParts.modelId || "-";
  setInput("dashboard_current_model", currentModelLabel);
  setInput("dashboard_current_provider", modelSettings.providerId || currentRefParts.providerId || "-");
  setInput(
    "dashboard_current_context_window",
    modelSettings.contextWindow ? `${Number(modelSettings.contextWindow).toLocaleString()} tokens` : "-"
  );
  setInput("dashboard_current_thinking_strength", modelSettings.thinkingStrength || "无");
}

let dashboardGatewayTokenSyncPending = false;
let dashboardGatewayTokenLoadPending = false;
let dashboardGatewayPairingApprovePending = false;
let dashboardGatewayRestartPending = false;

function setDashboardGatewayTokenStatus(message, type = "info") {
  const statusEl = document.querySelector("#dashboard_gateway_token_status");
  if (!statusEl) {
    return;
  }
  statusEl.textContent = String(message || "").trim();
  statusEl.classList.toggle("is-done", type === "ok");
  statusEl.classList.toggle("is-fail", type === "error");
}

function setDashboardGatewayPairingStatus(message, type = "info") {
  const statusEl = document.querySelector("#dashboard_gateway_pairing_status");
  if (!statusEl) {
    return;
  }
  statusEl.textContent = String(message || "").trim();
  statusEl.classList.toggle("is-done", type === "ok");
  statusEl.classList.toggle("is-fail", type === "error");
}

function setDashboardGatewayTokenValue(token = "") {
  const value = String(token || "").trim();
  const tokenInput = document.querySelector("#dashboard_gateway_token_value");
  if (tokenInput instanceof HTMLInputElement) {
    tokenInput.value = value;
  }
  const copyButton = document.querySelector("#dashboard_gateway_token_copy");
  if (copyButton instanceof HTMLButtonElement) {
    copyButton.disabled = !value;
  }
}

function readDashboardGatewayTokenValue() {
  const tokenInput = document.querySelector("#dashboard_gateway_token_value");
  if (!(tokenInput instanceof HTMLInputElement)) {
    return "";
  }
  return String(tokenInput.value || "").trim();
}

async function copyTextToClipboard(text) {
  const value = String(text || "");
  if (!value) {
    return;
  }
  if (navigator?.clipboard?.writeText && window.isSecureContext) {
    await navigator.clipboard.writeText(value);
    return;
  }
  const temp = document.createElement("textarea");
  temp.value = value;
  temp.setAttribute("readonly", "true");
  temp.style.position = "fixed";
  temp.style.opacity = "0";
  temp.style.pointerEvents = "none";
  document.body.appendChild(temp);
  temp.focus();
  temp.select();
  const copied = document.execCommand("copy");
  document.body.removeChild(temp);
  if (!copied) {
    throw new Error("浏览器未允许复制，请手动复制");
  }
}

async function loadDashboardGatewayToken({ silent = false } = {}) {
  if (dashboardGatewayTokenLoadPending) {
    return;
  }
  dashboardGatewayTokenLoadPending = true;
  try {
    const result = await api("/api/gateway/token/current", {
      allowBusinessError: true
    });
    const payload = result?.result || {};
    if (!result.ok) {
      throw new Error(payload.message || result.message || "读取 Gateway Token 失败");
    }
    const token = String(payload.token || "").trim();
    if (!token) {
      setDashboardGatewayTokenValue("");
      setDashboardGatewayTokenStatus("当前未检测到 Gateway Token，请先点击自动配置。", "info");
      if (!silent) {
        setMessage("当前未检测到 Gateway Token，请先自动配置。", "info");
      }
      return;
    }
    setDashboardGatewayTokenValue(token);
    const tokenMasked = String(payload.tokenMasked || "").trim() || "已加载";
    const sourceLabel = String(payload.source || "openclaw-config").trim();
    setDashboardGatewayTokenStatus(`当前 Token：${tokenMasked}（来源：${sourceLabel}）`, "ok");
    if (!silent) {
      setMessage("Gateway Token 已读取，可直接复制使用", "ok");
    }
  } catch (error) {
    const detail = error.message || String(error);
    setDashboardGatewayTokenValue("");
    setDashboardGatewayTokenStatus(`读取 Gateway Token 失败：${detail}`, "error");
    if (!silent) {
      setMessage(`读取 Gateway Token 失败：${detail}`, "error");
    }
  } finally {
    dashboardGatewayTokenLoadPending = false;
  }
}

async function copyDashboardGatewayToken() {
  const token = readDashboardGatewayTokenValue();
  if (!token) {
    setMessage("当前没有可复制的 Gateway Token，请先点击自动配置。", "error");
    return;
  }
  const copyButton = document.querySelector("#dashboard_gateway_token_copy");
  const rawLabel = copyButton instanceof HTMLButtonElement ? copyButton.textContent : "";
  if (copyButton instanceof HTMLButtonElement) {
    copyButton.disabled = true;
    copyButton.textContent = "复制中...";
  }
  try {
    await copyTextToClipboard(token);
    setDashboardGatewayTokenStatus("Gateway Token 已复制到剪贴板。", "ok");
    setMessage("Gateway Token 已复制到剪贴板", "ok");
    if (copyButton instanceof HTMLButtonElement) {
      copyButton.textContent = "已复制";
    }
  } catch (error) {
    const detail = error.message || String(error);
    setMessage(`Gateway Token 复制失败：${detail}`, "error");
    if (copyButton instanceof HTMLButtonElement) {
      copyButton.textContent = "复制失败";
    }
  } finally {
    if (copyButton instanceof HTMLButtonElement) {
      setTimeout(() => {
        copyButton.textContent = rawLabel || "复制 Gateway Token";
        copyButton.disabled = !readDashboardGatewayTokenValue();
      }, 1200);
    }
  }
}

async function syncDashboardGatewayToken() {
  if (dashboardGatewayTokenSyncPending) {
    setMessage("Gateway Token 自动配置正在进行，请稍候", "info");
    return;
  }

  const triggerButton = document.querySelector("#dashboard_gateway_token_sync");
  dashboardGatewayTokenSyncPending = true;
  if (triggerButton instanceof HTMLButtonElement) {
    triggerButton.disabled = true;
    triggerButton.setAttribute("aria-busy", "true");
  }
  setDashboardGatewayTokenStatus("正在自动读取并写入 Gateway Token...", "info");

  try {
    const result = await api("/api/gateway/token/sync", {
      method: "POST",
      allowBusinessError: true
    });
    const payload = result?.result || {};
    if (!result.ok) {
      throw new Error(payload.message || result.message || "自动配置失败");
    }
    const tokenPlain = String(payload.token || "").trim();
    if (tokenPlain) {
      setDashboardGatewayTokenValue(tokenPlain);
    }
    const tokenMasked = String(payload.tokenMasked || "").trim() || "已写入";
    const sourceLabel = String(payload.source || "runtime").trim();
    setDashboardGatewayTokenStatus(`配置完成：${tokenMasked}（来源：${sourceLabel}）`, "ok");
    setMessage(`Gateway Token 自动配置完成：${payload.path || "-"}`, "ok");
  } catch (error) {
    const detail = error.message || String(error);
    setDashboardGatewayTokenStatus(`自动配置失败：${detail}`, "error");
    setMessage(`Gateway Token 自动配置失败：${detail}`, "error");
  } finally {
    dashboardGatewayTokenSyncPending = false;
    if (triggerButton instanceof HTMLButtonElement) {
      triggerButton.disabled = false;
      triggerButton.setAttribute("aria-busy", "false");
    }
  }
}

async function approveDashboardPendingPairings() {
  if (dashboardGatewayPairingApprovePending) {
    setMessage("待处理配对审批正在执行，请稍候", "info");
    return;
  }

  const triggerButton = document.querySelector("#dashboard_gateway_pairing_approve");
  dashboardGatewayPairingApprovePending = true;
  if (triggerButton instanceof HTMLButtonElement) {
    triggerButton.disabled = true;
    triggerButton.setAttribute("aria-busy", "true");
  }
  setDashboardGatewayPairingStatus("正在读取并批准待处理配对请求...", "info");

  try {
    const result = await api("/api/gateway/pairing/approve-pending", {
      method: "POST",
      allowBusinessError: true
    });
    const payload = result?.result || {};
    if (!result.ok) {
      throw new Error(payload.message || result.message || "待处理配对审批失败");
    }

    const pendingCount = Number(payload.pendingCount || 0);
    const approvedCount = Number(payload.approvedCount || 0);
    const failedCount = Number(payload.failedCount || 0);
    if (pendingCount === 0) {
      setDashboardGatewayPairingStatus("当前没有待处理配对请求，无需审批。", "ok");
      setMessage("当前没有待处理配对请求", "ok");
      return;
    }
    if (failedCount > 0) {
      const detail = String(payload.message || "存在审批失败项").trim();
      setDashboardGatewayPairingStatus(`审批部分失败：成功 ${approvedCount} / 失败 ${failedCount}`, "error");
      setMessage(`待处理配对审批失败：${detail}`, "error");
      return;
    }

    setDashboardGatewayPairingStatus(`已批准 ${approvedCount} 个待处理配对请求`, "ok");
    setMessage(`待处理配对审批完成：${approvedCount} 个`, "ok");
  } catch (error) {
    const detail = error.message || String(error);
    setDashboardGatewayPairingStatus(`审批失败：${detail}`, "error");
    setMessage(`待处理配对审批失败：${detail}`, "error");
  } finally {
    dashboardGatewayPairingApprovePending = false;
    if (triggerButton instanceof HTMLButtonElement) {
      triggerButton.disabled = false;
      triggerButton.setAttribute("aria-busy", "false");
    }
  }
}

async function restartDashboardGatewayService() {
  if (dashboardGatewayRestartPending) {
    setMessage("网关重启正在执行，请稍候", "info");
    return;
  }

  const triggerButton = document.querySelector("#dashboard_gateway_restart");
  dashboardGatewayRestartPending = true;
  if (triggerButton instanceof HTMLButtonElement) {
    triggerButton.disabled = true;
    triggerButton.setAttribute("aria-busy", "true");
  }
  setDashboardGatewayPairingStatus("正在重启网关服务...", "info");

  try {
    const result = await api("/api/service/restart", {
      method: "POST",
      allowBusinessError: true
    });
    const payload = result?.result || {};
    const actionOk = payload?.ok !== false;
    if (!result.ok || !actionOk) {
      throw new Error(payload.message || result.message || "网关重启失败");
    }
    const detail = String(payload.message || "执行成功").trim();
    setDashboardGatewayPairingStatus(`网关重启完成：${detail}`, "ok");
    setMessage(`网关重启完成：${detail}`, "ok");
  } catch (error) {
    const detail = error.message || String(error);
    setDashboardGatewayPairingStatus(`网关重启失败：${detail}`, "error");
    setMessage(`网关重启失败：${detail}`, "error");
  } finally {
    dashboardGatewayRestartPending = false;
    if (triggerButton instanceof HTMLButtonElement) {
      triggerButton.disabled = false;
      triggerButton.setAttribute("aria-busy", "false");
    }
  }
}

function setupDashboard() {
  if (modelEditorState.dashboardBound) {
    return;
  }
  modelEditorState.dashboardBound = true;
  const contextInputs = Array.from(document.querySelectorAll("[data-dashboard-context-input]"));
  const syncContextInputs = (valueText) => {
    contextInputs.forEach((input) => {
      if (String(input.value || "") !== valueText) {
        input.value = valueText;
      }
    });
  };
  const saved = toNonNegativeInt(localStorage.getItem(DASHBOARD_CONTEXT_KEY) || "");
  if (saved !== null) {
    syncContextInputs(String(saved));
  }
  contextInputs.forEach((input) => {
    input.addEventListener("input", () => {
      const parsed = toNonNegativeInt(input.value || "");
      if (parsed === null) {
        localStorage.removeItem(DASHBOARD_CONTEXT_KEY);
        syncContextInputs("");
        return;
      }
      const next = String(parsed);
      localStorage.setItem(DASHBOARD_CONTEXT_KEY, next);
      syncContextInputs(next);
    });
  });

  document.querySelectorAll("[data-dashboard-jump]").forEach((button) => {
    button.addEventListener("click", () => {
      const target = String(button.getAttribute("data-dashboard-jump") || "").trim();
      if (!target) {
        return;
      }
      const tab = document.querySelector(`.tab[data-tab-target="${target}"]`);
      if (tab instanceof HTMLElement) {
        tab.click();
      }
    });
  });

  document.querySelector("#dashboard_summary_refresh")?.addEventListener("click", () => {
    Promise.allSettled([loadStatusOverview({ silent: true }), loadErrorSummary({ silent: true }), checkUpdate({ silent: true })])
      .then((results) => {
        const failed = results.filter((item) => item.status === "rejected");
        if (failed.length > 0) {
          const reasons = failed.map((item) => item.reason?.message || String(item.reason || "unknown"));
          setMessage(`仪表盘刷新部分失败：${reasons.join(" | ")}`, "error");
          return;
        }
        setMessage("仪表盘状态总览刷新完成", "ok");
      });
  });

  document.querySelector("#dashboard_quick_model_ref")?.addEventListener("change", () => {
    const settings = modelEditorState.currentModelSettings;
    const selectedRef = String(getInputValue("dashboard_quick_model_ref") || "").trim();
    const entry = findModelEntryByRef(settings, selectedRef);
    renderDashboardQuickSwitchHint(entry);
  });

  document.querySelector("#dashboard_quick_switch")?.addEventListener("click", () => {
    const settings = modelEditorState.currentModelSettings;
    if (!settings) {
      setMessage("模型配置尚未加载完成，请稍后重试", "error");
      return;
    }
    const selectedRef = String(getInputValue("dashboard_quick_model_ref") || "").trim();
    if (!selectedRef) {
      setMessage("请先选择目标模型", "error");
      return;
    }
    const entry = findModelEntryByRef(settings, selectedRef);
    if (!entry) {
      setMessage("目标模型不存在，请刷新页面后重试", "error");
      return;
    }
    switchDefaultModelByEntry(settings, entry, "已从仪表盘切换默认模型到").catch((error) =>
      setMessage(error.message || String(error), "error")
    );
  });

  document.querySelector("#dashboard_gateway_token_sync")?.addEventListener("click", () => {
    syncDashboardGatewayToken().catch((error) => {
      const detail = error.message || String(error);
      setDashboardGatewayTokenStatus(`自动配置失败：${detail}`, "error");
      setMessage(`Gateway Token 自动配置失败：${detail}`, "error");
    });
  });

  document.querySelector("#dashboard_gateway_token_copy")?.addEventListener("click", () => {
    copyDashboardGatewayToken().catch((error) => {
      const detail = error.message || String(error);
      setMessage(`Gateway Token 复制失败：${detail}`, "error");
    });
  });

  document.querySelector("#dashboard_gateway_pairing_approve")?.addEventListener("click", () => {
    approveDashboardPendingPairings().catch((error) => {
      const detail = error.message || String(error);
      setDashboardGatewayPairingStatus(`审批失败：${detail}`, "error");
      setMessage(`待处理配对审批失败：${detail}`, "error");
    });
  });

  document.querySelector("#dashboard_gateway_restart")?.addEventListener("click", () => {
    restartDashboardGatewayService().catch((error) => {
      const detail = error.message || String(error);
      setDashboardGatewayPairingStatus(`网关重启失败：${detail}`, "error");
      setMessage(`网关重启失败：${detail}`, "error");
    });
  });

  loadDashboardGatewayToken({ silent: true }).catch(() => {});
}

function truncateText(value, max = 72) {
  const text = String(value || "").replace(/\s+/g, " ").trim();
  if (!text) {
    return "";
  }
  if (text.length <= max) {
    return text;
  }
  return `${text.slice(0, Math.max(0, max - 1))}…`;
}

function updateDashboardErrorSummary(lines = []) {
  const list = Array.isArray(lines) ? lines : [];
  const latestLine = list.length > 0 ? String(list[list.length - 1] || "").trim() : "";
  dashboardSummaryState.errorCount = list.length;
  dashboardSummaryState.latestError = latestLine;

  if (list.length === 0) {
    setText("dashboard_summary_errors", "无错误");
    setText("dashboard_summary_errors_meta", "最近 20 条中未发现错误关键字");
    return;
  }

  setText("dashboard_summary_errors", `${list.length} 条错误`);
  setText("dashboard_summary_errors_meta", truncateText(latestLine, 80) || "已命中错误关键字");
}

function updateDashboardVersionSummary(updateResult = {}) {
  const currentTag = String(updateResult?.currentTag || "").trim();
  const latestTag = String(updateResult?.latestTag || "").trim();
  const warning = String(updateResult?.warning || "").trim();
  const hasUpdate = Boolean(updateResult?.updateAvailable);

  dashboardSummaryState.currentTag = currentTag;
  dashboardSummaryState.latestTag = latestTag;
  dashboardSummaryState.updateAvailable = hasUpdate;
  dashboardSummaryState.updateWarning = warning;

  if (warning) {
    setText("dashboard_summary_version", currentTag ? `当前 ${currentTag}` : "检查失败");
    setText("dashboard_summary_version_meta", truncateText(`最新版本读取失败：${warning}`, 90));
    return;
  }

  if (!currentTag && !latestTag) {
    setText("dashboard_summary_version", "未读取");
    setText("dashboard_summary_version_meta", "尚未获取版本信息");
    return;
  }

  setText("dashboard_summary_version", hasUpdate ? `可升级到 ${latestTag || "-"}` : `当前 ${currentTag || "-"}`);
  setText(
    "dashboard_summary_version_meta",
    hasUpdate ? `当前 ${currentTag || "-"}，检测到新版本` : `当前 ${currentTag || "-"}，已是最新`
  );
}

function updateDashboardSummaryCards({ runtime = {}, model = {}, channels = {}, skills = {}, refreshedAt = "" } = {}) {
  const runtimeMode = String(runtime?.mode || "-");
  const runtimeState = runtime?.active ? "运行中" : runtime?.ok === false ? "状态异常" : "未运行";
  setText("dashboard_summary_runtime", runtimeState);
  setText("dashboard_summary_runtime_meta", `模式: ${runtimeMode} | ${truncateText(runtime?.message || "-", 56)}`);

  // 顶部大字状态同步
  const heroEl = document.querySelector("#runtime_state");
  if (heroEl) {
    heroEl.textContent = runtime?.active ? "机器人运行中" : runtime?.ok === false ? "状态异常" : "未运行";
    const dot = heroEl.previousElementSibling;
    if (dot && dot.classList.contains("dot")) {
      dot.style.background = runtime?.active ? "var(--success, #22c55e)" : "var(--danger, #ef4444)";
    }
  }

  const currentModel = model?.current && typeof model.current === "object" ? model.current : {};
  const modelId = String(currentModel?.modelName || currentModel?.modelId || "-");
  const modelProvider = String(currentModel?.providerId || "-");
  setText("dashboard_summary_model", modelId || "-");
  setText("dashboard_summary_model_meta", `提供商: ${modelProvider}`);
  // 同步 hero 模型名 + 模型切换区显示
  setText("dashboard_hero_model", modelId !== "-" ? `· ${modelId}` : "");
  setText("dashboard_model_display", modelId || "-");

  const channelRuntime = channels?.runtime && typeof channels.runtime === "object" ? channels.runtime : {};
  const channelRunning = Number(channelRuntime?.running ?? 0);
  const channelTotal = Number(channelRuntime?.total ?? 0);
  setText("dashboard_summary_channels", `${channelRunning}/${channelTotal}`);
  setText(
    "dashboard_summary_channels_meta",
    channelRuntime?.ok === false
      ? `渠道状态读取失败: ${truncateText(channelRuntime?.message || "-", 56)}`
      : "运行中 / 总渠道数"
  );

  const skillSummary = skills && typeof skills === "object" ? skills : {};
  const skillEnabled = Number(skillSummary?.enabled ?? 0);
  const skillTotal = Number(skillSummary?.total ?? 0);
  setText("dashboard_summary_skills", `${skillEnabled}/${skillTotal}`);
  setText(
    "dashboard_summary_skills_meta",
    skillSummary?.ok === false ? `Skills 状态读取失败: ${truncateText(skillSummary?.message || "-", 56)}` : "已启用 / 总技能数"
  );

  const hint = document.querySelector("#dashboard_summary_hint");
  if (hint) {
    hint.textContent = refreshedAt ? `最后刷新：${refreshedAt}` : '点击"刷新总览"后显示最新状态。';
  }
}

function renderChannelRuntimeList(containerSelector, items = [], emptyText = "暂无渠道运行数据") {
  const container = document.querySelector(containerSelector);
  if (!container) {
    return;
  }
  if (!Array.isArray(items) || items.length === 0) {
    setStackListEmpty(container, emptyText);
    return;
  }

  container.innerHTML = "";
  items.forEach((item) => {
    const node = document.createElement("sl-card");
    node.className = "dashboard-runtime-item dashboard-runtime-item-channel";
    node.title = `${item?.name || item?.key || "未命名 Skill"}\nkey: ${item?.key || "-"}\nsource: ${item?.source || "-"}`;

    const body = document.createElement("div");
    body.className = "dashboard-runtime-item-body";

    const top = document.createElement("div");
    top.className = "stack-item-row";
    const title = document.createElement("span");
    title.className = "stack-item-title";
    title.textContent = item?.label || item?.id || "未命名渠道";
    top.appendChild(title);

    const chips = document.createElement("div");
    chips.className = "chip-line";

    const configuredChip = createDashboardStatusTag(item?.configured ? "已配置" : "未配置", item?.configured ? "success" : "neutral");
    chips.appendChild(configuredChip);

    const runningChip = createDashboardStatusTag(item?.running ? "运行中" : "未运行", item?.running ? "primary" : "warning");
    chips.appendChild(runningChip);

    if (String(item?.lastError || "").trim()) {
      chips.appendChild(createDashboardStatusTag("最近有报错", "danger"));
    }

    top.appendChild(chips);
    body.appendChild(top);

    const meta = document.createElement("p");
    meta.className = "stack-item-meta";
    const errorText = String(item?.lastError || "").trim();
    const probeText = formatLocalTime(item?.lastProbeAt);
    meta.textContent = errorText ? `最近错误: ${errorText}` : `最近检查: ${probeText}`;
    body.appendChild(meta);
    node.appendChild(body);
    container.appendChild(node);
  });
}

function renderSkillsRuntimeList(containerSelector, items = [], emptyText = "暂无 Skills 运行数据") {
  const container = document.querySelector(containerSelector);
  if (!container) {
    return;
  }
  if (!Array.isArray(items) || items.length === 0) {
    setStackListEmpty(container, emptyText);
    return;
  }

  const total = items.length;
  const enabledCount = items.filter((i) => i?.enabled).length;

  // 摘要文字
  const summaryEl = document.querySelector("#dashboard_skills_summary_text");
  if (summaryEl) {
    summaryEl.textContent = `${total} 个技能，${enabledCount} 个已启用`;
  }

  // 分为有问题 / 正常两组
  const problemItems = items.filter((i) => !i?.enabled || i?.blocked || !i?.eligible);
  const normalItems = items.filter((i) => i?.enabled && !i?.blocked && i?.eligible);

  container.innerHTML = "";

  const renderItem = (item) => {
    const node = document.createElement("div");
    node.className = "dashboard-runtime-item-flat dashboard-runtime-item-body";

    const top = document.createElement("div");
    top.className = "stack-item-row";
    const title = document.createElement("span");
    title.className = "stack-item-title";
    title.textContent = item?.name || item?.key || "未命名 Skill";
    top.appendChild(title);

    const chips = document.createElement("div");
    chips.className = "chip-line";
    // 三维状态合并为一个标签
    let statusText, statusVariant;
    if (item?.blocked) {
      statusText = "受限"; statusVariant = "danger";
    } else if (!item?.enabled) {
      statusText = "已禁用"; statusVariant = "neutral";
    } else if (!item?.eligible) {
      statusText = "未就绪"; statusVariant = "warning";
    } else {
      statusText = "正常"; statusVariant = "success";
    }
    chips.appendChild(createDashboardStatusTag(statusText, statusVariant));
    top.appendChild(chips);
    node.appendChild(top);
    return node;
  };

  // 先渲染有问题的
  problemItems.forEach((item) => container.appendChild(renderItem(item)));

  // 正常技能默认隐藏
  const normalNodes = normalItems.map((item) => {
    const n = renderItem(item);
    n.style.display = "none";
    n.dataset.skillNormal = "1";
    container.appendChild(n);
    return n;
  });

  // 切换按钮
  const toggleBtn = document.querySelector("#dashboard_skills_toggle_all");
  if (toggleBtn) {
    if (normalItems.length === 0) {
      toggleBtn.style.display = "none";
    } else {
      toggleBtn.style.display = "";
      toggleBtn.textContent = `显示全部 (${total})`;
      let expanded = false;
      toggleBtn.onclick = () => {
        expanded = !expanded;
        normalNodes.forEach((n) => (n.style.display = expanded ? "" : "none"));
        toggleBtn.textContent = expanded ? "只看有问题的" : `显示全部 (${total})`;
      };
    }
  }
}

function renderDashboardChannelRuntime(items = []) {
  renderChannelRuntimeList("#dashboard_channel_runtime_list", items, "暂无渠道运行数据");
}

function renderDashboardSkillsRuntime(items = []) {
  renderSkillsRuntimeList("#dashboard_skills_runtime_list", items, "暂无 Skills 运行数据");
}

async function loadStatusOverview({ silent = false } = {}) {
  const response = await api("/api/dashboard/summary");
  const summary = response?.summary && typeof response.summary === "object" ? response.summary : {};
  const runtime = summary.runtime && typeof summary.runtime === "object" ? summary.runtime : {};
  const model = summary.model && typeof summary.model === "object" ? summary.model : {};
  const channels = summary.channels && typeof summary.channels === "object" ? summary.channels : {};
  const runtimeChannels = channels.runtime && typeof channels.runtime === "object" ? channels.runtime : {};
  const skills = summary.skills && typeof summary.skills === "object" ? summary.skills : {};
  const refreshedAt = new Date().toLocaleString();
  renderDashboardChannelRuntime(Array.isArray(runtimeChannels.items) ? runtimeChannels.items : []);
  renderDashboardSkillsRuntime(Array.isArray(skills.items) ? skills.items : []);
  updateDashboardSummaryCards({
    runtime,
    model,
    channels,
    skills,
    refreshedAt
  });

  if (!silent) {
    setMessage("状态总览刷新完成", "ok");
  }
}

function setSelectValueWithCustom(selectId, customInputId, rawValue) {
  const selectEl = document.querySelector(`#${selectId}`);
  if (!selectEl) {
    return;
  }
  const customEl = customInputId ? document.querySelector(`#${customInputId}`) : null;
  const value = String(rawValue || "").trim();
  const hasPresetOption = Array.from(selectEl.options || []).some((option) => option.value === value);

  if (hasPresetOption) {
    selectEl.value = value;
    if (customEl) {
      customEl.value = "";
      customEl.classList.remove("is-visible");
    }
    return;
  }

  if (Array.from(selectEl.options || []).some((option) => option.value === "custom")) {
    selectEl.value = "custom";
    if (customEl) {
      customEl.value = value;
      customEl.classList.add("is-visible");
    }
    return;
  }

  selectEl.value = value;
}

function getSelectValueWithCustom(selectId, customInputId) {
  const selectEl = document.querySelector(`#${selectId}`);
  if (!selectEl) {
    return "";
  }
  if (String(selectEl.value || "") !== "custom") {
    return String(selectEl.value || "").trim();
  }
  const customEl = customInputId ? document.querySelector(`#${customInputId}`) : null;
  return String(customEl?.value || "").trim();
}

function fillModelIdPicker(selectId, customInputId, { modelIds = [], selectedValue = "" } = {}) {
  const selectEl = document.querySelector(`#${selectId}`);
  if (!(selectEl instanceof HTMLSelectElement)) {
    return "";
  }

  const seen = new Set();
  const orderedIds = [];
  modelIds.forEach((item) => {
    const id = String(item || "").trim();
    if (!id || seen.has(id)) {
      return;
    }
    seen.add(id);
    orderedIds.push(id);
  });
  DEFAULT_MODEL_OPTIONS.forEach((item) => {
    const id = String(item?.id || "").trim();
    if (!id || seen.has(id)) {
      return;
    }
    seen.add(id);
    orderedIds.push(id);
  });

  selectEl.innerHTML = "";
  orderedIds.forEach((id) => {
    const option = document.createElement("option");
    option.value = id;
    option.textContent = id;
    selectEl.appendChild(option);
  });
  const customOption = document.createElement("option");
  customOption.value = "custom";
  customOption.textContent = "自定义";
  selectEl.appendChild(customOption);

  const preferredValue = String(selectedValue || "").trim() || orderedIds[0] || "custom";
  setSelectValueWithCustom(selectId, customInputId, preferredValue);
  return getSelectValueWithCustom(selectId, customInputId);
}

function toModelFallbackFromDefaultEntry(entry = {}) {
  const modelId = String(entry?.modelId || "").trim();
  if (!modelId) {
    return {};
  }
  return {
    id: modelId,
    name: String(entry?.modelName || modelId).trim() || modelId,
    contextWindow: Number(entry?.contextWindow || 0) || undefined,
    maxTokens: Number(entry?.maxTokens || 0) || undefined
  };
}

function renderTemplatePreset(templateKey, options = {}) {
  const template = MODEL_TEMPLATE_MAP[templateKey] || MODEL_TEMPLATE_MAP["aicodecat-gpt"];
  const apiMode = String(options.apiOverride || template.api || "").trim();
  const forceModelName = Boolean(options.forceModelName);
  const isAicodecatTemplate = String(template.providerId || "").startsWith("aicodecat-");
  const preferredModelId = String(
    options.modelId || getSelectValueWithCustom("template_model_id", "template_model_id_custom") || ""
  ).trim();

  setInput("template_provider_id", template.providerId);
  setSelectValueWithCustom("template_api", "template_api_custom", apiMode);
  setInput("template_base_url", isAicodecatTemplate ? resolveAicodecatBaseUrl(apiMode) : template.baseUrl);

  const templateModelId = fillModelIdPicker("template_model_id", "template_model_id_custom", {
    modelIds: (template.models || []).map((item) => item?.id),
    selectedValue: preferredModelId
  });
  const selectedTemplateModel =
    template.models.find((item) => String(item?.id || "").trim() === templateModelId) || template.models[0] || {};
  const currentTemplateName = String(getInputValue("template_model_name") || "").trim();
  if (forceModelName || !currentTemplateName) {
    setInput("template_model_name", selectedTemplateModel?.name || templateModelId || "");
  }
  const modelName = String(getInputValue("template_model_name") || "").trim();
  const family = modelFamilyById(templateModelId);
  const profile = MODEL_PROFILE_BY_FAMILY[family] || MODEL_PROFILE_BY_FAMILY.gpt;
  const previewModel = normalizeModelDraft(
    {
      id: templateModelId,
      name: modelName || selectedTemplateModel?.name || templateModelId
    },
    {
      id: templateModelId,
      name: selectedTemplateModel?.name || templateModelId,
      reasoning:
        selectedTemplateModel?.reasoning !== undefined
          ? Boolean(selectedTemplateModel.reasoning)
          : Boolean(template.models?.[0]?.reasoning),
      input:
        Array.isArray(selectedTemplateModel?.input) && selectedTemplateModel.input.length > 0
          ? selectedTemplateModel.input
          : Array.isArray(template.models?.[0]?.input) && template.models[0].input.length > 0
            ? template.models[0].input
            : ["text"],
      contextWindow: selectedTemplateModel?.contextWindow || profile.contextWindow,
      maxTokens: selectedTemplateModel?.maxTokens || profile.maxTokens
    }
  );

  const preview = document.querySelector("#template_model_preview");
  if (preview) {
    preview.textContent = previewModel
      ? `- ${previewModel.name || previewModel.id} (${previewModel.id}) | 输入: ${(previewModel.input || []).join("+")} | 思考: ${
          previewModel.reasoning ? "开启" : "关闭"
        } | 上下文: ${previewModel.contextWindow} | 最大输出: ${previewModel.maxTokens}`
      : "请先选择或输入模型 ID";
  }

  setSelectValueWithCustom("custom_api", "custom_api_custom", apiMode || template.api);
  setInput("custom_base_url", isAicodecatTemplate ? resolveAicodecatBaseUrl(apiMode) : template.baseUrl);
  setInput("custom_provider_id", template.providerId);
  const customModelId = fillModelIdPicker("custom_model_id", "custom_model_id_custom", {
    modelIds: (template.models || []).map((item) => item?.id),
    selectedValue: templateModelId || template.models[0]?.id || DEFAULT_MODEL_OPTIONS[0]?.id || ""
  });
  if (!String(getInputValue("custom_model_name") || "").trim()) {
    const picked = template.models.find((item) => String(item?.id || "").trim() === customModelId);
    setInput("custom_model_name", String(picked?.name || customModelId || "").trim());
  }

  const defaultModel = buildDefaultModelEntry(customModelId, String(getInputValue("custom_model_name") || "").trim());
  if (!String(getInputValue("custom_model_context_window") || "").trim()) {
    setInput("custom_model_context_window", defaultModel?.contextWindow || "");
  }
  if (!String(getInputValue("custom_model_max_tokens") || "").trim()) {
    setInput("custom_model_max_tokens", defaultModel?.maxTokens || "");
  }
}

function getCatalogProviders(modelSettings = modelEditorState.currentModelSettings) {
  return Array.isArray(modelSettings?.catalog?.providers) ? modelSettings.catalog.providers : [];
}

function findCatalogProviderById(providerId, modelSettings = modelEditorState.currentModelSettings) {
  const target = String(providerId || "").trim();
  if (!target) {
    return null;
  }
  return getCatalogProviders(modelSettings).find((provider) => String(provider?.id || "").trim() === target) || null;
}

function syncExistingProviderMeta(modelSettings = modelEditorState.currentModelSettings) {
  const selectedProviderId = String(getInputValue("existing_provider_id") || "").trim();
  const selectedProvider = findCatalogProviderById(selectedProviderId, modelSettings);
  setInput("existing_provider_api", selectedProvider?.api || "");
  setInput("existing_provider_baseurl", selectedProvider?.baseUrl || "");

  const providerModelIds = Array.isArray(selectedProvider?.models)
    ? selectedProvider.models.map((item) => String(item?.id || "").trim()).filter(Boolean)
    : [];
  const previousModelId = getSelectValueWithCustom("existing_model_id", "existing_model_id_custom");
  const currentModelId = fillModelIdPicker("existing_model_id", "existing_model_id_custom", {
    modelIds: providerModelIds,
    selectedValue: previousModelId
  });

  const modelSelect = document.querySelector("#existing_model_id");
  if (modelSelect instanceof HTMLSelectElement) {
    modelSelect.disabled = !selectedProvider;
  }

  const selectedModel = Array.isArray(selectedProvider?.models)
    ? selectedProvider.models.find((item) => String(item?.id || "").trim() === currentModelId)
    : null;
  const selectedFallback = toModelFallbackFromDefaultEntry(buildDefaultModelEntry(currentModelId, currentModelId));
  const resolvedName = String(selectedModel?.name || selectedModel?.id || selectedFallback.name || currentModelId || "").trim();
  const resolvedContext = Number(selectedModel?.contextWindow || selectedFallback.contextWindow || 0) || "";
  const resolvedMaxTokens = Number(selectedModel?.maxTokens || selectedFallback.maxTokens || 0) || "";
  setInput("existing_model_name", resolvedName);
  setInput("existing_model_context_window", resolvedContext);
  setInput("existing_model_max_tokens", resolvedMaxTokens);
}

function fillExistingProviderOptions(modelSettings) {
  const select = document.querySelector("#existing_provider_id");
  if (!(select instanceof HTMLSelectElement)) {
    return;
  }

  const providers = getCatalogProviders(modelSettings).filter((provider) => String(provider?.id || "").trim());
  select.innerHTML = "";
  if (providers.length === 0) {
    const emptyOption = document.createElement("option");
    emptyOption.value = "";
    emptyOption.textContent = "暂无可用供应商";
    select.appendChild(emptyOption);
    select.disabled = true;
    setInput("existing_provider_api", "");
    setInput("existing_provider_baseurl", "");
    fillModelIdPicker("existing_model_id", "existing_model_id_custom", {
      modelIds: [],
      selectedValue: ""
    });
    const modelSelect = document.querySelector("#existing_model_id");
    if (modelSelect instanceof HTMLSelectElement) {
      modelSelect.disabled = true;
    }
    return;
  }

  select.disabled = false;
  providers.forEach((provider) => {
    const option = document.createElement("option");
    option.value = String(provider.id || "").trim();
    option.textContent = String(provider.id || "").trim();
    select.appendChild(option);
  });

  const preferredProviderId = String(modelSettings?.providerId || "").trim();
  if (preferredProviderId && providers.some((provider) => String(provider.id || "").trim() === preferredProviderId)) {
    select.value = preferredProviderId;
  } else if (select.options.length > 0) {
    select.selectedIndex = 0;
  }
  syncExistingProviderMeta(modelSettings);
}

function fillModelEditor(modelSettings) {
  const catalog = modelSettings?.catalog || { providers: [], modelRefs: [] };
  const catalogRefs = Array.isArray(catalog.modelRefs) ? catalog.modelRefs : [];
  modelEditorState.currentModelSettings = modelSettings || null;
  modelEditorState.modelCatalog = {
    providers: Array.isArray(catalog.providers) ? catalog.providers : [],
    modelRefs: catalogRefs
  };

  const selectableModelRefs = [];
  const seenRefs = new Set();

  // 只使用当前配置文件中已经存在的模型，避免把模板默认模型误展示给用户。
  catalogRefs.forEach((entry) => {
    const ref = String(entry?.ref || "").trim();
    if (!ref || seenRefs.has(ref)) {
      return;
    }
    seenRefs.add(ref);
    selectableModelRefs.push({
      ...entry,
      ref
    });
  });

  const currentPrimary = String(modelSettings?.primary || "").trim();
  if (currentPrimary && !seenRefs.has(currentPrimary)) {
    const fallbackCurrent = {
      ref: currentPrimary,
      providerId: modelSettings.providerId,
      providerApi: modelSettings.providerApi,
      providerBaseUrl: modelSettings.providerBaseUrl,
      modelId: modelSettings.modelId,
      modelName: modelSettings.modelName,
      contextWindow: modelSettings.contextWindow,
      maxTokens: modelSettings.maxTokens,
      thinkingStrength: modelSettings.thinkingStrength || "无"
    };
    seenRefs.add(currentPrimary);
    selectableModelRefs.push(fallbackCurrent);
  }

  if (selectableModelRefs.length === 0 && currentPrimary) {
    selectableModelRefs.push({
      ref: currentPrimary,
      providerId: modelSettings.providerId,
      providerApi: modelSettings.providerApi,
      providerBaseUrl: modelSettings.providerBaseUrl,
      modelId: modelSettings.modelId,
      modelName: modelSettings.modelName,
      contextWindow: modelSettings.contextWindow,
      maxTokens: modelSettings.maxTokens,
      thinkingStrength: modelSettings.thinkingStrength || "无"
    });
  }

  modelEditorState.defaultModelRefs = selectableModelRefs;

  const defaultSelect = document.querySelector("#model_default_ref");
  if (defaultSelect) {
    defaultSelect.innerHTML = "";
    modelEditorState.defaultModelRefs.forEach((entry) => {
      const option = document.createElement("option");
      option.value = entry.ref;
      option.textContent = entry.modelId || entry.modelName || entry.ref;
      defaultSelect.appendChild(option);
    });
    if (modelSettings.primary && modelEditorState.defaultModelRefs.some((entry) => entry.ref === modelSettings.primary)) {
      defaultSelect.value = modelSettings.primary;
    } else if (defaultSelect.options.length > 0) {
      defaultSelect.selectedIndex = 0;
    }
  }

  const selectedEntry =
    modelEditorState.defaultModelRefs.find((entry) => entry.ref === modelSettings.primary) ||
    modelEditorState.defaultModelRefs[0] || {
      ref: modelSettings.primary,
      providerId: modelSettings.providerId,
      providerApi: modelSettings.providerApi,
      providerBaseUrl: modelSettings.providerBaseUrl,
      modelId: modelSettings.modelId,
      modelName: modelSettings.modelName,
      contextWindow: modelSettings.contextWindow,
      maxTokens: modelSettings.maxTokens
    };

  renderModelSummary(selectedEntry, selectedEntry.ref || modelSettings.primary);
  modelEditorState.currentModelPayload = buildModelPayload({
    primary: modelSettings.primary || selectedEntry.ref,
    providerId: modelSettings.providerId || selectedEntry.providerId,
    providerApi: modelSettings.providerApi || selectedEntry.providerApi,
    providerBaseUrl: modelSettings.providerBaseUrl || selectedEntry.providerBaseUrl,
    providerApiKey: "",
    modelId: modelSettings.modelId || selectedEntry.modelId,
    modelName: modelSettings.modelName || selectedEntry.modelName || selectedEntry.modelId,
    contextWindow: modelSettings.contextWindow || selectedEntry.contextWindow,
    maxTokens: modelSettings.maxTokens || selectedEntry.maxTokens,
    providerModels: []
  });
  setInput("template_set_as_primary", false);
  setInput("existing_set_as_primary", false);
  setInput("custom_set_as_primary", false);
  fillExistingProviderOptions(modelSettings);
  setModelProviderMode("template");
  setModelAddWorkspaceVisible(false);

  fillDashboardQuickSwitch(modelSettings);

  if (document.querySelector("#model_raw_config_editor")) {
    loadModelRawConfig({ silent: true }).catch((error) => {
      setModelRawConfigStatus(`读取失败：${error.message || String(error)}`, "error");
    });
  }
}

function bindModelCrudDialogEvents() {
  if (modelMutationState.dialogBound) {
    return;
  }
  modelMutationState.dialogBound = true;

  document.querySelector("#model_provider_edit_cancel")?.addEventListener("click", () => {
    closeShoelaceDialog("model_provider_edit_dialog");
  });
  document.querySelector("#model_provider_edit_submit")?.addEventListener("click", () => {
    runModelMutation(async () => {
      await submitProviderEditDialog();
    }).catch((error) => {
      setMessage(error.message || String(error), "error");
    });
  });

  document.querySelector("#model_item_edit_cancel")?.addEventListener("click", () => {
    closeShoelaceDialog("model_item_edit_dialog");
  });
  document.querySelector("#model_item_edit_submit")?.addEventListener("click", () => {
    runModelMutation(async () => {
      await submitModelEditDialog();
    }).catch((error) => {
      setMessage(error.message || String(error), "error");
    });
  });

  const providerDialog = getShoelaceDialog("model_provider_edit_dialog");
  providerDialog?.addEventListener("sl-after-hide", () => {
    modelMutationState.providerEditId = "";
    setInput("model_provider_edit_apikey", "");
  });

  const modelDialog = getShoelaceDialog("model_item_edit_dialog");
  modelDialog?.addEventListener("sl-after-hide", () => {
    modelMutationState.modelEditProviderId = "";
    modelMutationState.modelEditId = "";
  });
}

function setupModelEditor() {
  const panel = document.querySelector('[data-panel="panel-model"], [data-panel="panel-model-add"]');
  if (!panel || panel.dataset.boundModelEditor === "1") {
    return;
  }
  panel.dataset.boundModelEditor = "1";
  bindModelCrudDialogEvents();
  bindModelRawConfigEditor();
  const defaultSelect = document.querySelector("#model_default_ref");

  document.querySelector("#model_add_toggle")?.addEventListener("click", () => {
    const workspace = document.querySelector("#model_add_workspace");
    const willOpen = workspace ? workspace.classList.contains("is-hidden") : false;
    setModelAddWorkspaceVisible(willOpen);
    if (willOpen) {
      setModelProviderMode(modelEditorState.providerMode || "template");
      workspace?.scrollIntoView({ behavior: "smooth", block: "start" });
    }
  });

  document.querySelectorAll("[data-model-provider-mode]").forEach((button) => {
    button.addEventListener("click", () => {
      const targetMode = String(button.getAttribute("data-model-provider-mode") || "").trim();
      setModelProviderMode(targetMode);
    });
  });
  setModelProviderMode(modelEditorState.providerMode || "template");
  const existingModelSelect = document.querySelector("#existing_model_id");
  const existingModelCustomInput = document.querySelector("#existing_model_id_custom");
  const refreshExistingModelCustomInput = () => {
    if (!existingModelSelect || !existingModelCustomInput) {
      return;
    }
    const useCustom = String(existingModelSelect.value || "") === "custom";
    existingModelCustomInput.classList.toggle("is-visible", useCustom);
  };
  document.querySelector("#existing_provider_id")?.addEventListener("change", () => {
    syncExistingProviderMeta(modelEditorState.currentModelSettings);
    refreshExistingModelCustomInput();
  });
  existingModelSelect?.addEventListener("change", () => {
    syncExistingProviderMeta(modelEditorState.currentModelSettings);
    refreshExistingModelCustomInput();
  });
  refreshExistingModelCustomInput();

  const templateSelect = document.querySelector("#model_template_key");
  templateSelect?.addEventListener("change", () => {
    renderTemplatePreset(String(templateSelect.value || "aicodecat-gpt"), { forceModelName: true });
  });

  const templateApiSelect = document.querySelector("#template_api");
  const templateApiCustomInput = document.querySelector("#template_api_custom");
  const templateModelSelect = document.querySelector("#template_model_id");
  const templateModelCustomInput = document.querySelector("#template_model_id_custom");
  const templateModelNameInput = document.querySelector("#template_model_name");
  const syncTemplateByApiMode = () => {
    const providerId = String(getInputValue("template_provider_id") || "").trim();
    const apiMode = getSelectValueWithCustom("template_api", "template_api_custom");
    const selectedModelId = getSelectValueWithCustom("template_model_id", "template_model_id_custom");
    if (!providerId || !apiMode) {
      return;
    }

    const isAicodecatProvider = providerId === AICODECAT_PROVIDER || providerId.startsWith("aicodecat-");
    if (!isAicodecatProvider) {
      return;
    }

    const resolvedProviderId = resolveProviderId(AICODECAT_PROVIDER, apiMode);
    if (!MODEL_TEMPLATE_MAP[resolvedProviderId]) {
      return;
    }

    if (templateSelect) {
      templateSelect.value = resolvedProviderId;
    }
    renderTemplatePreset(resolvedProviderId, { apiOverride: apiMode, modelId: selectedModelId, forceModelName: true });
  };

  const syncTemplateByModelSelection = () => {
    const selectedModelId = getSelectValueWithCustom("template_model_id", "template_model_id_custom");
    if (!selectedModelId) {
      return;
    }

    const family = modelFamilyById(selectedModelId);
    const profile = MODEL_PROFILE_BY_FAMILY[family] || MODEL_PROFILE_BY_FAMILY.gpt;
    const providerApi = profile.apiMode;
    const providerId = resolveProviderId(AICODECAT_PROVIDER, providerApi);
    if (!MODEL_TEMPLATE_MAP[providerId]) {
      return;
    }

    if (templateSelect) {
      templateSelect.value = providerId;
    }
    renderTemplatePreset(providerId, { apiOverride: providerApi, modelId: selectedModelId, forceModelName: true });
  };

  const refreshTemplateApiCustomInput = () => {
    if (!templateApiSelect || !templateApiCustomInput) {
      return;
    }
    const useCustom = String(templateApiSelect.value || "") === "custom";
    templateApiCustomInput.classList.toggle("is-visible", useCustom);
  };

  const refreshTemplateModelCustomInput = () => {
    if (!templateModelSelect || !templateModelCustomInput) {
      return;
    }
    const useCustom = String(templateModelSelect.value || "") === "custom";
    templateModelCustomInput.classList.toggle("is-visible", useCustom);
  };

  templateApiSelect?.addEventListener("change", () => {
    refreshTemplateApiCustomInput();
    syncTemplateByApiMode();
  });
  templateApiCustomInput?.addEventListener("input", () => {
    if (String(templateApiSelect?.value || "") !== "custom") {
      return;
    }
    syncTemplateByApiMode();
  });
  templateModelSelect?.addEventListener("change", () => {
    refreshTemplateModelCustomInput();
    syncTemplateByModelSelection();
  });
  templateModelCustomInput?.addEventListener("input", () => {
    if (String(templateModelSelect?.value || "") !== "custom") {
      return;
    }
    syncTemplateByModelSelection();
  });
  templateModelNameInput?.addEventListener("input", () => {
    renderTemplatePreset(String(templateSelect?.value || "aicodecat-gpt"), {
      apiOverride: getSelectValueWithCustom("template_api", "template_api_custom"),
      modelId: getSelectValueWithCustom("template_model_id", "template_model_id_custom")
    });
  });
  refreshTemplateApiCustomInput();
  refreshTemplateModelCustomInput();

  const customApiSelect = document.querySelector("#custom_api");
  const customApiCustomInput = document.querySelector("#custom_api_custom");
  const customModelSelect = document.querySelector("#custom_model_id");
  const customModelCustomInput = document.querySelector("#custom_model_id_custom");
  const customProviderInput = document.querySelector("#custom_provider_id");

  const syncCustomByApiMode = () => {
    const providerId = String(getInputValue("custom_provider_id") || "").trim();
    const apiMode = getSelectValueWithCustom("custom_api", "custom_api_custom");
    if (!providerId || !apiMode) {
      return;
    }
    const isAicodecatProvider = providerId === AICODECAT_PROVIDER || providerId.startsWith("aicodecat-");
    if (!isAicodecatProvider) {
      return;
    }
    const resolvedProviderId = resolveProviderId(AICODECAT_PROVIDER, apiMode);
    setInput("custom_provider_id", resolvedProviderId);
    setInput("custom_base_url", resolveAicodecatBaseUrl(apiMode));
  };

  const syncCustomByModelSelection = () => {
    const providerId = String(getInputValue("custom_provider_id") || "").trim();
    const selectedModelId = getSelectValueWithCustom("custom_model_id", "custom_model_id_custom");
    if (!providerId || !selectedModelId) {
      return;
    }
    const isAicodecatProvider = providerId === AICODECAT_PROVIDER || providerId.startsWith("aicodecat-");
    if (!isAicodecatProvider) {
      return;
    }
    const family = modelFamilyById(selectedModelId);
    const profile = MODEL_PROFILE_BY_FAMILY[family] || MODEL_PROFILE_BY_FAMILY.gpt;
    const providerApi = profile.apiMode;
    setSelectValueWithCustom("custom_api", "custom_api_custom", providerApi);
    syncCustomByApiMode();
  };

  const refreshCustomApiCustomInput = () => {
    if (!customApiSelect || !customApiCustomInput) {
      return;
    }
    const useCustom = String(customApiSelect.value || "") === "custom";
    customApiCustomInput.classList.toggle("is-visible", useCustom);
  };

  const refreshCustomModelCustomInput = () => {
    if (!customModelSelect || !customModelCustomInput) {
      return;
    }
    const useCustom = String(customModelSelect.value || "") === "custom";
    customModelCustomInput.classList.toggle("is-visible", useCustom);
  };

  customApiSelect?.addEventListener("change", () => {
    refreshCustomApiCustomInput();
    syncCustomByApiMode();
  });
  customApiCustomInput?.addEventListener("input", () => {
    if (String(customApiSelect?.value || "") !== "custom") {
      return;
    }
    syncCustomByApiMode();
  });
  customModelSelect?.addEventListener("change", () => {
    refreshCustomModelCustomInput();
    syncCustomByModelSelection();
  });
  customModelCustomInput?.addEventListener("input", () => {
    if (String(customModelSelect?.value || "") !== "custom") {
      return;
    }
    syncCustomByModelSelection();
  });
  customProviderInput?.addEventListener("change", () => {
    syncCustomByApiMode();
  });
  refreshCustomApiCustomInput();
  refreshCustomModelCustomInput();

  if (defaultSelect instanceof HTMLSelectElement) {
    defaultSelect.addEventListener("change", () => {
      const selectedRef = String(defaultSelect.value || "");
      const entry = modelEditorState.defaultModelRefs.find((item) => item.ref === selectedRef);
      renderModelSummary(entry || {}, selectedRef);
    });
  }

  document.querySelector("#save_default_model")?.addEventListener("click", () => {
    const selectedRef = String(getInputValue("model_default_ref") || "").trim();
    const entry = modelEditorState.defaultModelRefs.find((item) => item.ref === selectedRef);
    if (!entry) {
      setMessage("默认模型无效，请先选择一个可用模型", "error");
      return;
    }
    const payload = buildModelPayload({
      primary: entry.ref,
      providerId: entry.providerId,
      providerApi: entry.providerApi,
      providerBaseUrl: entry.providerBaseUrl,
      providerApiKey: "",
      modelId: entry.modelId,
      modelName: entry.modelName || entry.modelId,
      contextWindow: entry.contextWindow || 200000,
      maxTokens: entry.maxTokens || 8192,
      providerModels: []
    });
    saveModelSettings(payload, "默认模型已更新").catch((error) => setMessage(error.message, "error"));
  });

  document.querySelector("#save_provider_template")?.addEventListener("click", () => {
    const templateKey = String(getInputValue("model_template_key") || "").trim();
    const template = MODEL_TEMPLATE_MAP[templateKey];
    if (!template) {
      setMessage("模板不存在，请重新选择", "error");
      return;
    }
    const providerId = String(getInputValue("template_provider_id") || "").trim();
    const providerApi = getSelectValueWithCustom("template_api", "template_api_custom");
    const providerBaseUrl = String(getInputValue("template_base_url") || "").trim();
    const providerApiKey = String(getInputValue("template_api_key") || "").trim();
    const modelId = getSelectValueWithCustom("template_model_id", "template_model_id_custom");
    const modelNameInput = String(getInputValue("template_model_name") || "").trim();

    if (!providerId || !providerApi || !providerBaseUrl || !modelId) {
      setMessage("模板配置不完整，请检查提供商名称 / API 模式 / URL / 模型 ID", "error");
      return;
    }

    const matchedTemplateModel = template.models.find((item) => String(item?.id || "").trim() === modelId) || null;
    const family = modelFamilyById(modelId);
    const familyProfile = MODEL_PROFILE_BY_FAMILY[family] || MODEL_PROFILE_BY_FAMILY.gpt;
    const fallbackModel = {
      id: modelId,
      name: matchedTemplateModel?.name || modelNameInput || modelId,
      reasoning:
        matchedTemplateModel?.reasoning !== undefined
          ? Boolean(matchedTemplateModel.reasoning)
          : Boolean(template.models?.[0]?.reasoning),
      input:
        Array.isArray(matchedTemplateModel?.input) && matchedTemplateModel.input.length > 0
          ? matchedTemplateModel.input
          : Array.isArray(template.models?.[0]?.input) && template.models[0].input.length > 0
            ? template.models[0].input
            : ["text"],
      contextWindow: matchedTemplateModel?.contextWindow || familyProfile.contextWindow,
      maxTokens: matchedTemplateModel?.maxTokens || familyProfile.maxTokens
    };
    const nextModel = normalizeModelDraft(
      {
        id: modelId,
        name: modelNameInput || fallbackModel.name
      },
      fallbackModel
    );
    if (!nextModel) {
      setMessage("模型信息无效，请检查模型 ID", "error");
      return;
    }

    const targetPrimaryRef = `${providerId}/${nextModel.id}`;
    const primaryRef = resolveProviderSavePrimaryRef(targetPrimaryRef, "template_set_as_primary");
    if (!primaryRef) {
      setMessage("无法确定默认模型指向，请先在路径 1 设置默认模型或勾选“保存后设为当前默认模型”", "error");
      return;
    }

    const payload = buildModelPayload({
      primary: primaryRef,
      providerId,
      providerApi,
      providerBaseUrl,
      providerApiKey,
      modelId: nextModel.id,
      modelName: nextModel.name || nextModel.id,
      contextWindow: nextModel.contextWindow,
      maxTokens: nextModel.maxTokens,
      providerModels: [nextModel]
    });
    const shouldSwitchPrimary = Boolean(getInputValue("template_set_as_primary"));
    const actionLabel = shouldSwitchPrimary ? "模型已写入并切换为默认模型" : "模型已写入（默认模型未变）";
    setModelAddSaveStatus("save_provider_template_status", "正在保存配置...", "working");
    saveModelSettings(payload, actionLabel)
      .then(() => {
        setModelAddSaveStatus("save_provider_template_status", "配置完成，模型已成功写入。", "ok");
      })
      .catch((error) => {
        setModelAddSaveStatus("save_provider_template_status", `保存失败：${error.message || String(error)}`, "error");
        setMessage(error.message || String(error), "error");
      });
  });

  document.querySelector("#save_provider_existing")?.addEventListener("click", () => {
    const providerId = String(getInputValue("existing_provider_id") || "").trim();
    const providerEntry = findCatalogProviderById(providerId, modelEditorState.currentModelSettings);
    if (!providerEntry) {
      setMessage("请先选择一个已有供应商", "error");
      return;
    }

    const modelId = getSelectValueWithCustom("existing_model_id", "existing_model_id_custom");
    const modelNameInput = String(getInputValue("existing_model_name") || "").trim();
    const contextWindowInput = Number(getInputValue("existing_model_context_window") || 0);
    const maxTokensInput = Number(getInputValue("existing_model_max_tokens") || 0);
    if (!modelId) {
      setMessage("请填写模型 ID", "error");
      return;
    }

    const providerApi = String(providerEntry.api || "").trim();
    const providerBaseUrl = String(providerEntry.baseUrl || "").trim();
    if (!providerApi || !providerBaseUrl) {
      setMessage("该供应商缺少 API 或 Base URL，请先补齐供应商配置后再添加模型", "error");
      return;
    }

    const currentModels = Array.isArray(providerEntry.models) ? providerEntry.models : [];
    const defaultModelFallback = toModelFallbackFromDefaultEntry(buildDefaultModelEntry(modelId, modelNameInput || modelId));
    const fallbackModel =
      currentModels.find((item) => String(item?.id || "").trim() === modelId) ||
      defaultModelFallback ||
      {};
    const nextModel = normalizeModelDraft(
      {
        id: modelId,
        name: modelNameInput || modelId,
        contextWindow: Number.isFinite(contextWindowInput) && contextWindowInput > 0 ? Math.floor(contextWindowInput) : undefined,
        maxTokens: Number.isFinite(maxTokensInput) && maxTokensInput > 0 ? Math.floor(maxTokensInput) : undefined
      },
      fallbackModel
    );
    if (!nextModel) {
      setMessage("模型信息无效，请检查模型 ID", "error");
      return;
    }

    const mergedModels = [nextModel];
    currentModels.forEach((item) => {
      const existingId = String(item?.id || "").trim();
      if (!existingId || existingId === nextModel.id) {
        return;
      }
      mergedModels.push(item);
    });

    const targetPrimaryRef = `${providerId}/${nextModel.id}`;
    const primaryRef = resolveProviderSavePrimaryRef(targetPrimaryRef, "existing_set_as_primary");
    if (!primaryRef) {
      setMessage("无法确定默认模型指向，请先设置默认模型或勾选“保存后设为当前默认模型”", "error");
      return;
    }

    const payload = buildModelPayload({
      primary: primaryRef,
      providerId,
      providerApi,
      providerBaseUrl,
      providerApiKey: "",
      modelId: nextModel.id,
      modelName: nextModel.name || nextModel.id,
      contextWindow: nextModel.contextWindow,
      maxTokens: nextModel.maxTokens,
      providerModels: mergedModels
    });
    const shouldSwitchPrimary = Boolean(getInputValue("existing_set_as_primary"));
    const actionLabel = shouldSwitchPrimary
      ? `已在供应商 ${providerId} 下新增模型并切换默认`
      : `已在供应商 ${providerId} 下新增模型（默认模型未变）`;
    setModelAddSaveStatus("save_provider_existing_status", "正在保存配置...", "working");
    saveModelSettings(payload, actionLabel)
      .then(() => {
        setInput("existing_model_name", "");
        setInput("existing_model_context_window", "");
        setInput("existing_model_max_tokens", "");
        setInput("existing_set_as_primary", false);
        setSelectValueWithCustom("existing_model_id", "existing_model_id_custom", nextModel.id);
        setModelAddSaveStatus("save_provider_existing_status", "配置完成，模型已成功写入。", "ok");
      })
      .catch((error) => {
        setModelAddSaveStatus("save_provider_existing_status", `保存失败：${error.message || String(error)}`, "error");
        setMessage(error.message || String(error), "error");
      });
  });

  document.querySelector("#save_provider_custom")?.addEventListener("click", () => {
    const providerId = String(getInputValue("custom_provider_id") || "").trim();
    const providerApi = getSelectValueWithCustom("custom_api", "custom_api_custom");
    const providerBaseUrl = String(getInputValue("custom_base_url") || "").trim();
    const providerApiKey = String(getInputValue("custom_api_key") || "").trim();
    const modelId = getSelectValueWithCustom("custom_model_id", "custom_model_id_custom");
    const modelNameInput = String(getInputValue("custom_model_name") || "").trim();
    let contextWindowInput;
    let maxTokensInput;
    try {
      contextWindowInput = parseOptionalPositiveIntInput(getInputValue("custom_model_context_window"), "上下文长度");
      maxTokensInput = parseOptionalPositiveIntInput(getInputValue("custom_model_max_tokens"), "最大输出长度");
    } catch (error) {
      setMessage(error.message || String(error), "error");
      return;
    }

    if (!providerId || !providerApi || !providerBaseUrl || !modelId) {
      setMessage("自定义配置不完整，请至少填写提供商名称 / API 模式 / URL / 模型 ID", "error");
      return;
    }

    const defaultModelFallback = toModelFallbackFromDefaultEntry(buildDefaultModelEntry(modelId, modelNameInput || modelId));
    const fallbackModel = {
      ...defaultModelFallback,
      id: modelId,
      name: modelNameInput || defaultModelFallback.name || modelId
    };
    const nextModel = normalizeModelDraft(
      {
        id: modelId,
        name: modelNameInput || fallbackModel.name,
        contextWindow: contextWindowInput,
        maxTokens: maxTokensInput
      },
      fallbackModel
    );
    if (!nextModel) {
      setMessage("模型信息无效，请检查模型 ID", "error");
      return;
    }

    const targetPrimaryRef = `${providerId}/${nextModel.id}`;
    const primaryRef = resolveProviderSavePrimaryRef(targetPrimaryRef, "custom_set_as_primary");
    if (!primaryRef) {
      setMessage("无法确定默认模型指向，请先在路径 1 设置默认模型或勾选“保存后设为当前默认模型”", "error");
      return;
    }

    const payload = buildModelPayload({
      primary: primaryRef,
      providerId,
      providerApi,
      providerBaseUrl,
      providerApiKey,
      modelId: nextModel.id,
      modelName: nextModel.name || nextModel.id,
      contextWindow: nextModel.contextWindow,
      maxTokens: nextModel.maxTokens,
      providerModels: [nextModel]
    });
    const shouldSwitchPrimary = Boolean(getInputValue("custom_set_as_primary"));
    const actionLabel = shouldSwitchPrimary ? "供应商与模型已写入，默认模型已切换" : "供应商与模型已写入（默认模型未变）";
    setModelAddSaveStatus("save_provider_custom_status", "正在保存配置...", "working");
    saveModelSettings(payload, actionLabel)
      .then(() => {
        setInput("custom_model_name", "");
        setInput("custom_model_context_window", "");
        setInput("custom_model_max_tokens", "");
        setInput("custom_set_as_primary", false);
        setModelAddSaveStatus("save_provider_custom_status", "配置完成，模型已成功写入。", "ok");
      })
      .catch((error) => {
        setModelAddSaveStatus("save_provider_custom_status", `保存失败：${error.message || String(error)}`, "error");
        setMessage(error.message || String(error), "error");
      });
  });

  renderTemplatePreset(String(getInputValue("model_template_key") || "aicodecat-gpt"));
  setModelAddWorkspaceVisible(false);
}


let saveModelSettingsHandler = null;

function setSaveModelSettingsHandler(handler) {
  saveModelSettingsHandler = typeof handler === "function" ? handler : null;
}

async function saveModelSettings(...args) {
  if (!saveModelSettingsHandler) {
    throw new Error("saveModelSettings handler 未设置");
  }
  return saveModelSettingsHandler(...args);
}

export {
  fillModelEditor,
  fillDashboardQuickSwitch,
  loadStatusOverview,
  renderDashboardModelCards,
  renderModelSummary,
  setupDashboard,
  setupModelEditor,
  setSaveModelSettingsHandler,
  updateDashboardErrorSummary,
  updateDashboardVersionSummary
};
</file>

<file path="public/pages/chat-console.html">
<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>OpenClaw 龙虾控制台</title>
        <script>
      (function initThemeEarly() {
        var theme = "light";
        try {
          var saved = window.localStorage.getItem("openclaw-panel-theme");
          theme = saved === "dark" ? "dark" : "light";
        } catch (_error) {
          theme = "light";
        }
        var root = document.documentElement;
        root.dataset.theme = theme;
        root.classList.toggle("sl-theme-dark", theme === "dark");
        root.classList.toggle("sl-theme-light", theme !== "dark");
      })();
    </script>    <link rel="stylesheet" href="/shoelace/themes/light.css" />
    <link rel="stylesheet" href="/shoelace/themes/dark.css" />
    <link rel="stylesheet" href="/styles.css" />
    <script type="module" src="/shoelace/shoelace-autoloader.js"></script>
  </head>
  <body data-theme="light">
    <div class="layout">
      <aside class="sidebar">
        <div class="brand">
          <p class="eyebrow">OpenClaw</p>
          <h1>龙虾控制台</h1>
          <p class="sub">管理你的 AI 助手：模型、渠道、技能，一站搞定。</p>
        </div>

                <nav class="tabs sidebar-tabs">
          <a class="tab" data-tab-target="panel-dashboard" href="/dashboard">仪表盘</a>
          <a class="tab" data-tab-target="panel-model" href="/model">模型配置</a>
          <a class="tab is-active" data-tab-target="panel-chat-console" href="/chat-console">智能对话</a>
          <a class="tab" data-tab-target="panel-skills" href="/skills">技能管理</a>
          <a class="tab" data-tab-target="panel-config-generator" href="/config-generator">配置生成器</a>
          <a class="tab" data-tab-target="panel-channel" href="/channels">平台接入</a>
          <a class="tab" data-tab-target="panel-update" href="/update">版本更新</a>
          <a class="tab" data-tab-target="panel-service" href="/service">服务控制</a>
          <a class="tab" data-tab-target="panel-logs" href="/logs">运行日志</a>
        </nav>
      </aside>

      <main class="content">
        <header class="page-header">
          <div>
            <h2 class="page-title">龙虾控制台</h2>
            <p class="page-subtitle">你的 AI 助手管理中心</p>
          </div>
          <button id="theme_toggle" class="btn-soft" type="button">切换到深夜模式</button>
        </header>

<section class="panel is-visible" data-panel="panel-chat-console">
          <article class="card">
            <h2>智能对话</h2>
            <p class="muted-line">和 AI 助手对话</p>

            <div class="chat-workspace">
              <!-- 顶栏：会话选择 + 新建（最高频操作） -->
              <div class="chat-topbar">
                <div class="actions" style="flex:1;min-width:0">
                  <label style="flex:1;min-width:160px;margin:0">
                    当前会话
                    <select id="chat_session_select"></select>
                  </label>
                  <button id="chat_new_session" type="button">新建会话</button>
                  <button id="chat_refresh_sessions" class="btn-soft" type="button">刷新会话</button>
                </div>
              </div>

              <!-- sr-only 隐藏字段（保留 DOM ID） -->
              <div class="sr-only">
                <label>
                  最近任务 ID
                  <input id="chat_last_run_id" type="text" readonly />
                </label>
                <label>
                  实时通道状态
                  <input id="chat_stream_status" type="text" readonly />
                </label>
              </div>

              <!-- 消息区域（视觉焦点） -->
              <div id="chat_messages" class="chat-messages">
                <div class="chat-empty">选择或新建会话，开始对话</div>
              </div>

              <!-- 输入区域 -->
              <label>
                输入消息
                <textarea id="chat_message_input" rows="3" placeholder="输入消息后按 Enter 发送，Shift+Enter 换行"></textarea>
              </label>

              <!-- 附件区域（紧凑） -->
              <div class="actions">
                <button id="chat_pick_files" class="btn-soft" type="button">添加附件</button>
                <input id="chat_file_input" type="file" multiple hidden />
                <span id="chat_attachment_hint" class="muted-line" style="margin:0">支持上传、粘贴或拖拽</span>
              </div>
              <div id="chat_attachment_list" class="chat-attachment-list">
              </div>

              <!-- 主操作栏：发送最醒目 -->
              <div class="actions">
                <button id="chat_send_message" type="button">发送消息</button>
                <button id="chat_abort_run" class="btn-soft" type="button">停止回复</button>
                <button id="chat_reset_session" class="btn-soft" type="button">清空对话</button>
              </div>
              <p id="chat_inline_hint" class="muted-line chat-inline-hint"></p>

              <!-- 思考模式设置（次要，折叠） -->
              <details class="chat-debug">
                <summary>思考模式设置</summary>
                <div class="actions" style="margin-top:8px">
                  <label class="inline-check">
                    显示思考过程
                    <input id="chat_show_thinking" type="checkbox" checked />
                  </label>
                  <label style="min-width:120px">
                    回答深度
                    <select id="chat_thinking_level">
                      <option value="">自动</option>
                      <option value="minimal">简略</option>
                      <option value="low">较少</option>
                      <option value="medium">适中</option>
                      <option value="high">深入</option>
                    </select>
                  </label>
                </div>
              </details>

              <!-- 排障工具（低频，折叠） -->
              <details class="chat-debug">
                <summary>遇到问题？点这里排查</summary>
                <div class="grid">
                  <label class="sr-only">
                    幂等键（可选）
                    <input id="chat_idempotency_key" type="text" placeholder="留空自动生成" />
                  </label>
                </div>
                <div class="actions">
                  <button id="chat_load_history" class="btn-soft" type="button">刷新历史</button>
                  <button id="chat_reconnect_stream" class="btn-soft" type="button">重新连接</button>
                </div>
                <label>
                  对话历史（原始）
                  <pre id="chat_history_output" class="output">请选择会话后加载历史</pre>
                </label>
                <label>
                  实时数据流（原始）
                  <pre id="chat_stream_output" class="output">等待流式事件...</pre>
                </label>
              </details>
            </div>
          </article>
        </section>

        <section class="card">
          <h2>操作记录</h2>
          <p class="muted-line">每次操作的结果都会记录在这里，方便排查问题。</p>
          <pre id="messages" class="output"></pre>
        </section>
      </main>
    </div>

    <script type="module" src="/app.js"></script>
  </body>
</html>
</file>

<file path="public/pages/logs.html">
<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>OpenClaw 龙虾控制台</title>
        <script>
      (function initThemeEarly() {
        var theme = "light";
        try {
          var saved = window.localStorage.getItem("openclaw-panel-theme");
          theme = saved === "dark" ? "dark" : "light";
        } catch (_error) {
          theme = "light";
        }
        var root = document.documentElement;
        root.dataset.theme = theme;
        root.classList.toggle("sl-theme-dark", theme === "dark");
        root.classList.toggle("sl-theme-light", theme !== "dark");
      })();
    </script>    <link rel="stylesheet" href="/shoelace/themes/light.css" />
    <link rel="stylesheet" href="/shoelace/themes/dark.css" />
    <link rel="stylesheet" href="/styles.css" />
    <script type="module" src="/shoelace/shoelace-autoloader.js"></script>
  </head>
  <body data-theme="light">
    <div class="layout">
      <aside class="sidebar">
        <div class="brand">
          <p class="eyebrow">OpenClaw</p>
          <h1>龙虾控制台</h1>
          <p class="sub">管理你的 AI 助手：模型、渠道、技能，一站搞定。</p>
        </div>

                <nav class="tabs sidebar-tabs">
          <a class="tab" data-tab-target="panel-dashboard" href="/dashboard">仪表盘</a>
          <a class="tab" data-tab-target="panel-model" href="/model">模型配置</a>
          <a class="tab" data-tab-target="panel-chat-console" href="/chat-console">智能对话</a>
          <a class="tab" data-tab-target="panel-skills" href="/skills">技能管理</a>
          <a class="tab" data-tab-target="panel-config-generator" href="/config-generator">配置生成器</a>
          <a class="tab" data-tab-target="panel-channel" href="/channels">平台接入</a>
          <a class="tab" data-tab-target="panel-update" href="/update">版本更新</a>
          <a class="tab" data-tab-target="panel-service" href="/service">服务控制</a>
          <a class="tab is-active" data-tab-target="panel-logs" href="/logs">运行日志</a>
        </nav>
      </aside>

      <main class="content">
        <header class="page-header">
          <div>
            <h2 class="page-title">龙虾控制台</h2>
            <p class="page-subtitle">你的 AI 助手管理中心</p>
          </div>
          <button id="theme_toggle" class="btn-soft" type="button">切换到深夜模式</button>
        </header>

<section class="panel is-visible" data-panel="panel-logs">
          <article class="card">
            <h2>运行记录</h2>
            <p class="muted-line">查看机器人的运行记录，排查问题时用。</p>
            <div class="actions">
              <label class="filter">
                搜索日志
                <input id="log_filter" type="text" placeholder="输入关键词筛选，比如 error、timeout" />
              </label>
              <button id="load_tail">查看最近记录</button>
              <button id="load_errors" class="btn-soft">只看错误</button>
              <button id="start_stream" class="btn-soft">实时跟踪</button>
              <button id="stop_stream" class="btn-soft">停止跟踪</button>
            </div>
            <pre id="log_output" class="output"></pre>
            <h3 style="margin-top:16px;">最近错误</h3>
            <ul id="error_summary" class="error-list"></ul>
          </article>
        </section>

        <section class="card">
          <h2>操作记录</h2>
          <p class="muted-line">每次点击后的结果都会记录在这里，方便你定位问题。</p>
          <pre id="messages" class="output"></pre>
        </section>
      </main>
    </div>

    <script type="module" src="/app.js"></script>
  </body>
</html>
</file>

<file path="public/pages/service.html">
<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>OpenClaw 龙虾控制台</title>
        <script>
      (function initThemeEarly() {
        var theme = "light";
        try {
          var saved = window.localStorage.getItem("openclaw-panel-theme");
          theme = saved === "dark" ? "dark" : "light";
        } catch (_error) {
          theme = "light";
        }
        var root = document.documentElement;
        root.dataset.theme = theme;
        root.classList.toggle("sl-theme-dark", theme === "dark");
        root.classList.toggle("sl-theme-light", theme !== "dark");
      })();
    </script>    <link rel="stylesheet" href="/shoelace/themes/light.css" />
    <link rel="stylesheet" href="/shoelace/themes/dark.css" />
    <link rel="stylesheet" href="/styles.css" />
    <script type="module" src="/shoelace/shoelace-autoloader.js"></script>
    <style>
      .service-status-hero {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 8px;
        padding: 28px 16px 20px;
      }

      .service-status-hero .pill {
        font-size: 18px;
        font-weight: 700;
        padding: 10px 28px;
        letter-spacing: 0.02em;
      }

      .service-hint-text {
        margin: 0;
        color: var(--muted);
        font-size: 13px;
        text-align: center;
      }

      .service-page-intro {
        margin: 0;
        color: var(--muted);
        font-size: 13px;
        text-align: center;
        padding-bottom: 4px;
      }

      .service-actions-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        gap: 10px;
      }

      .service-actions-grid button {
        padding: 12px 16px;
        font-size: 14px;
      }

      .btn-danger-soft {
        background: var(--soft-button);
        border-color: var(--danger);
        color: var(--danger);
      }

      .btn-danger-soft:hover {
        background: #fef2f2;
      }

      body[data-theme="dark"] .btn-danger-soft:hover {
        background: #2a1515;
      }

      .service-output-section h3 {
        margin: 0 0 4px;
        font-size: 15px;
        font-weight: 600;
      }

      .service-output-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 8px;
      }

      .service-output-header button {
        font-size: 12px;
        padding: 4px 10px;
      }
    </style>
  </head>
  <body data-theme="light">
    <div class="layout">
      <aside class="sidebar">
        <div class="brand">
          <p class="eyebrow">OpenClaw</p>
          <h1>龙虾控制台</h1>
          <p class="sub">管理你的 AI 助手：模型、渠道、技能，一站搞定。</p>
        </div>

                <nav class="tabs sidebar-tabs">
          <a class="tab" data-tab-target="panel-dashboard" href="/dashboard">仪表盘</a>
          <a class="tab" data-tab-target="panel-model" href="/model">模型配置</a>
          <a class="tab" data-tab-target="panel-chat-console" href="/chat-console">智能对话</a>
          <a class="tab" data-tab-target="panel-skills" href="/skills">技能管理</a>
          <a class="tab" data-tab-target="panel-config-generator" href="/config-generator">配置生成器</a>
          <a class="tab" data-tab-target="panel-channel" href="/channels">平台接入</a>
          <a class="tab" data-tab-target="panel-update" href="/update">版本更新</a>
          <a class="tab is-active" data-tab-target="panel-service" href="/service">服务控制</a>
          <a class="tab" data-tab-target="panel-logs" href="/logs">运行日志</a>
        </nav>
      </aside>

      <main class="content">
        <header class="page-header">
          <div>
            <h2 class="page-title">龙虾控制台</h2>
            <p class="page-subtitle">你的 AI 助手管理中心</p>
          </div>
          <button id="theme_toggle" class="btn-soft" type="button">切换到深夜模式</button>
        </header>

<section class="panel is-visible" data-panel="panel-service">
          <!-- 状态区：视觉焦点 -->
          <article class="card">
            <h2>服务控制</h2>
            <p class="service-page-intro">在这里检查服务状态，并执行启动、停止、重启操作。</p>
            <div class="service-status-hero">
              <span class="pill" id="service_state">还没检查</span>
              <p class="service-hint-text" id="service_hint">页面会自动刷新一次状态，你也可以随时点击“刷新状态”</p>
            </div>

            <!-- 操作按钮 -->
            <div class="service-actions-grid">
              <button class="btn-soft" data-action="status">刷新状态</button>
              <button data-action="start">启动服务</button>
              <button class="btn-danger-soft" data-action="stop">停止服务</button>
              <button class="btn-soft" data-action="restart">重启服务</button>
            </div>
          </article>

          <!-- 运行信息 -->
          <article class="card">
            <div class="service-output-section">
              <div class="service-output-header">
                <h3>运行信息</h3>
                <button class="btn-soft" onclick="document.getElementById('service_output').textContent=''">清空</button>
              </div>
              <pre id="service_output" class="output"></pre>
            </div>
          </article>
        </section>

        <!-- 操作记录 -->
        <section class="card">
          <h2>操作记录</h2>
          <p class="muted-line">每次操作的结果都会记录在这里，方便你回头查看。</p>
          <pre id="messages" class="output"></pre>
        </section>
      </main>
    </div>

    <script type="module" src="/app.js"></script>
  </body>
</html>
</file>

<file path="public/pages/skills.html">
<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>OpenClaw 龙虾控制台</title>
        <script>
      (function initThemeEarly() {
        var theme = "light";
        try {
          var saved = window.localStorage.getItem("openclaw-panel-theme");
          theme = saved === "dark" ? "dark" : "light";
        } catch (_error) {
          theme = "light";
        }
        var root = document.documentElement;
        root.dataset.theme = theme;
        root.classList.toggle("sl-theme-dark", theme === "dark");
        root.classList.toggle("sl-theme-light", theme !== "dark");
      })();
    </script>    <link rel="stylesheet" href="/shoelace/themes/light.css" />
    <link rel="stylesheet" href="/shoelace/themes/dark.css" />
    <link rel="stylesheet" href="/styles.css" />
    <script type="module" src="/shoelace/shoelace-autoloader.js"></script>
  </head>
  <body data-theme="light">
    <div class="layout">
      <aside class="sidebar">
        <div class="brand">
          <p class="eyebrow">OpenClaw</p>
          <h1>龙虾控制台</h1>
          <p class="sub">管理你的 AI 助手：模型、渠道、技能，一站搞定。</p>
        </div>

                <nav class="tabs sidebar-tabs">
          <a class="tab" data-tab-target="panel-dashboard" href="/dashboard">仪表盘</a>
          <a class="tab" data-tab-target="panel-model" href="/model">模型配置</a>
          <a class="tab" data-tab-target="panel-chat-console" href="/chat-console">智能对话</a>
          <a class="tab is-active" data-tab-target="panel-skills" href="/skills">技能管理</a>
          <a class="tab" data-tab-target="panel-config-generator" href="/config-generator">配置生成器</a>
          <a class="tab" data-tab-target="panel-channel" href="/channels">平台接入</a>
          <a class="tab" data-tab-target="panel-update" href="/update">版本更新</a>
          <a class="tab" data-tab-target="panel-service" href="/service">服务控制</a>
          <a class="tab" data-tab-target="panel-logs" href="/logs">运行日志</a>
        </nav>
      </aside>

      <main class="content">
        <header class="page-header">
          <div>
            <h2 class="page-title">龙虾控制台</h2>
            <p class="page-subtitle">你的 AI 助手管理中心</p>
          </div>
          <button id="theme_toggle" class="btn-soft" type="button">切换到深夜模式</button>
        </header>

<section class="panel is-visible" data-panel="panel-skills">
          <!-- 板块一：技能总览 + 列表 -->
          <article class="card">
            <div class="dashboard-overview-row">
              <div>
                <h2 style="margin:0;">技能管理</h2>
                <p class="muted-line" style="margin-bottom:0;">管理 AI 技能的启停和配置</p>
              </div>
              <div class="actions">
                <button id="skills_refresh" class="btn-soft" type="button">刷新列表</button>
              </div>
            </div>
            <div class="dashboard-stat-row">
              <div class="dashboard-stat">
                <span class="dashboard-stat-label">总数</span>
                <span class="dashboard-stat-value"><input id="skills_total" type="text" readonly style="border:none;background:transparent;padding:0;font-size:inherit;font-weight:inherit;color:inherit;width:3em;" /></span>
              </div>
              <div class="dashboard-stat">
                <span class="dashboard-stat-label">已启用</span>
                <span class="dashboard-stat-value" style="color:var(--success);"><input id="skills_enabled" type="text" readonly style="border:none;background:transparent;padding:0;font-size:inherit;font-weight:inherit;color:inherit;width:3em;" /></span>
              </div>
              <div class="dashboard-stat">
                <span class="dashboard-stat-label">已禁用</span>
                <span class="dashboard-stat-value" style="color:var(--muted);"><input id="skills_disabled" type="text" readonly style="border:none;background:transparent;padding:0;font-size:inherit;font-weight:inherit;color:inherit;width:3em;" /></span>
              </div>
            </div>
            <div id="skills_list" class="stack-list"></div>
          </article>

          <!-- 板块二：调整技能设置 -->
          <article class="card">
            <h2>调整技能</h2>
            <p class="muted-line">选中上方的技能后，在这里修改设置。留空的项不会被改动。</p>
            <div class="grid">
              <label>
                启用状态
                <select id="skills_edit_enabled">
                  <option value="" selected>保持不变</option>
                  <option value="true">启用</option>
                  <option value="false">禁用</option>
                </select>
              </label>
              <label>
                密钥（留空不改）
                <input id="skills_edit_api_key" type="password" autocomplete="off" placeholder="输入新密钥（可选）" />
              </label>
              <label class="inline-check">
                清除当前密钥
                <input id="skills_edit_clear_api_key" type="checkbox" />
              </label>
            </div>
            <sl-details summary="高级设置：环境变量">
              <p class="muted-line" style="margin-top:8px;">每行写一个 KEY=VALUE。要删除某个变量，写 KEY= 即可。</p>
              <label>
                环境变量
                <textarea
                  id="skills_edit_env_patch"
                  rows="5"
                  placeholder="例如：&#10;HTTP_PROXY=http://127.0.0.1:7890&#10;OPENAI_BASE_URL=&#10;（第二行表示删除该变量）"
                ></textarea>
              </label>
            </sl-details>
            <div class="actions" style="margin-top:12px;">
              <button id="skills_save_config" type="button">保存设置</button>
            </div>
            <p id="skills_save_result" class="muted-line">请先选择一个技能，再修改设置。</p>
          </article>

          <!-- 板块三：技能配置详情（开发者，折叠） -->
          <article class="card">
            <sl-details summary="技能配置详情（高级）">
              <p class="muted-line" style="margin-top:8px;">选择上方的技能后，这里会显示详细配置（敏感字段已脱敏）。</p>
              <pre id="skills_config_preview" class="output">选择上方的技能后，这里会显示详细配置</pre>
            </sl-details>
          </article>
        </section>

        <!-- 操作记录 -->
        <section class="card">
          <h2>操作记录</h2>
          <p class="muted-line">每次操作的结果都会记录在这里。</p>
          <pre id="messages" class="output"></pre>
        </section>
      </main>
    </div>

    <script type="module" src="/app.js"></script>
  </body>
</html>
</file>

<file path="src/openclaw-config.js">
export { ensureOpenClawConfigPermissions, loadOpenClawConfig, saveOpenClawConfig } from "./openclaw-config/storage.js";
export { extractSettings } from "./openclaw-config/extract.js";
export { applySettings } from "./openclaw-config/apply.js";
export {
  removeModelFromCatalog,
  removeProviderFromCatalog,
  updateModelInCatalog,
  updateProviderInCatalog
} from "./openclaw-config/model-catalog.js";
export { openClawSettingsSchema } from "./openclaw-config/schema.js";
</file>

<file path="public/app-routes.js">
export const PANEL_ROUTES = {
  "panel-dashboard": "/dashboard",
  "panel-skills": "/skills",
  "panel-chat-console": "/chat-console",
  "panel-model": "/model",
  "panel-model-add": "/model/add",
  "panel-config-generator": "/config-generator",
  "panel-channel": "/channels",
  "panel-update": "/update",
  "panel-service": "/service",
  "panel-logs": "/logs"
};

const CHANNEL_DETAIL_ROUTES = ["/channels/telegram", "/channels/feishu", "/channels/discord", "/channels/slack"];

export function panelByPath(pathname) {
  const path = String(pathname || "").trim() || "/";
  if (path === "/") {
    return "panel-dashboard";
  }
  if (path === "/status-overview") {
    return "panel-dashboard";
  }
  if (CHANNEL_DETAIL_ROUTES.includes(path)) {
    return "panel-channel";
  }
  const matched = Object.entries(PANEL_ROUTES).find(([, route]) => route === path);
  return matched ? matched[0] : "panel-dashboard";
}

export function isKnownPanelPath(pathname) {
  const path = String(pathname || "").trim() || "/";
  return (
    path === "/" ||
    path === "/status-overview" ||
    Object.values(PANEL_ROUTES).includes(path) ||
    CHANNEL_DETAIL_ROUTES.includes(path)
  );
}
</file>

<file path="public/pages/channels.html">
<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>OpenClaw 龙虾控制台</title>
    <script>
      (function initThemeEarly() {
        var theme = "light";
        try {
          var saved = window.localStorage.getItem("openclaw-panel-theme");
          theme = saved === "dark" ? "dark" : "light";
        } catch (_error) {
          theme = "light";
        }
        var root = document.documentElement;
        root.dataset.theme = theme;
        root.classList.toggle("sl-theme-dark", theme === "dark");
        root.classList.toggle("sl-theme-light", theme !== "dark");
      })();
    </script>
    <link rel="stylesheet" href="/shoelace/themes/light.css" />
    <link rel="stylesheet" href="/shoelace/themes/dark.css" />
    <link rel="stylesheet" href="/styles.css" />
    <script type="module" src="/shoelace/shoelace-autoloader.js"></script>
    <style>
      .channel-access-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        gap: 14px;
        margin-top: 12px;
      }

      .channel-access-card {
        border: 1px solid var(--nested-card-border);
        border-radius: 12px;
        padding: 14px;
        background: var(--nested-card-bg);
        text-decoration: none;
        color: inherit;
        transition: border-color 0.2s ease, box-shadow 0.2s ease, transform 0.2s ease;
        display: grid;
        gap: 10px;
      }

      .channel-access-card:hover {
        border-color: var(--primary);
        transform: translateY(-1px);
      }

      .channel-access-card.is-disabled {
        cursor: not-allowed;
        opacity: 0.74;
        border-style: dashed;
      }

      .channel-access-card.is-disabled:hover {
        border-color: var(--border);
        transform: none;
        box-shadow: none;
      }

      .channel-access-card.is-ready {
        border-color: color-mix(in srgb, var(--primary) 32%, var(--border));
        box-shadow: 0 0 0 1px color-mix(in srgb, var(--primary) 15%, transparent);
      }

      .channel-access-card.is-partial {
        border-color: color-mix(in srgb, #f59e0b 45%, var(--border));
      }

      .channel-access-head {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 8px;
      }

      .channel-access-head h3 {
        margin: 0;
        font-size: 16px;
      }

      .channel-access-arrow {
        color: var(--muted);
        font-size: 16px;
      }

      .channel-access-tags {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
      }

      .channel-summary {
        margin: 0;
        color: var(--muted);
        font-size: 12px;
      }
    </style>
  </head>
  <body data-theme="light">
    <div class="layout">
      <aside class="sidebar">
        <div class="brand">
          <p class="eyebrow">OpenClaw</p>
          <h1>龙虾控制台</h1>
          <p class="sub">管理你的 AI 助手：模型、渠道、技能，一站搞定。</p>
        </div>

        <nav class="tabs sidebar-tabs">
          <a class="tab" data-tab-target="panel-dashboard" href="/dashboard">仪表盘</a>
          <a class="tab" data-tab-target="panel-model" href="/model">模型配置</a>
          <a class="tab" data-tab-target="panel-chat-console" href="/chat-console">智能对话</a>
          <a class="tab" data-tab-target="panel-skills" href="/skills">技能管理</a>
          <a class="tab" data-tab-target="panel-config-generator" href="/config-generator">配置生成器</a>
          <a class="tab is-active" data-tab-target="panel-channel" href="/channels">平台接入</a>
          <a class="tab" data-tab-target="panel-update" href="/update">版本更新</a>
          <a class="tab" data-tab-target="panel-service" href="/service">服务控制</a>
          <a class="tab" data-tab-target="panel-logs" href="/logs">运行日志</a>
        </nav>
      </aside>

      <main class="content">
        <header class="page-header">
          <div>
            <h2 class="page-title">龙虾控制台</h2>
            <p class="page-subtitle">你的 AI 助手管理中心</p>
          </div>
          <button id="theme_toggle" class="btn-soft" type="button">切换到深夜模式</button>
        </header>

        <section class="panel is-visible" data-panel="panel-channel">
          <article class="card">
            <h2>平台接入</h2>
            <p class="muted-line">先看状态，再点进对应平台补配置。你只需要关心“是否已配置”和“是否已启用”。</p>
            <div class="channel-access-grid">
              <a class="channel-access-card" data-channel-card="telegram" href="/channels/telegram">
                <div class="channel-access-head">
                  <h3>Telegram</h3>
                  <span class="channel-access-arrow">进入 →</span>
                </div>
                <div class="channel-access-tags">
                  <sl-tag id="channel_status_telegram_enabled" size="small" pill>未启用</sl-tag>
                  <sl-tag id="channel_status_telegram_configured" size="small" pill variant="warning">未配置</sl-tag>
                </div>
                <p class="channel-summary" id="channel_status_telegram_summary">点击进入配置页面</p>
              </a>

              <div class="channel-access-card is-disabled" data-channel-card="feishu" data-channel-disabled="true" aria-disabled="true">
                <div class="channel-access-head">
                  <h3>飞书</h3>
                  <span class="channel-access-arrow">暂未开放</span>
                </div>
                <div class="channel-access-tags">
                  <sl-tag id="channel_status_feishu_enabled" size="small" pill>未启用</sl-tag>
                  <sl-tag id="channel_status_feishu_configured" size="small" pill variant="warning">未配置</sl-tag>
                </div>
                <p class="channel-summary" id="channel_status_feishu_summary">功能开发中，暂不支持进入配置页。</p>
              </div>

              <div class="channel-access-card is-disabled" data-channel-card="discord" data-channel-disabled="true" aria-disabled="true">
                <div class="channel-access-head">
                  <h3>Discord</h3>
                  <span class="channel-access-arrow">暂未开放</span>
                </div>
                <div class="channel-access-tags">
                  <sl-tag id="channel_status_discord_enabled" size="small" pill>未启用</sl-tag>
                  <sl-tag id="channel_status_discord_configured" size="small" pill variant="warning">未配置</sl-tag>
                </div>
                <p class="channel-summary" id="channel_status_discord_summary">功能开发中，暂不支持进入配置页。</p>
              </div>

              <div class="channel-access-card is-disabled" data-channel-card="slack" data-channel-disabled="true" aria-disabled="true">
                <div class="channel-access-head">
                  <h3>Slack</h3>
                  <span class="channel-access-arrow">暂未开放</span>
                </div>
                <div class="channel-access-tags">
                  <sl-tag id="channel_status_slack_enabled" size="small" pill>未启用</sl-tag>
                  <sl-tag id="channel_status_slack_configured" size="small" pill variant="warning">未配置</sl-tag>
                </div>
                <p class="channel-summary" id="channel_status_slack_summary">功能开发中，暂不支持进入配置页。</p>
              </div>
            </div>
          </article>
        </section>

        <section class="card">
          <h2>操作记录</h2>
          <p class="muted-line">每次点击后的结果都会记录在这里，方便你定位问题。</p>
          <pre id="messages" class="output"></pre>
        </section>
      </main>
    </div>

    <script type="module" src="/app.js"></script>
  </body>
</html>
</file>

<file path="public/pages/config-generator.html">
<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>OpenClaw 龙虾控制台</title>
        <script>
      (function initThemeEarly() {
        var theme = "light";
        try {
          var saved = window.localStorage.getItem("openclaw-panel-theme");
          theme = saved === "dark" ? "dark" : "light";
        } catch (_error) {
          theme = "light";
        }
        var root = document.documentElement;
        root.dataset.theme = theme;
        root.classList.toggle("sl-theme-dark", theme === "dark");
        root.classList.toggle("sl-theme-light", theme !== "dark");
      })();
    </script>    <link rel="stylesheet" href="/shoelace/themes/light.css" />
    <link rel="stylesheet" href="/shoelace/themes/dark.css" />
    <link rel="stylesheet" href="/styles.css" />
    <script type="module" src="/shoelace/shoelace-autoloader.js"></script>
  </head>
  <body data-theme="light">
    <div class="layout">
      <aside class="sidebar">
        <div class="brand">
          <p class="eyebrow">OpenClaw</p>
          <h1>龙虾控制台</h1>
          <p class="sub">管理你的 AI 助手：模型、渠道、技能，一站搞定。</p>
        </div>

                <nav class="tabs sidebar-tabs">
          <a class="tab" data-tab-target="panel-dashboard" href="/dashboard">仪表盘</a>
          <a class="tab" data-tab-target="panel-model" href="/model">模型配置</a>
          <a class="tab" data-tab-target="panel-chat-console" href="/chat-console">智能对话</a>
          <a class="tab" data-tab-target="panel-skills" href="/skills">技能管理</a>
          <a class="tab is-active" data-tab-target="panel-config-generator" href="/config-generator">配置生成器</a>
          <a class="tab" data-tab-target="panel-channel" href="/channels">平台接入</a>
          <a class="tab" data-tab-target="panel-update" href="/update">版本更新</a>
          <a class="tab" data-tab-target="panel-service" href="/service">服务控制</a>
          <a class="tab" data-tab-target="panel-logs" href="/logs">运行日志</a>
        </nav>
      </aside>

      <main class="content">
        <header class="page-header">
          <div>
            <h2 class="page-title">龙虾控制台</h2>
            <p class="page-subtitle">你的 AI 助手管理中心</p>
          </div>
          <button id="theme_toggle" class="btn-soft" type="button">切换到深夜模式</button>
        </header>

<section class="panel is-visible" data-panel="panel-config-generator">
          <article class="card config-generator-card">
            <h2>配置生成器</h2>
            <p class="muted-line">这个工具用于手动生成配置文件。如果你只是想切换模型，请去「模型配置」页面。</p>

            <div class="grid">
              <label>
                AI 服务商
                <div class="field-stack">
                  <select id="cfg_provider">
                    <option value="aicodecat">aicodecat</option>
                    <option value="custom">自定义</option>
                  </select>
                  <input id="cfg_provider_custom" class="custom-field" type="text" placeholder="输入自定义服务商 ID" />
                </div>
              </label>

              <label>
                API 协议
                <div class="field-stack">
                  <select id="cfg_apimode">
                    <option value="anthropic-messages">anthropic-messages（Claude）</option>
                    <option value="openai-responses" selected>openai-responses（GPT）</option>
                    <option value="openai-completions">openai-completions（GPT 兼容）</option>
                    <option value="google-generative-ai">google-generative-ai（Gemini）</option>
                    <option value="custom">自定义</option>
                  </select>
                  <input id="cfg_apimode_custom" class="custom-field" type="text" placeholder="输入自定义 API 模式" />
                </div>
              </label>
            </div>

            <div class="grid">
              <label>
                API 地址
                <div class="field-stack">
                  <select id="cfg_baseurl">
                    <option value="https://aicode.cat/v1" selected>https://aicode.cat/v1 (GPT)</option>
                    <option value="https://aicode.cat">https://aicode.cat (Claude)</option>
                    <option value="https://aicode.cat/v1beta">https://aicode.cat/v1beta (Gemini)</option>
                    <option value="custom">自定义</option>
                  </select>
                  <input id="cfg_baseurl_custom" class="custom-field" type="url" placeholder="输入自定义 Base URL" />
                </div>
              </label>

              <label>
                模型标识
                <div class="field-stack">
                  <select id="cfg_model_id"></select>
                  <input id="cfg_model_id_custom" class="custom-field" type="text" placeholder="输入自定义模型标识" />
                </div>
              </label>
            </div>

            <div class="grid">
              <label>
                API 密钥
                <div class="cfg-secret-field">
                  <input id="cfg_apikey" type="password" autocomplete="off" placeholder="输入 API 密钥" />
                  <button id="cfg_apikey_toggle" class="btn-soft cfg-secret-toggle" type="button" aria-label="显示 API 密钥" title="显示 API 密钥">
                    👁
                  </button>
                </div>
              </label>
              <label>
                模型最大上下文
                <input id="cfg_context_window" type="number" min="1" step="1" placeholder="例如 400000" />
              </label>
              <label>
                最大输出内容
                <input id="cfg_max_tokens" type="number" min="1" step="1" placeholder="例如 128000" />
              </label>
              <label class="inline-check">
                开启推理
                <input id="cfg_reasoning" type="checkbox" />
              </label>
              <label>
                合并到现有配置
                <select id="cfg_inherit_existing">
                  <option value="false" selected>否，生成全新配置</option>
                  <option value="true">是，保留现有配置的其他设置</option>
                </select>
              </label>
              <label>
                状态
                <input id="cfg_status" type="text" value="就绪" readonly />
              </label>
            </div>

            <label>
              当前配置（粘贴你的 openclaw.json）
              <textarea id="cfg_input" rows="8" placeholder="粘贴你的 ~/.openclaw/openclaw.json"></textarea>
            </label>

            <div class="actions">
              <button id="cfg_generate" type="button">生成配置</button>
              <button id="cfg_copy" class="btn-soft" type="button">复制结果</button>
            </div>

            <label>
              生成的配置
              <pre id="cfg_output" class="output">点击「生成配置」后结果会显示在这里</pre>
            </label>
          </article>
        </section>

        <section class="card">
          <h2>操作记录</h2>
          <p class="muted-line">每次点击后的结果都会记录在这里，方便你定位问题。</p>
          <pre id="messages" class="output"></pre>
        </section>
      </main>
    </div>

    <script type="module" src="/app.js"></script>
  </body>
</html>
</file>

<file path="public/pages/model.html">
<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>OpenClaw 龙虾控制台</title>
        <script>
      (function initThemeEarly() {
        var theme = "light";
        try {
          var saved = window.localStorage.getItem("openclaw-panel-theme");
          theme = saved === "dark" ? "dark" : "light";
        } catch (_error) {
          theme = "light";
        }
        var root = document.documentElement;
        root.dataset.theme = theme;
        root.classList.toggle("sl-theme-dark", theme === "dark");
        root.classList.toggle("sl-theme-light", theme !== "dark");
      })();
    </script>    <link rel="stylesheet" href="/shoelace/themes/light.css" />
    <link rel="stylesheet" href="/shoelace/themes/dark.css" />
    <link rel="stylesheet" href="/styles.css" />
    <script type="module" src="/shoelace/shoelace-autoloader.js"></script>
  </head>
  <body data-theme="light">
    <div class="layout">
      <aside class="sidebar">
        <div class="brand">
          <p class="eyebrow">OpenClaw</p>
          <h1>龙虾控制台</h1>
          <p class="sub">管理你的 AI 助手：模型、渠道、技能，一站搞定。</p>
        </div>

                <nav class="tabs sidebar-tabs">
          <a class="tab" data-tab-target="panel-dashboard" href="/dashboard">仪表盘</a>
          <a class="tab is-active" data-tab-target="panel-model" href="/model">模型配置</a>
          <a class="tab" data-tab-target="panel-chat-console" href="/chat-console">智能对话</a>
          <a class="tab" data-tab-target="panel-skills" href="/skills">技能管理</a>
          <a class="tab" data-tab-target="panel-config-generator" href="/config-generator">配置生成器</a>
          <a class="tab" data-tab-target="panel-channel" href="/channels">平台接入</a>
          <a class="tab" data-tab-target="panel-update" href="/update">版本更新</a>
          <a class="tab" data-tab-target="panel-service" href="/service">服务控制</a>
          <a class="tab" data-tab-target="panel-logs" href="/logs">运行日志</a>
        </nav>
      </aside>

      <main class="content">
        <header class="page-header">
          <div>
            <h2 class="page-title">龙虾控制台</h2>
            <p class="page-subtitle">你的 AI 助手管理中心</p>
          </div>
          <button id="theme_toggle" class="btn-soft" type="button">切换到深夜模式</button>
        </header>

<section class="panel is-visible" data-panel="panel-model">
          <div class="sr-only" aria-hidden="true">
            <label>
              正在使用
              <select id="model_default_ref"></select>
            </label>
          </div>

          <article class="card model-overview-card">
            <div class="model-overview-head">
              <div>
                <h2>当前已配置模型</h2>
                <p class="muted-line">按提供商分组显示。点击模型卡片可编辑，支持删除模型或整个供应商。</p>
              </div>
              <a
                id="model_add_toggle"
                class="model-add-toggle model-add-toggle-primary"
                href="/model/add"
                title="添加新模型"
                aria-label="添加新模型"
              >
                添加新模型
              </a>
            </div>
            <sl-details summary="切换风险提示（可选）">
              <div class="grid">
                <label>
                  当前会话上下文 token（可选）
                  <input
                    id="dashboard_context_tokens"
                    data-dashboard-context-input="1"
                    type="number"
                    min="0"
                    step="1"
                    placeholder="不填则按保守策略提醒"
                  />
                </label>
              </div>
              <p id="dashboard_context_hint" class="muted-line">切换到更小上下文模型时，若会话过长会先给出风险确认。</p>
            </sl-details>
            <div id="model_provider_cards" class="model-provider-groups"></div>
          </article>

          <article class="card model-raw-config-card">
            <h2>当前龙虾 Bot 配置文件（实时 JSON）</h2>
            <p class="muted-line model-raw-config-meta">
              最后同步：<span id="model_raw_config_mtime">-</span> · 大小：<span id="model_raw_config_size">-</span>
            </p>
            <label>
              配置 JSON
              <textarea id="model_raw_config_editor" class="model-raw-config-editor" rows="18" spellcheck="false"></textarea>
            </label>
            <div class="actions">
              <button id="model_raw_config_reload" class="btn-soft" type="button">刷新真实配置</button>
              <button id="model_raw_config_save" type="button">保存到配置文件</button>
            </div>
            <p id="model_raw_config_status" class="muted-line model-raw-config-status">尚未加载配置文件。</p>
          </article>

          <sl-dialog id="model_provider_edit_dialog" label="编辑供应商">
            <div class="model-dialog-grid">
              <label>
                供应商名称
                <input id="model_provider_edit_id" type="text" />
              </label>
              <label>
                API 模式
                <input id="model_provider_edit_api" type="text" placeholder="例如 openai-responses" />
              </label>
              <label>
                API 地址
                <input id="model_provider_edit_baseurl" type="url" placeholder="例如 https://api.example.com/v1" />
              </label>
              <label>
                API 密钥（可选）
                <input id="model_provider_edit_apikey" type="password" autocomplete="off" placeholder="留空表示不修改" />
              </label>
            </div>
            <p class="muted-line model-dialog-hint">修改供应商名称后，该供应商下所有模型引用会自动迁移。</p>
            <div slot="footer" class="actions">
              <button id="model_provider_edit_cancel" class="btn-soft" type="button">取消</button>
              <button id="model_provider_edit_submit" type="button">保存</button>
            </div>
          </sl-dialog>

          <sl-dialog id="model_item_edit_dialog" label="编辑模型">
            <div class="model-dialog-grid">
              <label>
                所属供应商
                <input id="model_item_edit_provider" type="text" readonly />
              </label>
              <label>
                模型 ID
                <input id="model_item_edit_id" type="text" />
              </label>
              <label>
                模型名称
                <input id="model_item_edit_name" type="text" />
              </label>
              <label>
                最大上下文
                <input id="model_item_edit_context_window" type="number" min="1" step="1" placeholder="例如 200000" />
              </label>
              <label>
                最大输出
                <input id="model_item_edit_max_tokens" type="number" min="1" step="1" placeholder="例如 8192" />
              </label>
            </div>
            <div slot="footer" class="actions">
              <button id="model_item_edit_cancel" class="btn-soft" type="button">取消</button>
              <button id="model_item_edit_submit" type="button">保存</button>
            </div>
          </sl-dialog>
        </section>

        <section class="card">
          <h2>操作记录</h2>
          <p class="muted-line">每次操作的结果都会记录在这里。</p>
          <pre id="messages" class="output"></pre>
        </section>
      </main>
    </div>

    <script type="module" src="/app.js"></script>
  </body>
</html>
</file>

<file path="public/pages/dashboard.html">
<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>OpenClaw 龙虾控制台</title>
        <script>
      (function initThemeEarly() {
        var theme = "light";
        try {
          var saved = window.localStorage.getItem("openclaw-panel-theme");
          theme = saved === "dark" ? "dark" : "light";
        } catch (_error) {
          theme = "light";
        }
        var root = document.documentElement;
        root.dataset.theme = theme;
        root.classList.toggle("sl-theme-dark", theme === "dark");
        root.classList.toggle("sl-theme-light", theme !== "dark");
      })();
    </script>    <link rel="stylesheet" href="/shoelace/themes/light.css" />
    <link rel="stylesheet" href="/shoelace/themes/dark.css" />
    <link rel="stylesheet" href="/styles.css" />
    <script type="module" src="/shoelace/shoelace-autoloader.js"></script>
  </head>
  <body data-theme="light">
    <div class="layout">
      <aside class="sidebar">
        <div class="brand">
          <p class="eyebrow">OpenClaw</p>
          <h1>龙虾控制台</h1>
          <p class="sub">管理你的 AI 助手：模型、渠道、技能，一站搞定。</p>
        </div>

                <nav class="tabs sidebar-tabs">
          <a class="tab is-active" data-tab-target="panel-dashboard" href="/dashboard">仪表盘</a>
          <a class="tab" data-tab-target="panel-model" href="/model">模型配置</a>
          <a class="tab" data-tab-target="panel-chat-console" href="/chat-console">智能对话</a>
          <a class="tab" data-tab-target="panel-skills" href="/skills">技能管理</a>
          <a class="tab" data-tab-target="panel-config-generator" href="/config-generator">配置生成器</a>
          <a class="tab" data-tab-target="panel-channel" href="/channels">平台接入</a>
          <a class="tab" data-tab-target="panel-update" href="/update">版本更新</a>
          <a class="tab" data-tab-target="panel-service" href="/service">服务控制</a>
          <a class="tab" data-tab-target="panel-logs" href="/logs">运行日志</a>
        </nav>
      </aside>

      <main class="content">
        <header class="page-header">
          <div>
            <h2 class="page-title">龙虾控制台</h2>
            <p class="page-subtitle">你的 AI 助手管理中心</p>
          </div>
          <button id="theme_toggle" class="btn-soft" type="button">切换到深夜模式</button>
        </header>

<section class="panel is-visible" data-panel="panel-dashboard">
          <!-- ① 健康状态栏（原仪表盘总览，扁平化） -->
          <article class="card dashboard-overview-card">
            <div class="dashboard-overview-row">
              <div>
                <h2 class="dashboard-hero-status">
                  <span class="dot"></span>
                  <span id="runtime_state">面板已连接</span>
                  <span class="dashboard-hero-model" id="dashboard_hero_model"></span>
                </h2>
              </div>
              <div class="actions dashboard-overview-actions">
                <sl-button id="dashboard_summary_refresh" variant="primary" size="small">刷新总览</sl-button>
              </div>
            </div>
            <!-- 技术元数据：保留 ID，对小白隐藏 -->
            <div class="sr-only" aria-hidden="true">
              <span id="meta_service_name">service: -</span>
              <span id="meta_log_source">log: -</span>
            </div>
            <div class="dashboard-stat-row">
              <div class="dashboard-stat">
                <span class="dashboard-stat-label">运行状态</span>
                <span id="dashboard_summary_runtime" class="dashboard-stat-value">-</span>
                <span id="dashboard_summary_runtime_meta" class="sr-only">等待刷新</span>
              </div>
              <div class="dashboard-stat">
                <span class="dashboard-stat-label">当前模型</span>
                <span id="dashboard_summary_model" class="dashboard-stat-value">-</span>
                <span id="dashboard_summary_model_meta" class="sr-only">等待刷新</span>
              </div>
              <div class="dashboard-stat">
                <span class="dashboard-stat-label">渠道</span>
                <span id="dashboard_summary_channels" class="dashboard-stat-value">-</span>
                <span id="dashboard_summary_channels_meta" class="sr-only">等待刷新</span>
              </div>
              <div class="dashboard-stat">
                <span class="dashboard-stat-label">技能</span>
                <span id="dashboard_summary_skills" class="dashboard-stat-value">-</span>
                <span id="dashboard_summary_skills_meta" class="sr-only">等待刷新</span>
              </div>
              <div class="dashboard-stat dashboard-stat-error">
                <span class="dashboard-stat-label">错误</span>
                <span id="dashboard_summary_errors" class="dashboard-stat-value">-</span>
                <span id="dashboard_summary_errors_meta" class="sr-only">等待刷新</span>
              </div>
              <div class="dashboard-stat">
                <span class="dashboard-stat-label">版本</span>
                <span id="dashboard_summary_version" class="dashboard-stat-value">-</span>
                <span id="dashboard_summary_version_meta" class="sr-only">等待刷新</span>
              </div>
            </div>
            <p id="dashboard_summary_hint" class="muted-line">点击"刷新总览"后显示最新状态。</p>
          </article>

          <!-- ② 快捷操作（提升到第 2 位） -->
          <article class="card dashboard-surface-card">
            <h2>我想要...</h2>
            <div class="dashboard-quick-grid">
              <button class="btn-soft dashboard-quick-btn" data-dashboard-jump="panel-chat-console" type="button">打开智能对话</button>
              <button class="btn-soft dashboard-quick-btn" data-dashboard-jump="panel-model" type="button">配置模型</button>
              <button class="btn-soft dashboard-quick-btn" data-dashboard-jump="panel-channel" type="button">配置平台接入</button>
              <button class="btn-soft dashboard-quick-btn" data-dashboard-jump="panel-skills" type="button">管理技能</button>
              <button class="btn-soft dashboard-quick-btn" data-dashboard-jump="panel-update" type="button">检查版本更新</button>
              <button class="btn-soft dashboard-quick-btn" data-dashboard-jump="panel-service" type="button">服务控制</button>
            </div>
            <div class="dashboard-gateway-token-box">
              <div class="dashboard-gateway-token-main">
                <h3>Gateway Token 自动配置</h3>
                <p class="muted-line">模板机克隆后如果提示要填 Token，点一次按钮即可自动获取并写入真实配置文件。</p>
                <p id="dashboard_gateway_token_status" class="muted-line dashboard-gateway-token-status">
                  尚未执行自动配置。
                </p>
                <p id="dashboard_gateway_pairing_status" class="muted-line dashboard-gateway-token-status">
                  尚未执行网关运维动作。
                </p>
                <div class="dashboard-gateway-token-row">
                  <input
                    id="dashboard_gateway_token_value"
                    class="dashboard-gateway-token-input"
                    type="text"
                    readonly
                    placeholder="点击右侧按钮后自动显示，支持一键复制"
                  />
                  <button id="dashboard_gateway_token_copy" class="btn-soft" type="button" disabled>复制 Gateway Token</button>
                </div>
              </div>
              <div class="dashboard-gateway-token-actions">
                <button id="dashboard_gateway_token_sync" class="btn-soft" type="button">一键自动配置 Gateway Token</button>
                <button id="dashboard_gateway_pairing_approve" class="btn-soft" type="button">一键批准待处理配对</button>
                <button id="dashboard_gateway_restart" class="btn-soft" type="button">一键重启网关服务</button>
              </div>
            </div>
          </article>

          <!-- ③ 切换 AI 模型（精简版） -->
          <article class="card dashboard-surface-card">
            <h2>切换 AI 模型</h2>
            <p class="muted-line">当前模型：<strong id="dashboard_model_display">-</strong></p>
            <!-- 隐藏字段：保留 ID 防 JS 报错 -->
            <div class="sr-only" aria-hidden="true">
              <input id="dashboard_current_model" type="text" readonly />
              <input id="dashboard_current_provider" type="text" readonly />
              <input id="dashboard_current_context_window" type="text" readonly />
              <input id="dashboard_current_thinking_strength" type="text" readonly />
              <input id="dashboard_quick_context_tokens" data-dashboard-context-input="1" type="number" min="0" step="1" />
            </div>
            <div class="dashboard-model-switch-row">
              <label class="dashboard-model-switch-label">
                切换到
                <select id="dashboard_quick_model_ref"></select>
              </label>
              <button id="dashboard_quick_switch" class="btn-soft" type="button">切换</button>
            </div>
            <p class="muted-line">从长上下文模型切到短上下文模型时，请确保当前会话已用上下文不超过目标模型上限，否则会报错。</p>
            <p id="dashboard_quick_switch_hint" class="muted-line">选择目标模型后点击切换。</p>
          </article>

          <!-- ④ 地址与接入配置（折叠，默认收起） -->
          <article class="card dashboard-surface-card">
            <sl-details summary="地址与接入配置（初次部署时需要）">
              <div class="grid">
                <label>
                  本地地址
                  <input id="dashboard_panel_local_url" type="text" readonly />
                </label>
                <label>
                  公网地址
                  <input id="dashboard_panel_public_url" type="text" readonly />
                </label>
                <label>
                  网关地址
                  <input id="dashboard_gateway_public_url" type="text" readonly />
                </label>
                <label>
                  Webhook 地址
                  <input id="dashboard_webhook_base_url" type="text" readonly />
                </label>
              </div>
              <p id="dashboard_public_hint" class="muted-line">
                若为空，请在 <code>data/panel/panel.config.json</code> 的 <code>reverse_proxy</code> 中填写公网 IP 与端口。
              </p>
            </sl-details>
          </article>

          <!-- ⑤ 运行态明细（技能列表折叠/过滤） -->
          <article class="card dashboard-surface-card">
            <h2>运行态明细</h2>
            <p class="muted-line">当前在跑什么一目了然。</p>
            <div class="dashboard-runtime-grid">
              <article class="dashboard-runtime-card">
                <div class="dashboard-runtime-head">
                  <h3>渠道运行态</h3>
                  <span class="muted-line">最近检查与错误</span>
                </div>
                <div id="dashboard_channel_runtime_list" class="stack-list dashboard-channel-runtime-list"></div>
              </article>
              <article class="dashboard-runtime-card">
                <div class="dashboard-runtime-head">
                  <h3>技能运行态</h3>
                  <span id="dashboard_skills_summary_text" class="muted-line">按技能展示状态</span>
                </div>
                <div id="dashboard_skills_runtime_list" class="stack-list dashboard-skills-runtime-list"></div>
                <button id="dashboard_skills_toggle_all" class="btn-soft dashboard-skills-toggle-btn" type="button" style="display:none;">显示全部</button>
              </article>
            </div>
          </article>
        </section>

        <section class="card">
          <h2>操作时间线</h2>
          <p class="muted-line">每次点击后的结果都会记录在这里，方便你定位问题。</p>
          <pre id="messages" class="output"></pre>
        </section>
      </main>
    </div>

    <script type="module" src="/app.js"></script>
  </body>
</html>
</file>

<file path="src/docker-update.js">
import { execFile } from "node:child_process";

const DEFAULT_IMAGE_REPO = "ghcr.io/openclaw/openclaw";
const SELF_RECREATE_PLAN_ENV = "OPENCLAW_RECREATE_PLAN_B64";
const SELF_RECREATE_HELPER_SCRIPT = `
const { spawnSync } = require("node:child_process");
const PLAN_ENV_KEY = "${SELF_RECREATE_PLAN_ENV}";
const SLEEP_SEC = 1;

function run(args) {
  return spawnSync("docker", args, { encoding: "utf8" });
}

function runSleep(seconds) {
  return spawnSync("sh", ["-lc", "sleep " + String(seconds)], { encoding: "utf8" });
}

function outputOf(result) {
  return [result?.stdout, result?.stderr, result?.error?.message].filter(Boolean).join("\\n").trim();
}

function fail(message, result) {
  const detail = result ? outputOf(result) : "";
  console.error(detail ? \`\${message}: \${detail}\` : message);
  process.exit(1);
}

const encodedPlan = String(process.env[PLAN_ENV_KEY] || "").trim();
if (!encodedPlan) {
  fail("missing recreate plan");
}

let plan;
try {
  plan = JSON.parse(Buffer.from(encodedPlan, "base64").toString("utf8"));
} catch (error) {
  fail(\`invalid recreate plan: \${error.message}\`);
}

if (!plan || !plan.containerName || !Array.isArray(plan.args)) {
  fail("recreate plan is malformed");
}

function waitRunning(containerName) {
  for (let i = 0; i < 20; i += 1) {
    const statusResult = run(["inspect", "--format", "{{.State.Status}}", String(containerName)]);
    const status = String(statusResult.stdout || "").trim().toLowerCase();
    if (statusResult.status === 0 && status === "running") {
      return true;
    }
    runSleep(SLEEP_SEC);
  }
  return false;
}

function connectExtraNetworks(containerName, extraNetworks) {
  const networks = Array.isArray(extraNetworks) ? extraNetworks : [];
  for (const network of networks) {
    if (!network) {
      continue;
    }
    const connectResult = run(["network", "connect", String(network), String(containerName)]);
    const connectOutput = outputOf(connectResult).toLowerCase();
    if (connectResult.status !== 0 && !connectOutput.includes("already exists")) {
      return {
        ok: false,
        result: connectResult,
        message: \`failed to connect extra network \${network}\`
      };
    }
  }
  return {
    ok: true,
    result: null,
    message: ""
  };
}

function recreateAndVerify(containerName, args, extraNetworks, reasonLabel) {
  const recreateResult = run(args);
  if (recreateResult.status !== 0) {
    return {
      ok: false,
      result: recreateResult,
      message: \`failed to recreate container (\${reasonLabel})\`
    };
  }

  const connectResult = connectExtraNetworks(containerName, extraNetworks);
  if (!connectResult.ok) {
    return connectResult;
  }

  if (!waitRunning(containerName)) {
    return {
      ok: false,
      result: null,
      message: \`container did not reach running state (\${reasonLabel})\`
    };
  }

  return {
    ok: true,
    result: null,
    message: ""
  };
}

const containerName = String(plan.containerName);
const extraNetworks = Array.isArray(plan.extraNetworks) ? plan.extraNetworks : [];
const rollbackArgs = Array.isArray(plan.rollbackArgs) ? plan.rollbackArgs : [];
const rollbackExtraNetworks = Array.isArray(plan.rollbackExtraNetworks) ? plan.rollbackExtraNetworks : extraNetworks;

// ignore errors if container does not exist
run(["rm", "-f", containerName]);

const applyResult = recreateAndVerify(containerName, plan.args, extraNetworks, "apply");
if (applyResult.ok) {
  console.log("running");
  process.exit(0);
}

if (rollbackArgs.length > 0) {
  // apply failed: best-effort restore the previous image to keep panel available.
  run(["rm", "-f", containerName]);
  const rollbackResult = recreateAndVerify(containerName, rollbackArgs, rollbackExtraNetworks, "rollback");
  if (rollbackResult.ok) {
    fail("failed to apply target image; rolled back to previous image", applyResult.result);
  }
  fail(
    \`failed to apply target image, and rollback also failed: \${rollbackResult.message}\`,
    rollbackResult.result || applyResult.result
  );
}

fail(applyResult.message || "container did not reach running state", applyResult.result);
`;

function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

function runCommand(command, args, timeout = 30000) {
  return new Promise((resolve) => {
    execFile(command, args, { timeout, maxBuffer: 10 * 1024 * 1024 }, (error, stdout, stderr) => {
      resolve({
        ok: !error,
        code: error?.code ?? 0,
        stdout: (stdout || "").trim(),
        stderr: (stderr || "").trim(),
        message: error?.message || ""
      });
    });
  });
}

function ensureString(value) {
  return typeof value === "string" ? value : "";
}

function stripLeadingV(value) {
  const raw = ensureString(value).trim();
  return raw.startsWith("v") ? raw.slice(1) : raw;
}

export function normalizeTag(value) {
  const normalized = stripLeadingV(value);
  if (!normalized) {
    throw new Error("版本号不能为空");
  }
  if (!/^[0-9][0-9A-Za-z._-]*$/.test(normalized)) {
    throw new Error("版本号格式不合法");
  }
  return normalized;
}

export function imageTagFromImage(image) {
  const raw = ensureString(image).trim();
  if (!raw.includes(":")) {
    return "";
  }
  return raw.slice(raw.lastIndexOf(":") + 1);
}

function parseVersionParts(tag) {
  return normalizeTag(tag)
    .split(".")
    .map((item) => {
      const num = Number.parseInt(item, 10);
      return Number.isNaN(num) ? 0 : num;
    });
}

export function compareVersionTags(a, b) {
  const pa = parseVersionParts(a);
  const pb = parseVersionParts(b);
  const length = Math.max(pa.length, pb.length);
  for (let i = 0; i < length; i += 1) {
    const av = pa[i] ?? 0;
    const bv = pb[i] ?? 0;
    if (av > bv) {
      return 1;
    }
    if (av < bv) {
      return -1;
    }
  }
  return 0;
}

export function makeImageRef(tag, imageRepo = DEFAULT_IMAGE_REPO) {
  return `${imageRepo}:${normalizeTag(tag)}`;
}

function resolveGithubRepoFromImageRepo(imageRepo) {
  const raw = ensureString(imageRepo).trim().replace(/^https?:\/\//, "");
  if (!raw) {
    return null;
  }

  const parts = raw
    .split("/")
    .map((item) => item.trim())
    .filter(Boolean);

  // owner/repo (implicit GitHub repo)
  if (parts.length === 2 && !/[.:]/.test(parts[0])) {
    return { owner: parts[0], repo: parts[1] };
  }

  return null;
}

function resolveGhcrPackageFromImageRepo(imageRepo) {
  const raw = ensureString(imageRepo).trim().replace(/^https?:\/\//, "");
  if (!raw) {
    return null;
  }

  const parts = raw
    .split("/")
    .map((item) => item.trim())
    .filter(Boolean);

  if (parts.length >= 3 && parts[0].toLowerCase() === "ghcr.io") {
    return { owner: parts[1], packageName: parts[2] };
  }

  return null;
}

function buildGithubApiHeaders(githubToken = "") {
  const headers = {
    accept: "application/vnd.github+json",
    "user-agent": "openclaw-panel"
  };
  const token = ensureString(githubToken).trim();
  if (token) {
    headers.authorization = `Bearer ${token}`;
  }
  return headers;
}

function buildGhcrHeaders(token = "") {
  const headers = {
    accept: "application/json",
    "user-agent": "openclaw-panel"
  };
  const normalizedToken = ensureString(token).trim();
  if (normalizedToken) {
    headers.authorization = `Bearer ${normalizedToken}`;
  }
  return headers;
}

async function fetchGhcrPackageVersions({ owner, packageName, fetchImpl = fetch, githubToken = "" }) {
  const encodedOwner = encodeURIComponent(owner);
  const encodedPackage = encodeURIComponent(packageName);
  const headers = buildGithubApiHeaders(githubToken);
  const endpoints = [
    `https://api.github.com/users/${encodedOwner}/packages/container/${encodedPackage}/versions?per_page=100`,
    `https://api.github.com/orgs/${encodedOwner}/packages/container/${encodedPackage}/versions?per_page=100`
  ];

  let lastStatus = 0;
  for (const url of endpoints) {
    const response = await fetchImpl(url, { headers });
    if (response.ok) {
      const payload = await response.json();
      return Array.isArray(payload) ? payload : [];
    }
    lastStatus = response.status;
    if (response.status === 404) {
      continue;
    }
    if (response.status === 401 || response.status === 403) {
      const authError = new Error(`GitHub API 请求失败: ${response.status}（请确认 token 具备 read:packages 权限）`);
      authError.status = response.status;
      throw authError;
    }
    const responseError = new Error(`GitHub API 请求失败: ${response.status}`);
    responseError.status = response.status;
    throw responseError;
  }

  if (lastStatus === 404) {
    const notFoundError = new Error("GitHub API 请求失败: 404（请确认镜像地址正确，且私有包已提供 read:packages token）");
    notFoundError.status = 404;
    throw notFoundError;
  }

  const unknownError = new Error(`GitHub API 请求失败: ${lastStatus || "unknown"}`);
  unknownError.status = lastStatus || 0;
  throw unknownError;
}

function buildGhcrTokenUrl(owner, packageName) {
  const scope = encodeURIComponent(`repository:${owner}/${packageName}:pull`);
  return `https://ghcr.io/token?scope=${scope}&service=ghcr.io`;
}

async function fetchGhcrRegistryTags({ owner, packageName, fetchImpl = fetch }) {
  const tokenUrl = buildGhcrTokenUrl(owner, packageName);
  const tokenResponse = await fetchImpl(tokenUrl, { headers: buildGhcrHeaders() });
  if (!tokenResponse.ok) {
    throw new Error(`GHCR token 请求失败: ${tokenResponse.status}`);
  }

  const tokenPayload = await tokenResponse.json();
  const pullToken = ensureString(tokenPayload?.token).trim();
  if (!pullToken) {
    throw new Error("GHCR token 请求成功但未返回 token");
  }

  const tagsUrl = `https://ghcr.io/v2/${owner}/${packageName}/tags/list`;
  const tagsResponse = await fetchImpl(tagsUrl, { headers: buildGhcrHeaders(pullToken) });
  if (!tagsResponse.ok) {
    throw new Error(`GHCR tags 请求失败: ${tagsResponse.status}`);
  }

  const tagsPayload = await tagsResponse.json();
  return Array.isArray(tagsPayload?.tags) ? tagsPayload.tags : [];
}

function extractLatestTagFromRegistryTags(tags = []) {
  const candidates = [];
  for (const rawTag of tags) {
    const text = ensureString(rawTag).trim();
    if (!text) {
      continue;
    }
    const lower = text.toLowerCase();
    if (lower === "latest" || lower.startsWith("sha-")) {
      continue;
    }
    try {
      candidates.push({
        tag: normalizeTag(text),
        publishedAt: null
      });
    } catch {
      // Ignore non-semver-like tags.
    }
  }

  if (candidates.length === 0) {
    return null;
  }

  candidates.sort((a, b) => compareVersionTags(b.tag, a.tag));
  return candidates[0];
}

function extractLatestTagFromPackageVersions(versions = []) {
  const candidates = [];
  for (const item of versions) {
    const tags = Array.isArray(item?.metadata?.container?.tags) ? item.metadata.container.tags : [];
    const publishedAt = ensureString(item?.updated_at || item?.created_at || "");
    for (const rawTag of tags) {
      const text = ensureString(rawTag).trim();
      if (!text) {
        continue;
      }
      const lower = text.toLowerCase();
      if (lower === "latest" || lower.startsWith("sha-")) {
        continue;
      }
      try {
        const normalizedTag = normalizeTag(text);
        candidates.push({
          tag: normalizedTag,
          publishedAt: publishedAt || null
        });
      } catch {
        // Ignore non-semver-like tags.
      }
    }
  }

  if (candidates.length === 0) {
    return null;
  }

  candidates.sort((a, b) => compareVersionTags(b.tag, a.tag));
  return candidates[0];
}

async function fetchLatestGithubReleaseTag({ owner, repo, fetchImpl = fetch, githubToken = "" }) {
  const headers = buildGithubApiHeaders(githubToken);
  const response = await fetchImpl(`https://api.github.com/repos/${owner}/${repo}/releases/latest`, { headers });
  if (!response.ok) {
    throw new Error(`GitHub API 请求失败: ${response.status}`);
  }
  const payload = await response.json();
  const tag = normalizeTag(payload.tag_name || "");
  return {
    releaseRepo: `${owner}/${repo}`,
    tag,
    publishedAt: payload.published_at || null
  };
}

function resolveGithubToken(githubToken = "") {
  const direct = ensureString(githubToken).trim();
  if (direct) {
    return direct;
  }

  const envValue = ensureString(
    process.env.OPENCLAW_UPDATE_GITHUB_TOKEN ||
      process.env.GITHUB_PACKAGES_TOKEN ||
      process.env.GHCR_READ_TOKEN ||
      process.env.GHCR_TOKEN ||
      process.env.GITHUB_TOKEN
  ).trim();
  return envValue;
}

export async function fetchLatestRelease({ imageRepo = DEFAULT_IMAGE_REPO, fetchImpl = fetch, githubToken = "" } = {}) {
  const token = resolveGithubToken(githubToken);
  const ghcrPackage = resolveGhcrPackageFromImageRepo(imageRepo);
  if (ghcrPackage) {
    let latest = null;

    try {
      const versions = await fetchGhcrPackageVersions({
        owner: ghcrPackage.owner,
        packageName: ghcrPackage.packageName,
        fetchImpl,
        githubToken: token
      });
      latest = extractLatestTagFromPackageVersions(versions);
    } catch (error) {
      if (error?.status === 401 || error?.status === 403) {
        // Public GHCR packages can be read without PAT via anonymous pull token.
        try {
          const tags = await fetchGhcrRegistryTags({
            owner: ghcrPackage.owner,
            packageName: ghcrPackage.packageName,
            fetchImpl
          });
          latest = extractLatestTagFromRegistryTags(tags);
        } catch {
          // Keep original auth error to preserve guidance for private package troubleshooting.
          throw error;
        }
      } else {
        throw error;
      }
    }

    if (!latest) {
      throw new Error("未找到可用版本标签（请确保镜像已发布非 latest 的版本 tag）");
    }
    return {
      releaseRepo: `${ghcrPackage.owner}/${ghcrPackage.packageName}`,
      tag: latest.tag,
      publishedAt: latest.publishedAt
    };
  }

  const githubRepo = resolveGithubRepoFromImageRepo(imageRepo);
  if (!githubRepo) {
    throw new Error(`无法从镜像仓库推导 GitHub 仓库或 GHCR 包: ${imageRepo}`);
  }

  return {
    ...(await fetchLatestGithubReleaseTag({
      owner: githubRepo.owner,
      repo: githubRepo.repo,
      fetchImpl,
      githubToken: token
    }))
  };
}

async function inspectContainer(containerName, runCmd = runCommand) {
  const result = await runCmd("docker", ["inspect", containerName]);
  if (!result.ok) {
    throw new Error(`读取容器信息失败: ${result.stderr || result.message || "unknown"}`);
  }
  let parsed;
  try {
    parsed = JSON.parse(result.stdout);
  } catch {
    throw new Error("解析容器 inspect 结果失败");
  }
  if (!Array.isArray(parsed) || !parsed[0]) {
    throw new Error("容器 inspect 结果为空");
  }
  return parsed[0];
}

function formatPortBinding(containerPort, binding) {
  const hostIp = ensureString(binding?.HostIp || "");
  const hostPort = ensureString(binding?.HostPort || "");
  if (!hostPort) {
    return containerPort;
  }
  if (!hostIp || hostIp === "0.0.0.0") {
    return `${hostPort}:${containerPort}`;
  }
  return `${hostIp}:${hostPort}:${containerPort}`;
}

export function buildDockerRunArgs(inspect, image) {
  const containerName = ensureString(inspect?.Name || "").replace(/^\//, "");
  if (!containerName) {
    throw new Error("无法解析容器名");
  }

  const args = ["run", "-d", "--name", containerName];
  const hostConfig = inspect?.HostConfig || {};
  const restart = hostConfig?.RestartPolicy || {};
  const restartName = ensureString(restart?.Name || "");
  if (restartName && restartName !== "no") {
    if (restartName === "on-failure" && Number(restart?.MaximumRetryCount) > 0) {
      args.push("--restart", `${restartName}:${restart.MaximumRetryCount}`);
    } else {
      args.push("--restart", restartName);
    }
  }

  const binds = Array.isArray(hostConfig?.Binds) ? hostConfig.Binds : [];
  binds.forEach((bind) => {
    if (bind) {
      args.push("-v", bind);
    }
  });

  const portBindings = hostConfig?.PortBindings || {};
  Object.entries(portBindings).forEach(([containerPort, bindings]) => {
    const list = Array.isArray(bindings) ? bindings : [];
    list.forEach((binding) => {
      args.push("-p", formatPortBinding(containerPort, binding));
    });
  });

  const envList = Array.isArray(inspect?.Config?.Env) ? inspect.Config.Env : [];
  envList.forEach((item) => {
    args.push("-e", item);
  });

  const labels = inspect?.Config?.Labels || {};
  Object.entries(labels).forEach(([key, value]) => {
    if (key) {
      args.push("--label", `${key}=${value ?? ""}`);
    }
  });

  if (inspect?.Config?.WorkingDir) {
    args.push("-w", inspect.Config.WorkingDir);
  }
  if (inspect?.Config?.User) {
    args.push("-u", inspect.Config.User);
  }

  const networks = Object.keys(inspect?.NetworkSettings?.Networks || {});
  const networkMode = ensureString(hostConfig?.NetworkMode || "");
  const primaryNetwork =
    networkMode && !["bridge", "default", "none"].includes(networkMode) ? networkMode : networks[0] || "";
  if (primaryNetwork) {
    args.push("--network", primaryNetwork);
  }

  args.push(image);
  const cmd = inspect?.Config?.Cmd;
  if (Array.isArray(cmd)) {
    args.push(...cmd);
  } else if (typeof cmd === "string" && cmd.trim()) {
    args.push(cmd.trim());
  }

  const extraNetworks = networks.filter((name) => name && name !== primaryNetwork);
  return {
    containerName,
    args,
    extraNetworks
  };
}

function parseStateStatusLine(value) {
  const text = ensureString(value).trim();
  if (!text) {
    return {
      status: "",
      restartCount: null
    };
  }
  const [statusRaw, restartCountRaw] = text.split("|", 2);
  const status = ensureString(statusRaw).trim().toLowerCase();
  const parsedRestart = Number.parseInt(ensureString(restartCountRaw).trim(), 10);
  return {
    status,
    restartCount: Number.isNaN(parsedRestart) ? null : parsedRestart
  };
}

async function waitContainerRunning(containerName, runCmd = runCommand) {
  let stableRunningCount = 0;
  let lastRestartCount = null;
  for (let i = 0; i < 10; i += 1) {
    const result = await runCmd("docker", ["inspect", "--format", "{{.State.Status}}|{{.RestartCount}}", containerName]);
    if (result.ok) {
      const snapshot = parseStateStatusLine(result.stdout);
      const hasRestartCount = Number.isInteger(snapshot.restartCount);
      if (snapshot.status === "running") {
        if (!hasRestartCount) {
          stableRunningCount += 1;
        } else if (lastRestartCount !== null && snapshot.restartCount === lastRestartCount) {
          stableRunningCount += 1;
        } else {
          stableRunningCount = 1;
        }
        lastRestartCount = hasRestartCount ? snapshot.restartCount : null;
        if (stableRunningCount >= 2) {
          return true;
        }
      } else {
        stableRunningCount = 0;
        lastRestartCount = hasRestartCount ? snapshot.restartCount : null;
      }
    } else {
      stableRunningCount = 0;
      lastRestartCount = null;
    }
    await sleep(1000);
  }
  return false;
}

async function pullImageWithRetry(image, runCmd = runCommand, attempts = 3) {
  let last = null;
  for (let i = 1; i <= attempts; i += 1) {
    const result = await runCmd("docker", ["pull", image], 120000);
    last = result;
    if (result.ok) {
      return result;
    }
    if (i < attempts) {
      await sleep(i * 1000);
    }
  }
  return last || { ok: false, stderr: "镜像拉取失败", message: "镜像拉取失败" };
}

async function recreateContainer(inspect, image, runCmd = runCommand) {
  const plan = buildDockerRunArgs(inspect, image);
  await runCmd("docker", ["rm", "-f", plan.containerName]);
  const runResult = await runCmd("docker", plan.args, 60000);
  if (!runResult.ok) {
    throw new Error(runResult.stderr || runResult.message || "容器重建失败");
  }
  for (const network of plan.extraNetworks) {
    const connectResult = await runCmd("docker", ["network", "connect", network, plan.containerName]);
    if (!connectResult.ok && !/already exists/i.test(connectResult.stderr)) {
      throw new Error(connectResult.stderr || connectResult.message || `连接网络失败: ${network}`);
    }
  }
  const running = await waitContainerRunning(plan.containerName, runCmd);
  if (!running) {
    throw new Error("容器启动超时，未进入 running 状态");
  }
}

export async function checkForUpdates({
  containerName = "openclaw-gateway",
  imageRepo = DEFAULT_IMAGE_REPO,
  githubToken = "",
  fetchImpl = fetch,
  runCmd = runCommand
} = {}) {
  const inspect = await inspectContainer(containerName, runCmd);
  const currentImage = ensureString(inspect?.Config?.Image || "");
  const currentTag = imageTagFromImage(currentImage);
  let latestTag = "";
  let latestPublishedAt = null;
  let updateAvailable = false;
  let warning = "";
  let releaseRepo = "";

  try {
    const latest = await fetchLatestRelease({ imageRepo, fetchImpl, githubToken });
    releaseRepo = latest.releaseRepo || "";
    latestTag = latest.tag;
    latestPublishedAt = latest.publishedAt;
    if (currentTag) {
      try {
        updateAvailable = compareVersionTags(latestTag, currentTag) > 0;
      } catch {
        // Non-semver-like current tags (e.g. "local") should not break update checks.
        updateAvailable = stripLeadingV(currentTag) !== latestTag;
      }
    }
  } catch (error) {
    warning = error.message;
  }

  return {
    ok: true,
    containerName,
    imageRepo,
    releaseRepo,
    currentImage,
    currentTag,
    latestTag,
    latestPublishedAt,
    updateAvailable,
    warning
  };
}

export async function pullTag({
  containerName = "openclaw-gateway",
  targetTag,
  imageRepo = DEFAULT_IMAGE_REPO,
  runCmd = runCommand
}) {
  const normalizedTag = normalizeTag(targetTag);
  const targetImage = makeImageRef(normalizedTag, imageRepo);
  const snapshot = await inspectContainer(containerName, runCmd);
  const oldImage = ensureString(snapshot?.Config?.Image || "");

  const pullResult = await pullImageWithRetry(targetImage, runCmd, 3);
  if (!pullResult.ok) {
    return {
      ok: false,
      action: "pull",
      containerName,
      targetImage,
      oldImage,
      rolledBack: false,
      requiresRestart: false,
      message: pullResult.stderr || pullResult.message || "目标镜像拉取失败"
    };
  }

  return {
    ok: true,
    action: "pull",
    containerName,
    targetImage,
    oldImage,
    rolledBack: false,
    requiresRestart: true,
    message: "镜像拉取成功；重启容器后生效"
  };
}

async function scheduleSelfRecreateByHelper({ plan, helperImage, runCmd = runCommand }) {
  const payload = {
    containerName: String(plan?.containerName || "").trim(),
    args: Array.isArray(plan?.args) ? plan.args : [],
    extraNetworks: Array.isArray(plan?.extraNetworks) ? plan.extraNetworks : [],
    rollbackArgs: Array.isArray(plan?.rollbackArgs) ? plan.rollbackArgs : [],
    rollbackExtraNetworks: Array.isArray(plan?.rollbackExtraNetworks) ? plan.rollbackExtraNetworks : []
  };
  if (!payload.containerName || payload.args.length === 0) {
    throw new Error("无法生成重建计划，缺少必要容器参数");
  }

  const encodedPlan = Buffer.from(JSON.stringify(payload), "utf8").toString("base64");
  const helperResult = await runCmd(
    "docker",
    [
      "run",
      "-d",
      "--rm",
      "-v",
      "/var/run/docker.sock:/var/run/docker.sock",
      "-e",
      `${SELF_RECREATE_PLAN_ENV}=${encodedPlan}`,
      "--pull",
      "never",
      helperImage,
      "node",
      "-e",
      SELF_RECREATE_HELPER_SCRIPT
    ],
    30000
  );

  if (!helperResult.ok) {
    throw new Error(helperResult.stderr || helperResult.message || "无法启动更新重建任务");
  }

  const helperContainerId = ensureString(helperResult.stdout)
    .split(/\s+/)
    .filter(Boolean)
    .pop();

  return {
    helperContainerId: helperContainerId || ""
  };
}

export async function applyPulledTag({
  containerName = "openclaw-panel",
  targetTag,
  imageRepo = DEFAULT_IMAGE_REPO,
  runCmd = runCommand
}) {
  const normalizedTag = normalizeTag(targetTag);
  const targetImage = makeImageRef(normalizedTag, imageRepo);
  const snapshot = await inspectContainer(containerName, runCmd);
  const oldImage = ensureString(snapshot?.Config?.Image || "");

  const pullResult = await pullImageWithRetry(targetImage, runCmd, 3);
  if (!pullResult.ok) {
    return {
      ok: false,
      action: "apply",
      containerName,
      targetImage,
      oldImage,
      rolledBack: false,
      requiresRestart: false,
      requiresReconnect: false,
      message: pullResult.stderr || pullResult.message || "目标镜像拉取失败"
    };
  }

  try {
    const plan = buildDockerRunArgs(snapshot, targetImage);
    const rollbackPlan = oldImage ? buildDockerRunArgs(snapshot, oldImage) : null;
    const helper = await scheduleSelfRecreateByHelper({
      plan: {
        ...plan,
        rollbackArgs: rollbackPlan?.args || [],
        rollbackExtraNetworks: rollbackPlan?.extraNetworks || []
      },
      helperImage: oldImage || targetImage,
      runCmd
    });
    return {
      ok: true,
      action: "apply",
      containerName,
      targetImage,
      oldImage,
      rolledBack: false,
      requiresRestart: false,
      requiresReconnect: true,
      reconnectAfterMs: 6000,
      helperContainerId: helper.helperContainerId,
      message: "已开始重启并应用更新，页面会短暂断开并自动恢复"
    };
  } catch (error) {
    return {
      ok: false,
      action: "apply",
      containerName,
      targetImage,
      oldImage,
      rolledBack: false,
      requiresRestart: false,
      requiresReconnect: false,
      message: error.message || "无法启动重启并应用更新任务"
    };
  }
}

async function mutateVersion({
  action,
  containerName,
  targetTag,
  imageRepo = DEFAULT_IMAGE_REPO,
  runCmd = runCommand
}) {
  const normalizedTag = normalizeTag(targetTag);
  const targetImage = makeImageRef(normalizedTag, imageRepo);
  const snapshot = await inspectContainer(containerName, runCmd);
  const oldImage = ensureString(snapshot?.Config?.Image || "");

  const pullResult = await pullImageWithRetry(targetImage, runCmd, 3);
  if (!pullResult.ok) {
    return {
      ok: false,
      action,
      containerName,
      targetImage,
      oldImage,
      rolledBack: false,
      message: pullResult.stderr || pullResult.message || "目标镜像拉取失败"
    };
  }

  try {
    await recreateContainer(snapshot, targetImage, runCmd);
    return {
      ok: true,
      action,
      containerName,
      targetImage,
      oldImage,
      rolledBack: false,
      message: `${action} 成功`
    };
  } catch (error) {
    let rollbackOk = false;
    let rollbackMessage = "";
    if (oldImage) {
      try {
        await pullImageWithRetry(oldImage, runCmd, 3);
        await recreateContainer(snapshot, oldImage, runCmd);
        rollbackOk = true;
        rollbackMessage = "已自动回滚到旧版本";
      } catch (rollbackError) {
        rollbackMessage = rollbackError.message;
      }
    }
    return {
      ok: false,
      action,
      containerName,
      targetImage,
      oldImage,
      rolledBack: rollbackOk,
      message: error.message,
      rollbackMessage
    };
  }
}

export async function upgradeToTag(options) {
  return mutateVersion({ ...options, action: "upgrade" });
}

export async function rollbackToTag(options) {
  return mutateVersion({ ...options, action: "rollback" });
}
</file>

<file path="src/panel-config.js">
import os from "node:os";
import path from "node:path";
import { z } from "zod";
import { expandHome, readJsonFile, writeJsonFileAtomic } from "./utils.js";

function trimString(value) {
  return String(value || "").trim();
}

export function resolveOpenClawConfigPath(panelConfig, options = {}) {
  const env = options.env || process.env;
  const homeDir = options.homeDir || os.homedir();
  const envOverride = expandHome(trimString(env.OPENCLAW_CONFIG_PATH));
  if (envOverride) {
    return envOverride;
  }
  const configuredPath = expandHome(trimString(panelConfig?.openclaw?.config_path));
  if (configuredPath) {
    return configuredPath;
  }
  return path.join(homeDir, ".openclaw", "openclaw.json");
}

const panelConfigSchema = z.object({
  panel: z
    .object({
      listen_host: z.string().default("127.0.0.1"),
      listen_port: z.number().int().positive().default(18080),
      container_name: z.string().default("openclaw-panel"),
      image_repo: z.string().default("ghcr.io/bianshumeng/openclaw-panel")
    })
    .default({}),
  runtime: z
    .object({
      mode: z.enum(["systemd", "docker"]).default("systemd")
    })
    .default({}),
  reverse_proxy: z
    .object({
      enabled: z.boolean().default(false),
      public_scheme: z.enum(["http", "https"]).default("http"),
      public_host: z.string().default(""),
      panel_public_port: z.number().int().positive().default(18080),
      gateway_public_port: z.number().int().positive().default(18789),
      panel_public_base_url: z.string().default(""),
      webhook_public_base_url: z.string().default("")
    })
    .default({}),
  openclaw: z
    .object({
      config_path: z.string().default("~/.openclaw/openclaw.json"),
      service_name: z.string().default("openclaw-gateway"),
      container_name: z.string().default("openclaw-gateway"),
      image_repo: z.string().default("ghcr.io/bianshumeng/openclaw-mymy"),
      gateway_port: z.number().int().positive().default(18789),
      gateway_ws_url: z.string().default(""),
      gateway_media_root: z.string().default("")
    })
    .default({}),
  docker: z
    .object({
      enabled: z.boolean().default(false)
    })
    .default({}),
  update: z
    .object({
      github_token: z.string().default(""),
      bot_release_repo: z.string().default("openclaw/openclaw"),
      panel_release_repo: z.string().default("Bianshumeng/openclaw-panel-public"),
      panel_service_name: z.string().default("openclaw-panel"),
      panel_app_dir: z.string().default("/opt/openclaw-panel")
    })
    .default({}),
  log: z
    .object({
      source: z.enum(["journal", "file", "docker"]).default("journal"),
      file_path: z.string().default("~/.openclaw/logs/gateway.log")
    })
    .default({})
});

export const defaults = panelConfigSchema.parse({});

export function getPanelConfigPath() {
  if (process.env.PANEL_CONFIG_PATH) {
    return expandHome(process.env.PANEL_CONFIG_PATH);
  }
  return path.join(os.homedir(), ".openclaw-panel", "panel.config.json");
}

export async function loadPanelConfig() {
  const filePath = getPanelConfigPath();
  const raw = await readJsonFile(filePath, defaults);
  const merged = {
    ...defaults,
    ...raw,
    panel: { ...defaults.panel, ...(raw.panel || {}) },
    runtime: { ...defaults.runtime, ...(raw.runtime || {}) },
    reverse_proxy: { ...defaults.reverse_proxy, ...(raw.reverse_proxy || {}) },
    openclaw: { ...defaults.openclaw, ...(raw.openclaw || {}) },
    docker: { ...defaults.docker, ...(raw.docker || {}) },
    update: { ...defaults.update, ...(raw.update || {}) },
    log: { ...defaults.log, ...(raw.log || {}) }
  };
  const parsed = panelConfigSchema.parse(merged);
  const envListenHost = String(process.env.PANEL_LISTEN_HOST || "").trim();
  const envListenPort = Number.parseInt(String(process.env.PANEL_LISTEN_PORT || ""), 10);
  const resolvedOpenClawConfigPath = resolveOpenClawConfigPath(parsed);
  const panelWithEnv = {
    ...parsed.panel,
    ...(envListenHost ? { listen_host: envListenHost } : {}),
    ...(Number.isFinite(envListenPort) && envListenPort > 0 ? { listen_port: envListenPort } : {})
  };
  const runtimeWithAutoFix = { ...parsed.runtime, mode: "systemd" };
  const dockerWithAutoFix = { ...parsed.docker, enabled: false };
  const logWithAutoFix =
    parsed.log.source === "docker"
      ? {
          ...parsed.log,
          source: process.platform === "linux" ? "journal" : "file"
        }
      : parsed.log;
  const normalizedLogFilePath = trimString(logWithAutoFix.file_path) || defaults.log.file_path;
  return {
    filePath,
    config: {
      ...parsed,
      panel: panelWithEnv,
      runtime: runtimeWithAutoFix,
      docker: dockerWithAutoFix,
      openclaw: {
        ...parsed.openclaw,
        config_path: resolvedOpenClawConfigPath,
        gateway_media_root: ""
      },
      log: {
        ...logWithAutoFix,
        file_path: normalizedLogFilePath
      }
    }
  };
}

export async function savePanelConfig(next) {
  const parsed = panelConfigSchema.parse(next);
  const filePath = getPanelConfigPath();
  await writeJsonFileAtomic(filePath, parsed, 0o600);
  return {
    filePath,
    config: parsed
  };
}
</file>

<file path="public/pages/update.html">
<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>OpenClaw 龙虾控制台</title>
        <script>
      (function initThemeEarly() {
        var theme = "light";
        try {
          var saved = window.localStorage.getItem("openclaw-panel-theme");
          theme = saved === "dark" ? "dark" : "light";
        } catch (_error) {
          theme = "light";
        }
        var root = document.documentElement;
        root.dataset.theme = theme;
        root.classList.toggle("sl-theme-dark", theme === "dark");
        root.classList.toggle("sl-theme-light", theme !== "dark");
      })();
    </script>    <link rel="stylesheet" href="/shoelace/themes/light.css" />
    <link rel="stylesheet" href="/shoelace/themes/dark.css" />
    <link rel="stylesheet" href="/styles.css" />
    <script type="module" src="/shoelace/shoelace-autoloader.js"></script>
  </head>
  <body data-theme="light">
    <div class="layout">
      <aside class="sidebar">
        <div class="brand">
          <p class="eyebrow">OpenClaw</p>
          <h1>龙虾控制台</h1>
          <p class="sub">管理你的 AI 助手：模型、渠道、技能，一站搞定。</p>
        </div>

                <nav class="tabs sidebar-tabs">
          <a class="tab" data-tab-target="panel-dashboard" href="/dashboard">仪表盘</a>
          <a class="tab" data-tab-target="panel-model" href="/model">模型配置</a>
          <a class="tab" data-tab-target="panel-chat-console" href="/chat-console">智能对话</a>
          <a class="tab" data-tab-target="panel-skills" href="/skills">技能管理</a>
          <a class="tab" data-tab-target="panel-config-generator" href="/config-generator">配置生成器</a>
          <a class="tab" data-tab-target="panel-channel" href="/channels">平台接入</a>
          <a class="tab is-active" data-tab-target="panel-update" href="/update">版本更新</a>
          <a class="tab" data-tab-target="panel-service" href="/service">服务控制</a>
          <a class="tab" data-tab-target="panel-logs" href="/logs">运行日志</a>
        </nav>
      </aside>

      <main class="content">
        <header class="page-header">
          <div>
            <h2 class="page-title">龙虾控制台</h2>
            <p class="page-subtitle">你的 AI 助手管理中心</p>
          </div>
          <button id="theme_toggle" class="btn-soft" type="button">切换到深夜模式</button>
        </header>

<section class="panel is-visible" data-panel="panel-update">
          <article class="card">
            <h2>龙虾 Bot 直装更新</h2>
            <p class="muted-line">使用官方直装更新命令执行升级/回滚，完成后自动执行 doctor、gateway restart、health。</p>
            <div class="update-status-card">
              <div class="status-row">
                <span class="pill" id="bot_update_state" style="font-size:1.05rem;padding:0.45rem 1.4rem;">还没检查</span>
              </div>
              <p class="muted-line update-status-hint" id="bot_update_hint">页面打开后会自动检查，你也可以手动再检查一次</p>
            </div>

            <div id="bot_update_progress_wrap" class="update-progress-card" aria-live="polite">
              <div class="update-progress-head">
                <span>操作进度</span>
                <span id="bot_update_progress_text">等待操作（0%）</span>
              </div>
              <progress id="bot_update_progress" max="100" value="0"></progress>
            </div>

            <div class="grid update-version-card" style="grid-template-columns:1fr 1fr;gap:0.75rem 1.2rem;">
              <label>
                当前版本
                <input id="bot_update_current_tag" type="text" readonly />
              </label>
              <label>
                最新版本
                <input id="bot_update_latest_tag" type="text" readonly />
              </label>
            </div>

            <div class="actions" style="margin-top:1rem;">
              <button id="bot_check_update">检查新版本</button>
              <button id="bot_upgrade_update">升级</button>
            </div>

            <details style="margin-top:1.2rem;">
              <summary class="muted-line" style="cursor:pointer;user-select:none;">高级选项（指定版本 / 回滚）</summary>
              <div class="update-advanced-card">
                <label>
                  要升级/回滚到的版本
                  <input id="bot_update_target_tag" type="text" placeholder="留空则升级到最新版" />
                </label>
                <div class="actions" style="margin-top:0.75rem;">
                  <button id="bot_rollback_update" class="btn-soft">回滚（遇到问题时用）</button>
                </div>
              </div>
            </details>
          </article>

          <article class="card" style="margin-top:1rem;">
            <h2>龙虾控制台版本更新（公开仓库发版）</h2>
            <p class="muted-line">更新包来自公开仓库 release。先准备版本包，再点击“应用更新并重启”生效。</p>
            <div class="update-status-card">
              <div class="status-row">
                <span class="pill" id="panel_update_state" style="font-size:1.05rem;padding:0.45rem 1.4rem;">还没检查</span>
              </div>
              <p class="muted-line update-status-hint" id="panel_update_hint">页面打开后会自动检查，你也可以手动再检查一次</p>
            </div>

            <div id="panel_update_progress_wrap" class="update-progress-card" aria-live="polite">
              <div class="update-progress-head">
                <span>操作进度</span>
                <span id="panel_update_progress_text">等待操作（0%）</span>
              </div>
              <progress id="panel_update_progress" max="100" value="0"></progress>
            </div>

            <div class="grid update-version-card" style="grid-template-columns:1fr 1fr;gap:0.75rem 1.2rem;">
              <label>
                当前版本
                <input id="panel_update_current_tag" type="text" readonly />
              </label>
              <label>
                最新版本
                <input id="panel_update_latest_tag" type="text" readonly />
              </label>
            </div>

            <div class="actions" style="margin-top:1rem;">
              <button id="panel_check_update">检查新版本</button>
              <button id="panel_upgrade_update">准备更新包</button>
              <button id="panel_apply_update" class="btn-soft">应用更新并重启</button>
            </div>

            <details style="margin-top:1.2rem;">
              <summary class="muted-line" style="cursor:pointer;user-select:none;">高级选项（指定版本 / 回滚）</summary>
              <div class="update-advanced-card">
                <label>
                  要准备的目标版本
                  <input id="panel_update_target_tag" type="text" placeholder="留空则准备最新版" />
                </label>
                <div class="actions" style="margin-top:0.75rem;">
                  <button id="panel_rollback_update" class="btn-soft">准备回滚包</button>
                </div>
              </div>
            </details>
          </article>
        </section>

        <section class="card">
          <h2>操作记录</h2>
          <p class="muted-line">每次操作的结果都会记录在这里，方便你定位问题。</p>
          <pre id="messages" class="output"></pre>
        </section>
      </main>
    </div>

    <script type="module" src="/app.js"></script>
  </body>
</html>
</file>

<file path="public/js/pages/system-page.js">
import {
  api,
  channelSettingsSnapshot,
  els,
  getInputValue,
  modelEditorState,
  setInput,
  setMessage,
  setText
} from "../core/panel-core.js";
import {
  fillModelEditor,
  renderDashboardModelCards,
  updateDashboardErrorSummary,
  updateDashboardVersionSummary
} from "./model-dashboard-page.js";

let stream = null;
const UPDATE_TARGET_CONFIG = Object.freeze({
  bot: {
    label: "龙虾 Bot",
    stateId: "bot_update_state",
    hintId: "bot_update_hint",
    currentTagId: "bot_update_current_tag",
    latestTagId: "bot_update_latest_tag",
    targetTagId: "bot_update_target_tag",
    checkButtonId: "bot_check_update",
    upgradeButtonId: "bot_upgrade_update",
    rollbackButtonId: "bot_rollback_update",
    progressWrapId: "bot_update_progress_wrap",
    progressBarId: "bot_update_progress",
    progressTextId: "bot_update_progress_text"
  },
  panel: {
    label: "龙虾控制台",
    stateId: "panel_update_state",
    hintId: "panel_update_hint",
    currentTagId: "panel_update_current_tag",
    latestTagId: "panel_update_latest_tag",
    targetTagId: "panel_update_target_tag",
    checkButtonId: "panel_check_update",
    upgradeButtonId: "panel_upgrade_update",
    rollbackButtonId: "panel_rollback_update",
    applyButtonId: "panel_apply_update",
    progressWrapId: "panel_update_progress_wrap",
    progressBarId: "panel_update_progress",
    progressTextId: "panel_update_progress_text"
  }
});

function normalizeUpdateTarget(target = "bot") {
  return target === "panel" ? "panel" : "bot";
}

function getUpdateTargetConfig(target = "bot") {
  return UPDATE_TARGET_CONFIG[normalizeUpdateTarget(target)];
}

function fillPanelMeta(config, deployment = {}) {
  const runtime = config.runtime?.mode || "systemd";
  const target =
    runtime === "docker" ? config.openclaw.container_name || config.openclaw.service_name : config.openclaw.service_name;
  if (els.metaServiceName) {
    els.metaServiceName.textContent = `target: ${target}`;
  }
  if (els.metaLogSource) {
    els.metaLogSource.textContent = `log: ${config.log.source} (${runtime})`;
  }
  setInput("dashboard_panel_local_url", deployment.panelLocalUrl || "-");
  setInput("dashboard_panel_public_url", deployment.panelPublicUrl || "未配置（请填写公网 IP + 端口）");
  setInput("dashboard_gateway_public_url", deployment.gatewayPublicUrl || "未配置（请填写公网 IP + 端口）");
  setInput("dashboard_webhook_base_url", deployment.webhookBaseUrl || "未配置（请填写公网 IP + 端口）");
  if (els.dashboardPublicHint) {
    if (deployment.hasPublicEndpoint && deployment.hasWebhookEndpoint) {
      els.dashboardPublicHint.textContent = "公网访问地址与 Webhook 回调基地址已就绪，可直接复制到外部平台。";
    } else {
      els.dashboardPublicHint.innerHTML =
        "若为空，请在 <code>data/panel/panel.config.json</code> 的 <code>reverse_proxy</code> 中填写公网 IP 与端口。";
    }
  }
  if (els.serviceHint) {
    els.serviceHint.textContent =
      runtime === "docker" ? "当前为 Docker 运行时，按钮将控制容器。" : "当前为 systemd 运行时，按钮将控制服务。";
  }
}

function setUpdateState(text, mode = "info", target = "bot") {
  const config = getUpdateTargetConfig(target);
  const stateElement = document.querySelector(`#${config.stateId}`);
  if (!stateElement) {
    return;
  }
  stateElement.textContent = text;
  stateElement.classList.toggle("success", mode === "success");
  stateElement.classList.toggle("fail", mode === "fail");
}

function setUpdateHint(text, target = "bot") {
  const config = getUpdateTargetConfig(target);
  const hintElement = document.querySelector(`#${config.hintId}`);
  if (!hintElement) {
    return;
  }
  hintElement.textContent = text;
}

const updateActionLocks = {
  bot: false,
  panel: false
};

const updateProgressState = {
  bot: {
    value: 0,
    timer: null
  },
  panel: {
    value: 0,
    timer: null
  }
};

function setUpdateProgress(value = 0, { target = "bot", mode = "idle", text = "" } = {}) {
  const targetKey = normalizeUpdateTarget(target);
  const targetConfig = getUpdateTargetConfig(targetKey);
  const wrap = document.querySelector(`#${targetConfig.progressWrapId}`);
  const progress = document.querySelector(`#${targetConfig.progressBarId}`);
  const progressText = document.querySelector(`#${targetConfig.progressTextId}`);
  if (!wrap || !(progress instanceof HTMLProgressElement) || !progressText) {
    return;
  }

  const normalizedValue = Math.max(0, Math.min(100, Number(value) || 0));
  updateProgressState[targetKey].value = normalizedValue;
  progress.value = normalizedValue;
  progressText.textContent = text || `等待操作（${Math.round(normalizedValue)}%）`;
  wrap.classList.toggle("is-working", mode === "working");
  wrap.classList.toggle("is-done", mode === "done");
  wrap.classList.toggle("is-fail", mode === "fail");
}

function stopUpdateProgressTicker(target = "bot") {
  const targetKey = normalizeUpdateTarget(target);
  const timer = updateProgressState[targetKey].timer;
  if (timer) {
    clearInterval(timer);
    updateProgressState[targetKey].timer = null;
  }
}

function startUpdateProgressTicker(target = "bot", text = "正在处理...") {
  const targetKey = normalizeUpdateTarget(target);
  stopUpdateProgressTicker(targetKey);
  const initial = Math.max(updateProgressState[targetKey].value || 0, 10);
  setUpdateProgress(initial, {
    target: targetKey,
    mode: "working",
    text: `${text}（${Math.round(initial)}%）`
  });

  updateProgressState[targetKey].timer = setInterval(() => {
    const current = updateProgressState[targetKey].value || 0;
    if (current >= 92) {
      return;
    }
    const step = current < 55 ? 6 : 2;
    const next = Math.min(92, current + step);
    setUpdateProgress(next, {
      target: targetKey,
      mode: "working",
      text: `${text}（${Math.round(next)}%）`
    });
  }, 550);
}

function completeUpdateProgress(target = "bot", { success = true, text = "" } = {}) {
  const targetKey = normalizeUpdateTarget(target);
  stopUpdateProgressTicker(targetKey);
  setUpdateProgress(100, {
    target: targetKey,
    mode: success ? "done" : "fail",
    text: text || `${success ? "操作完成" : "操作失败"}（100%）`
  });
}

function setUpdateButtonsBusy(target = "bot", busy = false) {
  const targetKey = normalizeUpdateTarget(target);
  const targetConfig = getUpdateTargetConfig(targetKey);
  [
    targetConfig.checkButtonId,
    targetConfig.upgradeButtonId,
    targetConfig.rollbackButtonId,
    targetConfig.applyButtonId
  ]
    .filter(Boolean)
    .forEach((id) => {
      const button = document.querySelector(`#${id}`);
      if (!(button instanceof HTMLButtonElement)) {
        return;
      }
      button.disabled = Boolean(busy);
      button.setAttribute("aria-busy", busy ? "true" : "false");
    });
}

function initUpdateProgressState() {
  ["bot", "panel"].forEach((targetKey) => {
    setUpdateProgress(0, {
      target: targetKey,
      mode: "idle",
      text: "等待操作（0%）"
    });
  });
}

function hasNonEmptyChannelValue(value) {
  return String(value ?? "").trim().length > 0;
}

function isChannelConfigured(channelKey, channelSettings = {}) {
  if (!channelSettings || typeof channelSettings !== "object") {
    return false;
  }
  if (channelKey === "telegram") {
    return hasNonEmptyChannelValue(channelSettings.botToken);
  }
  if (channelKey === "feishu") {
    return hasNonEmptyChannelValue(channelSettings.appId) && hasNonEmptyChannelValue(channelSettings.appSecret);
  }
  if (channelKey === "discord") {
    return hasNonEmptyChannelValue(channelSettings.token);
  }
  if (channelKey === "slack") {
    const mode = String(channelSettings.mode || "socket").trim().toLowerCase();
    if (!hasNonEmptyChannelValue(channelSettings.botToken)) {
      return false;
    }
    return mode === "http"
      ? hasNonEmptyChannelValue(channelSettings.signingSecret)
      : hasNonEmptyChannelValue(channelSettings.appToken);
  }
  return false;
}

function setChannelAccessStatusTag(elementId, text, variant) {
  const tag = document.querySelector(`#${elementId}`);
  if (!tag) {
    return;
  }
  tag.textContent = text;
  if ("variant" in tag) {
    tag.variant = variant;
  } else {
    tag.className = `status-pill ${variant}`;
  }
}

function renderChannelAccessOverview(channels = {}) {
  const channelKeys = ["telegram", "feishu", "discord", "slack"];
  channelKeys.forEach((channelKey) => {
    const channelSettings = channels?.[channelKey] && typeof channels[channelKey] === "object" ? channels[channelKey] : {};
    const enabled = Boolean(channelSettings.enabled);
    const configured = isChannelConfigured(channelKey, channelSettings);
    const summary = document.querySelector(`#channel_status_${channelKey}_summary`);
    const card = document.querySelector(`[data-channel-card="${channelKey}"]`);
    const isDisabledCard = Boolean(card?.dataset?.channelDisabled === "true");

    setChannelAccessStatusTag(`channel_status_${channelKey}_enabled`, enabled ? "已启用" : "未启用", enabled ? "success" : "neutral");
    setChannelAccessStatusTag(
      `channel_status_${channelKey}_configured`,
      configured ? "已配置" : "未配置",
      configured ? "success" : "warning"
    );

    if (summary) {
      if (isDisabledCard) {
        summary.textContent = "功能开发中，暂不支持进入配置页。";
      } else if (configured && enabled) {
        summary.textContent = "配置完整，可直接使用。";
      } else if (configured) {
        summary.textContent = "配置已填，但当前处于未启用状态。";
      } else {
        summary.textContent = "还没填完关键凭证，点进去补齐即可。";
      }
    }

    if (card) {
      card.classList.toggle("is-ready", configured && enabled);
      card.classList.toggle("is-partial", configured && !enabled);
      card.classList.toggle("is-missing", !configured);
    }
  });
}

function readChannelString(id, fallback = "") {
  const element = document.querySelector(`#${id}`);
  if (!element) {
    return String(fallback ?? "");
  }
  return String(getInputValue(id) || "");
}

function readChannelBoolean(id, fallback = false) {
  const element = document.querySelector(`#${id}`);
  if (!element) {
    return Boolean(fallback);
  }
  return Boolean(getInputValue(id));
}

function normalizeOptionalPositiveInt(value) {
  const parsed = Number(value);
  if (!Number.isFinite(parsed) || parsed <= 0) {
    return null;
  }
  return Math.floor(parsed);
}

function normalizeOptionalNonNegativeInt(value) {
  const parsed = Number(value);
  if (!Number.isFinite(parsed) || parsed < 0) {
    return null;
  }
  return Math.floor(parsed);
}

function readChannelOptionalPositiveInt(id, fallback = null) {
  const element = document.querySelector(`#${id}`);
  if (!element) {
    return normalizeOptionalPositiveInt(fallback);
  }
  const raw = String(getInputValue(id) || "").trim();
  if (!raw) {
    return null;
  }
  return normalizeOptionalPositiveInt(raw);
}

function readChannelOptionalNonNegativeInt(id, fallback = null) {
  const element = document.querySelector(`#${id}`);
  if (!element) {
    return normalizeOptionalNonNegativeInt(fallback);
  }
  const raw = String(getInputValue(id) || "").trim();
  if (!raw) {
    return null;
  }
  return normalizeOptionalNonNegativeInt(raw);
}

function normalizeOptionalProbability(value) {
  const parsed = Number(value);
  if (!Number.isFinite(parsed) || parsed < 0 || parsed > 1) {
    return null;
  }
  return Number(parsed.toFixed(4));
}

function readChannelOptionalProbability(id, fallback = null) {
  const element = document.querySelector(`#${id}`);
  if (!element) {
    return normalizeOptionalProbability(fallback);
  }
  const raw = String(getInputValue(id) || "").trim();
  if (!raw) {
    return null;
  }
  return normalizeOptionalProbability(raw);
}

function readChannelTriStateBoolean(id, fallback = null) {
  const element = document.querySelector(`#${id}`);
  if (!element) {
    return typeof fallback === "boolean" ? fallback : null;
  }
  const value = String(getInputValue(id) || "default").trim().toLowerCase();
  if (value === "true") {
    return true;
  }
  if (value === "false") {
    return false;
  }
  return null;
}

function getChannelSnapshot() {
  const settings = channelSettingsSnapshot.settings;
  if (!settings || typeof settings !== "object") {
    return {};
  }
  const channels = settings.channels;
  if (!channels || typeof channels !== "object") {
    return {};
  }
  return channels;
}

const TELEGRAM_JSON_FIELD_RULES = Object.freeze([
  {
    elementId: "tg_groups_json",
    label: "群组覆盖（groupsJson）",
    expectedType: "object"
  },
  {
    elementId: "tg_accounts_json",
    label: "账号映射（accountsJson）",
    expectedType: "object"
  },
  {
    elementId: "tg_custom_commands_json",
    label: "自定义命令（customCommandsJson）",
    expectedType: "array"
  },
  {
    elementId: "tg_draft_chunk_json",
    label: "草稿分块（draftChunkJson）",
    expectedType: "object"
  }
]);

const TELEGRAM_ADVANCED_DEFAULT_INPUTS = Object.freeze({
  tg_enabled: false,
  tg_token_file: "",
  tg_dm_policy: "pairing",
  tg_allow_from: "",
  tg_group_policy: "allowlist",
  tg_group_allow_from: "",
  tg_require_mention: true,
  tg_stream_mode: "partial",
  tg_chunk_mode: "length",
  tg_text_chunk_limit: "",
  tg_reply_to_mode: "off",
  tg_link_preview: true,
  tg_block_streaming: false,
  tg_timeout_seconds: "",
  tg_media_max_mb: "",
  tg_dm_history_limit: "",
  tg_history_limit: "",
  tg_webhook_url: "",
  tg_webhook_secret: "",
  tg_webhook_path: "/telegram-webhook",
  tg_proxy: "",
  tg_config_writes: true,
  tg_reaction_level: "minimal",
  tg_reaction_notifications: "own",
  tg_inline_buttons: "allowlist",
  tg_action_send_message: true,
  tg_action_reactions: true,
  tg_action_delete_message: true,
  tg_action_sticker: false,
  tg_network_auto_select_family: "default",
  tg_retry_attempts: "",
  tg_retry_min_delay_ms: "",
  tg_retry_max_delay_ms: "",
  tg_retry_jitter: "",
  tg_commands_native: "default",
  tg_groups_json: "",
  tg_accounts_json: "",
  tg_custom_commands_json: "",
  tg_draft_chunk_json: ""
});

function validateOptionalJsonField(elementId, label, expectedType) {
  const element = document.querySelector(`#${elementId}`);
  if (!element) {
    return;
  }
  const text = String(getInputValue(elementId) || "").trim();
  if (!text) {
    return;
  }

  let parsed;
  try {
    parsed = JSON.parse(text);
  } catch {
    throw new Error(`${label} JSON 格式不正确，请检查括号与引号。`);
  }

  const isArray = Array.isArray(parsed);
  if (expectedType === "array" && !isArray) {
    throw new Error(`${label} 必须是 JSON 数组。`);
  }
  if (expectedType === "object" && (!parsed || typeof parsed !== "object" || isArray)) {
    throw new Error(`${label} 必须是 JSON 对象。`);
  }
}

function validateTelegramJsonOverrides() {
  TELEGRAM_JSON_FIELD_RULES.forEach((rule) => {
    validateOptionalJsonField(rule.elementId, `Telegram ${rule.label}`, rule.expectedType);
  });
}

function applyTelegramAdvancedDefaults() {
  Object.entries(TELEGRAM_ADVANCED_DEFAULT_INPUTS).forEach(([elementId, value]) => {
    setInput(elementId, value);
  });
}

async function resetTelegramAdvancedSettings() {
  const shouldReset = window.confirm("将 Telegram 高级配置重置为默认值并立即保存，是否继续？");
  if (!shouldReset) {
    setMessage("已取消重置 Telegram 高级配置", "info");
    return;
  }

  applyTelegramAdvancedDefaults();
  await saveSettings();
  setMessage("Telegram 高级配置已重置为默认值并保存", "ok");
}

function collectChannelSettings() {
  const snapshot = getChannelSnapshot();
  const telegramSnapshot = snapshot.telegram && typeof snapshot.telegram === "object" ? snapshot.telegram : {};
  const feishuSnapshot = snapshot.feishu && typeof snapshot.feishu === "object" ? snapshot.feishu : {};
  const discordSnapshot = snapshot.discord && typeof snapshot.discord === "object" ? snapshot.discord : {};
  const slackSnapshot = snapshot.slack && typeof snapshot.slack === "object" ? snapshot.slack : {};

  return {
    telegram: {
      enabled: readChannelBoolean("tg_enabled", telegramSnapshot.enabled),
      botToken: readChannelString("tg_bot_token", telegramSnapshot.botToken),
      tokenFile: readChannelString("tg_token_file", telegramSnapshot.tokenFile),
      dmPolicy: readChannelString("tg_dm_policy", telegramSnapshot.dmPolicy || "pairing") || "pairing",
      allowFrom: readChannelString("tg_allow_from", telegramSnapshot.allowFrom),
      groupPolicy: readChannelString("tg_group_policy", telegramSnapshot.groupPolicy || "allowlist") || "allowlist",
      groupAllowFrom: readChannelString("tg_group_allow_from", telegramSnapshot.groupAllowFrom),
      requireMention: readChannelBoolean("tg_require_mention", telegramSnapshot.requireMention),
      streamMode: readChannelString("tg_stream_mode", telegramSnapshot.streamMode || "partial") || "partial",
      chunkMode: readChannelString("tg_chunk_mode", telegramSnapshot.chunkMode || "length") || "length",
      textChunkLimit: readChannelOptionalPositiveInt("tg_text_chunk_limit", telegramSnapshot.textChunkLimit),
      replyToMode: readChannelString("tg_reply_to_mode", telegramSnapshot.replyToMode || "off") || "off",
      linkPreview: readChannelBoolean("tg_link_preview", telegramSnapshot.linkPreview),
      blockStreaming: readChannelBoolean("tg_block_streaming", telegramSnapshot.blockStreaming),
      timeoutSeconds: readChannelOptionalPositiveInt("tg_timeout_seconds", telegramSnapshot.timeoutSeconds),
      mediaMaxMb: readChannelOptionalPositiveInt("tg_media_max_mb", telegramSnapshot.mediaMaxMb),
      dmHistoryLimit: readChannelOptionalNonNegativeInt("tg_dm_history_limit", telegramSnapshot.dmHistoryLimit),
      historyLimit: readChannelOptionalNonNegativeInt("tg_history_limit", telegramSnapshot.historyLimit),
      webhookUrl: readChannelString("tg_webhook_url", telegramSnapshot.webhookUrl),
      webhookSecret: readChannelString("tg_webhook_secret", telegramSnapshot.webhookSecret),
      webhookPath: readChannelString("tg_webhook_path", telegramSnapshot.webhookPath || "/telegram-webhook"),
      proxy: readChannelString("tg_proxy", telegramSnapshot.proxy),
      configWrites: readChannelBoolean("tg_config_writes", telegramSnapshot.configWrites),
      reactionLevel: readChannelString("tg_reaction_level", telegramSnapshot.reactionLevel || "minimal") || "minimal",
      reactionNotifications:
        readChannelString("tg_reaction_notifications", telegramSnapshot.reactionNotifications || "own") || "own",
      inlineButtons: readChannelString("tg_inline_buttons", telegramSnapshot.inlineButtons || "allowlist") || "allowlist",
      actionSendMessage: readChannelBoolean("tg_action_send_message", telegramSnapshot.actionSendMessage),
      actionReactions: readChannelBoolean("tg_action_reactions", telegramSnapshot.actionReactions),
      actionDeleteMessage: readChannelBoolean("tg_action_delete_message", telegramSnapshot.actionDeleteMessage),
      actionSticker: readChannelBoolean("tg_action_sticker", telegramSnapshot.actionSticker),
      networkAutoSelectFamily: readChannelTriStateBoolean(
        "tg_network_auto_select_family",
        telegramSnapshot.networkAutoSelectFamily
      ),
      retryAttempts: readChannelOptionalPositiveInt("tg_retry_attempts", telegramSnapshot.retryAttempts),
      retryMinDelayMs: readChannelOptionalPositiveInt("tg_retry_min_delay_ms", telegramSnapshot.retryMinDelayMs),
      retryMaxDelayMs: readChannelOptionalPositiveInt("tg_retry_max_delay_ms", telegramSnapshot.retryMaxDelayMs),
      retryJitter: readChannelOptionalProbability("tg_retry_jitter", telegramSnapshot.retryJitter),
      commandsNative: readChannelString("tg_commands_native", telegramSnapshot.commandsNative || "default") || "default",
      groupsJson: readChannelString("tg_groups_json", telegramSnapshot.groupsJson),
      accountsJson: readChannelString("tg_accounts_json", telegramSnapshot.accountsJson),
      customCommandsJson: readChannelString("tg_custom_commands_json", telegramSnapshot.customCommandsJson),
      draftChunkJson: readChannelString("tg_draft_chunk_json", telegramSnapshot.draftChunkJson)
    },
    feishu: {
      enabled: readChannelBoolean("fs_enabled", feishuSnapshot.enabled),
      appId: readChannelString("fs_app_id", feishuSnapshot.appId),
      appSecret: readChannelString("fs_app_secret", feishuSnapshot.appSecret),
      domain: readChannelString("fs_domain", feishuSnapshot.domain || "feishu") || "feishu",
      connectionMode: readChannelString("fs_connection_mode", feishuSnapshot.connectionMode || "websocket") || "websocket",
      dmPolicy: readChannelString("fs_dm_policy", feishuSnapshot.dmPolicy || "pairing") || "pairing",
      allowFrom: readChannelString("fs_allow_from", feishuSnapshot.allowFrom),
      groupPolicy: readChannelString("fs_group_policy", feishuSnapshot.groupPolicy || "allowlist") || "allowlist",
      groupAllowFrom: readChannelString("fs_group_allow_from", feishuSnapshot.groupAllowFrom),
      requireMention: readChannelBoolean("fs_require_mention", feishuSnapshot.requireMention)
    },
    discord: {
      enabled: readChannelBoolean("dc_enabled", discordSnapshot.enabled),
      token: readChannelString("dc_token", discordSnapshot.token),
      dmPolicy: readChannelString("dc_dm_policy", discordSnapshot.dmPolicy || "pairing") || "pairing",
      allowFrom: readChannelString("dc_allow_from", discordSnapshot.allowFrom),
      groupPolicy: readChannelString("dc_group_policy", discordSnapshot.groupPolicy || "allowlist") || "allowlist",
      allowBots: readChannelBoolean("dc_allow_bots", discordSnapshot.allowBots),
      requireMention: readChannelBoolean("dc_require_mention", discordSnapshot.requireMention)
    },
    slack: {
      enabled: readChannelBoolean("sl_enabled", slackSnapshot.enabled),
      mode: readChannelString("sl_mode", slackSnapshot.mode || "socket") || "socket",
      botToken: readChannelString("sl_bot_token", slackSnapshot.botToken),
      appToken: readChannelString("sl_app_token", slackSnapshot.appToken),
      signingSecret: readChannelString("sl_signing_secret", slackSnapshot.signingSecret),
      dmPolicy: readChannelString("sl_dm_policy", slackSnapshot.dmPolicy || "pairing") || "pairing",
      allowFrom: readChannelString("sl_allow_from", slackSnapshot.allowFrom),
      groupPolicy: readChannelString("sl_group_policy", slackSnapshot.groupPolicy || "allowlist") || "allowlist",
      allowBots: readChannelBoolean("sl_allow_bots", slackSnapshot.allowBots),
      requireMention: readChannelBoolean("sl_require_mention", slackSnapshot.requireMention)
    }
  };
}

function fillSettings(settings) {
  renderDashboardModelCards(settings.model);
  fillModelEditor(settings.model);
  renderChannelAccessOverview(settings.channels || {});

  setInput("tg_enabled", settings.channels.telegram.enabled);
  setInput("tg_bot_token", settings.channels.telegram.botToken);
  setInput("tg_token_file", settings.channels.telegram.tokenFile);
  setInput("tg_dm_policy", settings.channels.telegram.dmPolicy);
  setInput("tg_allow_from", settings.channels.telegram.allowFrom);
  setInput("tg_group_policy", settings.channels.telegram.groupPolicy);
  setInput("tg_group_allow_from", settings.channels.telegram.groupAllowFrom);
  setInput("tg_require_mention", settings.channels.telegram.requireMention);
  setInput("tg_stream_mode", settings.channels.telegram.streamMode);
  setInput("tg_chunk_mode", settings.channels.telegram.chunkMode);
  setInput("tg_text_chunk_limit", settings.channels.telegram.textChunkLimit ?? "");
  setInput("tg_reply_to_mode", settings.channels.telegram.replyToMode);
  setInput("tg_link_preview", settings.channels.telegram.linkPreview);
  setInput("tg_block_streaming", settings.channels.telegram.blockStreaming);
  setInput("tg_timeout_seconds", settings.channels.telegram.timeoutSeconds ?? "");
  setInput("tg_media_max_mb", settings.channels.telegram.mediaMaxMb ?? "");
  setInput("tg_dm_history_limit", settings.channels.telegram.dmHistoryLimit ?? "");
  setInput("tg_history_limit", settings.channels.telegram.historyLimit ?? "");
  setInput("tg_webhook_url", settings.channels.telegram.webhookUrl);
  setInput("tg_webhook_secret", settings.channels.telegram.webhookSecret);
  setInput("tg_webhook_path", settings.channels.telegram.webhookPath || "/telegram-webhook");
  setInput("tg_proxy", settings.channels.telegram.proxy);
  setInput("tg_config_writes", settings.channels.telegram.configWrites);
  setInput("tg_reaction_level", settings.channels.telegram.reactionLevel);
  setInput("tg_reaction_notifications", settings.channels.telegram.reactionNotifications);
  setInput("tg_inline_buttons", settings.channels.telegram.inlineButtons);
  setInput("tg_action_send_message", settings.channels.telegram.actionSendMessage);
  setInput("tg_action_reactions", settings.channels.telegram.actionReactions);
  setInput("tg_action_delete_message", settings.channels.telegram.actionDeleteMessage);
  setInput("tg_action_sticker", settings.channels.telegram.actionSticker);
  setInput(
    "tg_network_auto_select_family",
    settings.channels.telegram.networkAutoSelectFamily === null
      ? "default"
      : settings.channels.telegram.networkAutoSelectFamily
      ? "true"
      : "false"
  );
  setInput("tg_retry_attempts", settings.channels.telegram.retryAttempts ?? "");
  setInput("tg_retry_min_delay_ms", settings.channels.telegram.retryMinDelayMs ?? "");
  setInput("tg_retry_max_delay_ms", settings.channels.telegram.retryMaxDelayMs ?? "");
  setInput("tg_retry_jitter", settings.channels.telegram.retryJitter ?? "");
  setInput("tg_commands_native", settings.channels.telegram.commandsNative || "default");
  setInput("tg_groups_json", settings.channels.telegram.groupsJson || "");
  setInput("tg_accounts_json", settings.channels.telegram.accountsJson || "");
  setInput("tg_custom_commands_json", settings.channels.telegram.customCommandsJson || "");
  setInput("tg_draft_chunk_json", settings.channels.telegram.draftChunkJson || "");

  setInput("fs_enabled", settings.channels.feishu.enabled);
  setInput("fs_app_id", settings.channels.feishu.appId);
  setInput("fs_app_secret", settings.channels.feishu.appSecret);
  setInput("fs_domain", settings.channels.feishu.domain);
  setInput("fs_connection_mode", settings.channels.feishu.connectionMode);
  setInput("fs_dm_policy", settings.channels.feishu.dmPolicy);
  setInput("fs_allow_from", settings.channels.feishu.allowFrom);
  setInput("fs_group_policy", settings.channels.feishu.groupPolicy);
  setInput("fs_group_allow_from", settings.channels.feishu.groupAllowFrom);
  setInput("fs_require_mention", settings.channels.feishu.requireMention);

  setInput("dc_enabled", settings.channels.discord.enabled);
  setInput("dc_token", settings.channels.discord.token);
  setInput("dc_dm_policy", settings.channels.discord.dmPolicy);
  setInput("dc_allow_from", settings.channels.discord.allowFrom);
  setInput("dc_group_policy", settings.channels.discord.groupPolicy);
  setInput("dc_allow_bots", settings.channels.discord.allowBots);
  setInput("dc_require_mention", settings.channels.discord.requireMention);

  setInput("sl_enabled", settings.channels.slack.enabled);
  setInput("sl_mode", settings.channels.slack.mode);
  setInput("sl_bot_token", settings.channels.slack.botToken);
  setInput("sl_app_token", settings.channels.slack.appToken);
  setInput("sl_signing_secret", settings.channels.slack.signingSecret);
  setInput("sl_dm_policy", settings.channels.slack.dmPolicy);
  setInput("sl_allow_from", settings.channels.slack.allowFrom);
  setInput("sl_group_policy", settings.channels.slack.groupPolicy);
  setInput("sl_allow_bots", settings.channels.slack.allowBots);
  setInput("sl_require_mention", settings.channels.slack.requireMention);
}

async function loadInitialData() {
  const [panelConfig, settings] = await Promise.all([api("/api/panel-config"), api("/api/settings")]);
  channelSettingsSnapshot.settings = settings.settings || null;
  initUpdateProgressState();
  fillPanelMeta(panelConfig.config, panelConfig.deployment || {});
  fillSettings(settings.settings);
}

async function checkUpdate({ silent = false, target = "bot" } = {}) {
  const targetKey = normalizeUpdateTarget(target);
  const targetConfig = getUpdateTargetConfig(targetKey);
  const result = await api(`/api/update/check?target=${encodeURIComponent(targetKey)}`);
  const data = result.result || {};

  setInput(targetConfig.currentTagId, data.currentTag || "");
  setInput(targetConfig.latestTagId, data.latestTag || "");
  if (!String(getInputValue(targetConfig.targetTagId) || "").trim() && data.latestTag) {
    setInput(targetConfig.targetTagId, data.latestTag);
  }

  if (data.warning) {
    setUpdateState("检查异常", "fail", targetKey);
    setUpdateHint(`已读取当前版本，但远程版本检查失败：${data.warning}`, targetKey);
    if (targetKey === "bot") {
      updateDashboardVersionSummary(data);
    }
    if (!silent) {
      setMessage(`${targetConfig.label} 更新检查告警：${data.warning}`, "error");
    }
    return data;
  }

  if (data.updateAvailable) {
    setUpdateState("有可用更新", "success", targetKey);
    setUpdateHint(`当前 ${data.currentTag || "-"}，最新 ${data.latestTag || "-"}`, targetKey);
  } else {
    setUpdateState("已是最新", "success", targetKey);
    setUpdateHint(`当前 ${data.currentTag || "-"}，无需升级`, targetKey);
  }
  if (targetKey === "bot") {
    updateDashboardVersionSummary(data);
  }
  if (!silent) {
    setMessage(
      `${targetConfig.label} 版本检查完成：current=${data.currentTag || "-"} latest=${data.latestTag || "-"}`,
      "ok"
    );
  }
  return data;
}

async function checkAllUpdates({ silent = false } = {}) {
  const results = await Promise.allSettled([
    checkUpdate({ silent, target: "bot" }),
    checkUpdate({ silent, target: "panel" })
  ]);
  const firstError = results.find((item) => item.status === "rejected");
  if (firstError && firstError.status === "rejected") {
    throw firstError.reason;
  }
}

async function resolveUpgradeTargetTag(rawTag = "", target = "bot") {
  const targetKey = normalizeUpdateTarget(target);
  const targetConfig = getUpdateTargetConfig(targetKey);
  const directTag = String(rawTag || "").trim();
  if (directTag) {
    return directTag;
  }

  const latestInput = String(getInputValue(targetConfig.latestTagId) || "").trim();
  if (latestInput) {
    setInput(targetConfig.targetTagId, latestInput);
    return latestInput;
  }

  const result = await api(`/api/update/check?target=${encodeURIComponent(targetKey)}`);
  const latestTag = String(result?.result?.latestTag || "").trim();
  if (!latestTag) {
    throw new Error("无法自动获取最新版本，请先点击“检查新版本”或手工填写目标版本");
  }
  setInput(targetConfig.latestTagId, latestTag);
  setInput(targetConfig.targetTagId, latestTag);
  return latestTag;
}

async function mutateVersion(action, { target = "bot" } = {}) {
  const targetKey = normalizeUpdateTarget(target);
  const targetConfig = getUpdateTargetConfig(targetKey);
  if (updateActionLocks[targetKey]) {
    setMessage(`${targetConfig.label} 正在执行更新操作，请稍候`, "info");
    return;
  }

  const actionLabelMap = {
    upgrade: "升级",
    rollback: "回滚",
    apply: "重启并应用"
  };
  const actionLabel = actionLabelMap[action] || "更新";
  let tag = String(getInputValue(targetConfig.targetTagId) || "").trim();
  if (!tag && (action === "upgrade" || action === "apply")) {
    tag = await resolveUpgradeTargetTag(tag, targetKey);
    setMessage(`${targetConfig.label} 未填写目标版本，已自动选择最新版本：${tag}`, "info");
  }
  if (!tag) {
    if (action === "rollback") {
      throw new Error("请先输入回滚目标版本");
    }
    throw new Error("请先输入目标版本");
  }

  updateActionLocks[targetKey] = true;
  setUpdateButtonsBusy(targetKey, true);
  setUpdateState(`${actionLabel}进行中`, "info", targetKey);
  setUpdateHint(`${actionLabel}执行中，请稍候...`, targetKey);
  startUpdateProgressTicker(targetKey, `${actionLabel}执行中`);

  try {
    const endpoint = action === "apply" ? "/api/update/apply" : `/api/update/${action}`;
    const result = await api(endpoint, {
      method: "POST",
      body: JSON.stringify({ tag, target: targetKey }),
      allowBusinessError: true
    });
    const payload = result.result || {};
    if (payload.ok) {
      const targetImageTag = String(payload.targetImage || "")
        .trim()
        .split(":")
        .pop();
      const oldImageTag = String(payload.oldImage || "")
        .trim()
        .split(":")
        .pop();

      if (targetKey === "panel" && action !== "apply") {
        const successText = action === "upgrade" ? "更新包已准备" : "回滚包已准备";
        setUpdateState(successText, "success", targetKey);
        setUpdateHint(payload.message || "版本包已准备完成，请点击“应用更新并重启”生效", targetKey);
        // stage-only flow: keep current tag as running version until apply step restarts the panel service
        setInput(targetConfig.currentTagId, oldImageTag || "");
        if (targetImageTag) {
          setInput(targetConfig.targetTagId, targetImageTag);
        }
        completeUpdateProgress(targetKey, { success: true, text: `${actionLabel}完成（100%）` });
        setMessage(`${targetConfig.label}${actionLabel}成功：${payload.targetImage}`, "ok");
        return;
      }

      const successStateText =
        action === "apply" ? "已重启并应用" : action === "upgrade" ? "升级成功" : "回滚成功";
      setUpdateState(successStateText, "success", targetKey);
      setUpdateHint(payload.message || `当前版本：${payload.targetImage || "-"}`, targetKey);
      setInput(targetConfig.currentTagId, targetImageTag || tag);
      completeUpdateProgress(targetKey, { success: true, text: `${actionLabel}完成（100%）` });
      setMessage(`${targetConfig.label}${actionLabel}成功：${payload.targetImage}`, "ok");

      await checkUpdate({ silent: true, target: targetKey }).catch(() => {});
      if (targetKey === "bot") {
        await runService("status").catch(() => {});
        await loadTail().catch(() => {});
      }
      if (targetKey === "panel" && action === "apply" && payload.requiresReconnect) {
        const reconnectDelay = Math.max(2000, Number(payload.reconnectAfterMs) || 6000);
        setMessage(`控制台正在重启，页面将在约 ${Math.ceil(reconnectDelay / 1000)} 秒后自动刷新`, "info");
        window.setTimeout(() => {
          window.location.reload();
        }, reconnectDelay);
      }
      return;
    }

    const rollbackNote = payload.rollbackMessage ? `；${payload.rollbackMessage}` : payload.rolledBack ? "；已自动回滚" : "";
    const detail = `${payload.message || "操作失败"}${rollbackNote}`;
    const failText = action === "apply" ? "应用失败" : action === "upgrade" ? "升级失败" : "回滚失败";
    setUpdateState(failText, "fail", targetKey);
    setUpdateHint(detail, targetKey);
    completeUpdateProgress(targetKey, { success: false, text: `${actionLabel}失败（100%）` });
    setMessage(`${targetConfig.label}${actionLabel}失败：${detail}`, "error");
  } catch (error) {
    const detail = error?.message || String(error);
    const failText = action === "apply" ? "应用失败" : action === "upgrade" ? "升级失败" : "回滚失败";
    setUpdateState(failText, "fail", targetKey);
    setUpdateHint(detail, targetKey);
    completeUpdateProgress(targetKey, { success: false, text: `${actionLabel}失败（100%）` });
    setMessage(`${targetConfig.label}${actionLabel}异常：${detail}`, "error");
  } finally {
    updateActionLocks[targetKey] = false;
    setUpdateButtonsBusy(targetKey, false);
  }
}

async function saveModelSettings(modelPayload, actionLabel) {
  const payload = {
    model: modelPayload
  };
  const result = await api("/api/settings", {
    method: "PUT",
    body: JSON.stringify(payload)
  });
  modelEditorState.currentModelPayload = modelPayload;
  setMessage(`${actionLabel}：${result.path}`, "ok");
  await loadInitialData();
}

async function saveSettings() {
  if (!modelEditorState.currentModelPayload) {
    throw new Error("模型配置尚未初始化，请刷新页面后重试");
  }
  validateTelegramJsonOverrides();
  const payload = {
    model: modelEditorState.currentModelPayload,
    channels: collectChannelSettings()
  };
  const result = await api("/api/settings", {
    method: "PUT",
    body: JSON.stringify(payload)
  });
  setMessage(`平台接入配置写入成功（模型保持当前值）：${result.path}`, "ok");
  await loadInitialData();
}

async function runService(action, { silentMessage = false, autoRefresh = true } = {}) {
  const result = await api(`/api/service/${action}`, {
    method: "POST",
    allowBusinessError: true
  });
  const payload = result.result || {};
  const output = payload.output || payload.message || "(empty)";
  if (els.serviceOutput) {
    els.serviceOutput.textContent = output;
  }

  if (!result.ok) {
    if (action === "status" && els.serviceState && els.serviceHint) {
      els.serviceState.textContent = "状态异常";
      els.serviceState.classList.toggle("success", false);
      els.serviceState.classList.toggle("fail", true);
      els.serviceHint.textContent = payload.message || "服务状态读取失败，请检查容器或 systemd 权限。";
    }
    if (autoRefresh && action !== "status" && els.serviceState && els.serviceHint) {
      try {
        await runService("status", { silentMessage: true, autoRefresh: false });
      } catch {
        // ignore refresh errors on failure branch; primary error is already surfaced
      }
    }
    if (!silentMessage) {
      setMessage(`service ${action}: 失败 - ${payload.message || payload.output || "未知错误"}`, "error");
    }
    return;
  }

  if (action === "status" && els.serviceState && els.serviceHint) {
    const active = Boolean(payload.active);
    els.serviceState.textContent = active ? "运行中" : "未运行";
    els.serviceState.classList.toggle("success", active);
    els.serviceState.classList.toggle("fail", !active);
    els.serviceHint.textContent = active
      ? "服务状态正常。你可以继续联调渠道或查看日志。"
      : "服务未运行。请先启动或检查 systemd 权限。";
  }
  if (!silentMessage) {
    setMessage(`service ${action}: 成功`, "ok");
  }

  if (autoRefresh && action !== "status" && els.serviceState && els.serviceHint) {
    try {
      await runService("status", { silentMessage: true, autoRefresh: false });
      if (!silentMessage) {
        setMessage("服务状态已自动刷新", "info");
      }
    } catch (error) {
      if (!silentMessage) {
        setMessage(`服务状态自动刷新失败：${error.message || String(error)}`, "error");
      }
    }
  }
}

async function loadTail() {
  if (!els.logOutput) {
    return;
  }
  const filter = encodeURIComponent(String(getInputValue("log_filter") || ""));
  const result = await api(`/api/logs/tail?lines=200&filter=${filter}`);
  els.logOutput.textContent = result.lines.join("\n");
  setMessage(`日志加载完成，共 ${result.lines.length} 行`, "ok");
}

async function loadErrorSummary({ silent = false } = {}) {
  const result = await api("/api/logs/errors?count=20");
  if (els.errorSummary) {
    els.errorSummary.innerHTML = "";
    result.lines.forEach((line) => {
      const li = document.createElement("li");
      li.textContent = line;
      els.errorSummary.appendChild(li);
    });
  }
  updateDashboardErrorSummary(result.lines);
  if (!silent) {
    setMessage(`错误摘要加载完成，共 ${result.lines.length} 条`, "ok");
  }
}

function stopStream() {
  if (stream) {
    stream.close();
    stream = null;
    setMessage("实时日志流已停止", "info");
  }
}

function startStream() {
  stopStream();
  if (!els.logOutput) {
    throw new Error("当前页面未加载日志面板");
  }
  const filter = encodeURIComponent(String(getInputValue("log_filter") || ""));
  stream = new EventSource(`/api/logs/stream?filter=${filter}`);
  stream.addEventListener("line", (event) => {
    const payload = JSON.parse(event.data);
    const next = `${payload.line}\n${els.logOutput.textContent}`;
    els.logOutput.textContent = next.slice(0, 30000);
  });
  stream.addEventListener("error", () => {
    setMessage("日志流出现错误，请检查日志来源配置", "error");
  });
  setMessage("实时日志流已启动", "ok");
}

function setChannelTestResult(elementId, detail, success) {
  const el = document.querySelector(`#${elementId}`);
  if (!el) {
    return;
  }
  const timestamp = new Date().toLocaleTimeString();
  el.textContent = `最近测试（${timestamp}）：${success ? "成功" : "失败"} - ${detail}`;
  el.classList.toggle("success", Boolean(success));
  el.classList.toggle("fail", !success);
}

function setChannelActionResult(elementId, detail, success) {
  const el = document.querySelector(`#${elementId}`);
  if (!el) {
    return;
  }
  const timestamp = new Date().toLocaleTimeString();
  el.textContent = `最近执行（${timestamp}）：${detail}`;
  if (success === null) {
    el.classList.remove("success", "fail");
    return;
  }
  el.classList.toggle("success", Boolean(success));
  el.classList.toggle("fail", !success);
}

function renderTelegramTrace(elementId, steps = []) {
  const trace = document.querySelector(`#${elementId}`);
  if (!trace) {
    return;
  }
  if (!Array.isArray(steps) || steps.length === 0) {
    trace.textContent = "暂无执行记录";
    return;
  }

  const lines = [];
  steps.forEach((step, index) => {
    const label = String(step?.label || `步骤 ${index + 1}`).trim();
    const statusText = step?.ok ? "成功" : "失败";
    const command = String(step?.command || "").trim();
    const output = String(step?.output || "").trim() || "(无输出)";
    lines.push(`[${index + 1}] ${label} - ${statusText}`);
    if (command) {
      lines.push(`命令: ${command}`);
    }
    lines.push(`输出: ${output}`);
    lines.push("");
  });
  trace.textContent = lines.join("\n").trim();
}

const telegramFlowLocks = {
  setup: false,
  pairing: false
};

function setActionButtonBusy(buttonId, busy, busyLabel) {
  const button = document.querySelector(`#${buttonId}`);
  if (!(button instanceof HTMLButtonElement)) {
    return;
  }
  if (!button.dataset.originalLabel) {
    button.dataset.originalLabel = String(button.textContent || "").trim();
  }
  button.disabled = Boolean(busy);
  button.setAttribute("aria-busy", busy ? "true" : "false");
  button.textContent = busy ? busyLabel : button.dataset.originalLabel;
}

async function runTelegramFlowWithLock({
  lockKey,
  buttonId,
  busyLabel,
  pendingResultId,
  pendingDetail,
  duplicateClickMessage,
  pendingMessage,
  run
}) {
  if (telegramFlowLocks[lockKey]) {
    if (duplicateClickMessage) {
      setMessage(duplicateClickMessage, "info");
    }
    return;
  }

  telegramFlowLocks[lockKey] = true;
  setActionButtonBusy(buttonId, true, busyLabel);
  if (pendingResultId && pendingDetail) {
    setChannelActionResult(pendingResultId, pendingDetail, null);
  }
  if (pendingMessage) {
    setMessage(pendingMessage, "info");
  }

  try {
    await run();
  } finally {
    telegramFlowLocks[lockKey] = false;
    setActionButtonBusy(buttonId, false, busyLabel);
  }
}

async function setupTelegramBasicFlow() {
  const botToken = String(getInputValue("tg_bot_token") || "").trim();
  if (!botToken) {
    setChannelActionResult("tg_setup_result", "失败：请先填写 Bot Token", false);
    throw new Error("Telegram 基础配置失败：Bot Token 不能为空");
  }

  await runTelegramFlowWithLock({
    lockKey: "setup",
    buttonId: "tg_setup_basic",
    busyLabel: "保存中...",
    pendingResultId: "tg_setup_result",
    pendingDetail: "处理中：正在启用 Telegram 插件并写入 Bot Token",
    duplicateClickMessage: "Telegram 基础配置正在处理中，请勿重复点击",
    pendingMessage: "Telegram 基础配置处理中，请稍候…",
    run: async () => {
      const result = await api("/api/channels/telegram/setup", {
        method: "POST",
        body: JSON.stringify({ botToken }),
        allowBusinessError: true
      });
      const payload = result.result && typeof result.result === "object" ? result.result : {};
      const steps = Array.isArray(payload.steps) ? payload.steps : [];
      renderTelegramTrace("tg_setup_trace", steps);

      if (!result.ok || payload.ok === false) {
        const detail = String(payload.message || result.message || "Telegram 基础配置失败");
        setChannelActionResult("tg_setup_result", `失败：${detail}`, false);
        setMessage(`Telegram 基础配置失败：${detail}`, "error");
        return;
      }

      const detail = String(payload.message || "Telegram 基础配置完成");
      setChannelActionResult("tg_setup_result", `成功：${detail}`, true);
      setMessage(detail, "ok");
      await loadInitialData();
    }
  });
}

async function approveTelegramPairingFlow() {
  const code = String(getInputValue("tg_pairing_code") || "").trim();
  if (!code) {
    setChannelActionResult("tg_pairing_result", "失败：请先填写验证码", false);
    throw new Error("Telegram 配对失败：验证码不能为空");
  }

  await runTelegramFlowWithLock({
    lockKey: "pairing",
    buttonId: "tg_pairing_approve",
    busyLabel: "验证中...",
    pendingResultId: "tg_pairing_result",
    pendingDetail: "处理中：正在提交验证码并等待验证结果",
    duplicateClickMessage: "Telegram 验证正在处理中，请勿重复点击",
    pendingMessage: "Telegram 验证处理中，请稍候…",
    run: async () => {
      const result = await api("/api/channels/telegram/pairing/approve", {
        method: "POST",
        body: JSON.stringify({ code }),
        allowBusinessError: true
      });
      const payload = result.result && typeof result.result === "object" ? result.result : {};
      const step = payload.step && typeof payload.step === "object" ? payload.step : null;
      if (step) {
        renderTelegramTrace("tg_pairing_trace", [step]);
      }

      if (!result.ok || payload.ok === false) {
        const detail = String(payload.message || result.message || "验证码验证失败");
        setChannelActionResult("tg_pairing_result", `失败：${detail}`, false);
        setMessage(`Telegram 配对失败：${detail}`, "error");
        return;
      }

      const detail = String(payload.message || "验证码验证成功");
      setChannelActionResult("tg_pairing_result", `成功：${detail}`, true);
      setMessage(detail, "ok");
    }
  });
}

async function saveAndTestTelegram() {
  const botToken = String(getInputValue("tg_bot_token") || "").trim();
  await saveSettings();
  if (botToken) {
    setInput("tg_bot_token", botToken);
  }
  await testTelegram();
}

async function saveAndTestFeishu() {
  const appId = String(getInputValue("fs_app_id") || "").trim();
  const appSecret = String(getInputValue("fs_app_secret") || "").trim();
  await saveSettings();
  if (appId) {
    setInput("fs_app_id", appId);
  }
  if (appSecret) {
    setInput("fs_app_secret", appSecret);
  }
  await testFeishu();
}

async function testTelegram() {
  const payload = {
    botToken: String(getInputValue("tg_bot_token") || "")
  };
  if (!payload.botToken) {
    setChannelTestResult("tg_test_result", "失败：请先填写 Bot Token", false);
    throw new Error("Telegram 测试失败：Bot Token 不能为空");
  }
  const result = await api("/api/test/telegram", {
    method: "POST",
    body: JSON.stringify(payload),
    allowBusinessError: true
  });
  setChannelTestResult("tg_test_result", result.message || "-", result.ok);
  setMessage(`Telegram 测试：${result.message}`, result.ok ? "ok" : "error");
}

async function testFeishu() {
  const payload = {
    appId: String(getInputValue("fs_app_id") || ""),
    appSecret: String(getInputValue("fs_app_secret") || "")
  };
  if (!payload.appId || !payload.appSecret) {
    setChannelTestResult("fs_test_result", "失败：请先填写 App ID 与 App Secret", false);
    throw new Error("Feishu 测试失败：App ID / App Secret 不能为空");
  }
  const result = await api("/api/test/feishu", {
    method: "POST",
    body: JSON.stringify(payload),
    allowBusinessError: true
  });
  setChannelTestResult("fs_test_result", result.message || "-", result.ok);
  setMessage(`Feishu 测试：${result.message}`, result.ok ? "ok" : "error");
}

async function testDiscord() {
  const payload = {
    token: String(getInputValue("dc_token") || "")
  };
  if (!payload.token) {
    setChannelTestResult("dc_test_result", "失败：请先填写 Discord Bot Token", false);
    throw new Error("Discord 测试失败：Bot Token 不能为空");
  }
  const result = await api("/api/test/discord", {
    method: "POST",
    body: JSON.stringify(payload),
    allowBusinessError: true
  });
  setChannelTestResult("dc_test_result", result.message || "-", result.ok);
  setMessage(`Discord 测试：${result.message}`, result.ok ? "ok" : "error");
}

async function testSlack() {
  const mode = String(getInputValue("sl_mode") || "socket");
  const payload = {
    mode,
    botToken: String(getInputValue("sl_bot_token") || ""),
    appToken: String(getInputValue("sl_app_token") || ""),
    signingSecret: String(getInputValue("sl_signing_secret") || "")
  };
  if (!payload.botToken) {
    setChannelTestResult("sl_test_result", "失败：请先填写 Slack Bot Token", false);
    throw new Error("Slack 测试失败：Bot Token 不能为空");
  }
  if (mode === "socket" && !payload.appToken) {
    setChannelTestResult("sl_test_result", "失败：socket 模式需要 App Token", false);
    throw new Error("Slack 测试失败：socket 模式需要 App Token");
  }
  if (mode === "http" && !payload.signingSecret) {
    setChannelTestResult("sl_test_result", "失败：http 模式需要 Signing Secret", false);
    throw new Error("Slack 测试失败：http 模式需要 Signing Secret");
  }
  const result = await api("/api/test/slack", {
    method: "POST",
    body: JSON.stringify(payload),
    allowBusinessError: true
  });
  setChannelTestResult("sl_test_result", result.message || "-", result.ok);
  setMessage(`Slack 测试：${result.message}`, result.ok ? "ok" : "error");
}

export {
  approveTelegramPairingFlow,
  checkAllUpdates,
  checkUpdate,
  fillPanelMeta,
  fillSettings,
  loadErrorSummary,
  loadInitialData,
  loadTail,
  mutateVersion,
  resetTelegramAdvancedSettings,
  renderChannelAccessOverview,
  runService,
  saveAndTestFeishu,
  saveAndTestTelegram,
  saveModelSettings,
  saveSettings,
  setChannelActionResult,
  setChannelTestResult,
  setUpdateState,
  setupTelegramBasicFlow,
  startStream,
  stopStream,
  testDiscord,
  testFeishu,
  testSlack,
  testTelegram
};
</file>

<file path="public/pages/channels-telegram.html">
<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>OpenClaw 龙虾控制台</title>
    <script>
      (function initThemeEarly() {
        var theme = "light";
        try {
          var saved = window.localStorage.getItem("openclaw-panel-theme");
          theme = saved === "dark" ? "dark" : "light";
        } catch (_error) {
          theme = "light";
        }
        var root = document.documentElement;
        root.dataset.theme = theme;
        root.classList.toggle("sl-theme-dark", theme === "dark");
        root.classList.toggle("sl-theme-light", theme !== "dark");
      })();
    </script>
    <link rel="stylesheet" href="/shoelace/themes/light.css" />
    <link rel="stylesheet" href="/shoelace/themes/dark.css" />
    <link rel="stylesheet" href="/styles.css" />
    <script type="module" src="/shoelace/shoelace-autoloader.js"></script>
    <style>
      .channel-page-status {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin: 10px 0 4px;
      }

      .channel-page-summary {
        margin: 0;
        color: var(--muted);
        font-size: 12px;
      }

      .channel-page-header-left {
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .channel-back-link {
        width: 34px;
        height: 34px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        border: 1px solid var(--border);
        border-radius: 9px;
        background: var(--soft-button);
        color: var(--text);
        text-decoration: none;
        font-size: 18px;
        line-height: 1;
      }

      .channel-back-link:hover {
        background: var(--soft-button-hover);
      }

      .tg-intro-list {
        margin: 8px 0 0;
        padding-left: 18px;
        color: var(--muted);
        display: grid;
        gap: 5px;
        font-size: 13px;
      }

      .tg-flow {
        display: grid;
        gap: 10px;
      }

      .tg-flow-step {
        border: 1px solid var(--border-strong);
        border-radius: 10px;
        padding: 12px;
        background: var(--inner-card-bg);
        display: grid;
        gap: 10px;
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.6);
      }

      .tg-flow-step h3 {
        margin: 0;
        font-size: 16px;
      }

      .tg-flow-step p {
        margin: 0;
        color: var(--muted);
        font-size: 13px;
      }

      .tg-flow-step input,
      .tg-flow-step select,
      .tg-flow-step textarea {
        background: #ffffff;
        border-color: #c6d2e4;
      }

      .tg-flow-step input:focus,
      .tg-flow-step select:focus,
      .tg-flow-step textarea:focus {
        border-color: var(--primary);
        box-shadow: 0 0 0 2px rgba(36, 87, 214, 0.18);
      }

      :root[data-theme="light"] .tg-flow-step {
        background: #e8eef8;
      }

      :root[data-theme="dark"] .tg-flow-step {
        box-shadow: none;
      }

      :root[data-theme="dark"] .tg-flow-step input,
      :root[data-theme="dark"] .tg-flow-step select,
      :root[data-theme="dark"] .tg-flow-step textarea {
        background: #141922;
        border-color: #384558;
      }

      .tg-flow-arrow {
        justify-self: center;
        color: var(--primary);
        font-size: 40px;
        font-weight: 900;
        line-height: 1;
        letter-spacing: 0;
        text-shadow: 0 1px 0 rgba(36, 87, 214, 0.55);
        text-shadow: 0 1px 0 color-mix(in srgb, var(--primary) 55%, transparent);
      }

      .tg-step-result {
        margin-top: 8px;
        padding: 10px;
        border: 1px dashed var(--border);
        border-radius: 8px;
        background: var(--code-bg);
        font-family: "JetBrains Mono", "Cascadia Mono", ui-monospace, SFMono-Regular, Menlo, monospace;
        font-size: 12px;
        white-space: pre-wrap;
        word-break: break-word;
      }

      .tg-advanced-grid {
        display: grid;
        gap: 12px;
        margin-top: 12px;
      }

      .tg-advanced-section {
        border: 1px solid var(--border);
        border-radius: 10px;
        padding: 12px;
        background: var(--surface-muted);
        display: grid;
        gap: 10px;
      }

      .tg-advanced-section h3 {
        margin: 0;
        font-size: 15px;
      }

      .tg-advanced-section > p {
        margin: 0;
        color: var(--muted);
        font-size: 12px;
      }

      .tg-help {
        display: block;
        color: var(--muted);
        font-size: 12px;
        line-height: 1.4;
        margin-top: 2px;
      }

      .tg-check-field {
        display: grid;
        gap: 6px;
      }

      .tg-check-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 8px;
        color: var(--muted);
        font-size: 13px;
      }
    </style>
  </head>
  <body data-theme="light">
    <div class="layout">
      <aside class="sidebar">
        <div class="brand">
          <p class="eyebrow">OpenClaw</p>
          <h1>龙虾控制台</h1>
          <p class="sub">管理你的 AI 助手：模型、渠道、技能，一站搞定。</p>
        </div>

        <nav class="tabs sidebar-tabs">
          <a class="tab" data-tab-target="panel-dashboard" href="/dashboard">仪表盘</a>
          <a class="tab" data-tab-target="panel-model" href="/model">模型配置</a>
          <a class="tab" data-tab-target="panel-chat-console" href="/chat-console">智能对话</a>
          <a class="tab" data-tab-target="panel-skills" href="/skills">技能管理</a>
          <a class="tab" data-tab-target="panel-config-generator" href="/config-generator">配置生成器</a>
          <a class="tab is-active" data-tab-target="panel-channel" href="/channels">平台接入</a>
          <a class="tab" data-tab-target="panel-update" href="/update">版本更新</a>
          <a class="tab" data-tab-target="panel-service" href="/service">服务控制</a>
          <a class="tab" data-tab-target="panel-logs" href="/logs">运行日志</a>
        </nav>
      </aside>

      <main class="content">
        <header class="page-header">
          <div class="channel-page-header-left">
            <a class="channel-back-link" href="/channels" aria-label="返回平台列表" title="返回平台列表">←</a>
            <div>
              <h2 class="page-title">龙虾控制台</h2>
              <p class="page-subtitle">你的 AI 助手管理中心</p>
            </div>
          </div>
          <button id="theme_toggle" class="btn-soft" type="button">切换到深夜模式</button>
        </header>

        <section class="panel is-visible" data-panel="panel-channel">
          <article class="card">
            <h2>Telegram（纸飞机）接入配置</h2>
            <p class="muted-line">Telegram 页面简单、机器人体验好、斜杠命令灵活。这里按 1 → 2 → 3 → 4 引导你完成最小可用接入。</p>
            <ul class="tg-intro-list">
              <li>完成基础配置后，你可以直接在 Telegram 给 Bot 发消息。</li>
              <li>系统会自动在后台执行 `openclaw plugins enable telegram` 等命令。</li>
              <li>如果命令执行失败，操作记录会告诉你具体卡在哪一步。</li>
            </ul>
            <div class="channel-page-status">
              <sl-tag id="channel_status_telegram_enabled" size="small" pill>未启用</sl-tag>
              <sl-tag id="channel_status_telegram_configured" size="small" pill variant="warning">未配置</sl-tag>
            </div>
            <p class="channel-page-summary" id="channel_status_telegram_summary">完成基础配置后会自动刷新状态。</p>
          </article>

          <article class="card">
            <h2>基础配置（按顺序完成）</h2>
            <div class="tg-flow">
              <section class="tg-flow-step">
                <h3>第 1 步：获取 Bot Token</h3>
                <p>在 Telegram 搜索 <b>@BotFather</b>，发送 <b>/newbot</b>，按提示创建机器人并拿到 Token。</p>
                <label>
                  Bot Token（示例：123456789:ABCdefGHIjklMNOpqrsTUVwxyz）
                  <input id="tg_bot_token" type="text" autocomplete="off" />
                </label>
              </section>

              <div class="tg-flow-arrow" aria-hidden="true">⬇</div>

              <section class="tg-flow-step">
                <h3>第 2 步：保存并启用</h3>
                <p>点击后会自动执行启用 Telegram 插件、开启频道并写入 Bot Token。</p>
                <div class="actions">
                  <button id="tg_setup_basic" type="button">保存并启用</button>
                </div>
                <p id="tg_setup_result" class="muted-line">还没执行过</p>
                <pre id="tg_setup_trace" class="tg-step-result">暂无执行记录</pre>
              </section>

              <div class="tg-flow-arrow" aria-hidden="true">⬇</div>

              <section class="tg-flow-step">
                <h3>第 3 步：在 Telegram 里给 Bot 发任意消息</h3>
                <p>Bot 会返回验证码，把验证码填在下一步。</p>
              </section>

              <div class="tg-flow-arrow" aria-hidden="true">⬇</div>

              <section class="tg-flow-step">
                <h3>第 4 步：输入验证码并验证</h3>
                <p>系统会执行 `openclaw pairing approve telegram 你的验证码` 完成配对。</p>
                <div class="grid">
                  <label>
                    验证码
                    <input id="tg_pairing_code" type="text" placeholder="请输入 Telegram 给你的验证码" />
                  </label>
                </div>
                <div class="actions">
                  <button id="tg_pairing_approve" type="button">验证并完成配对</button>
                </div>
                <p id="tg_pairing_result" class="muted-line">还没验证过</p>
                <pre id="tg_pairing_trace" class="tg-step-result">暂无执行记录</pre>
              </section>
            </div>
          </article>

          <article class="card">
            <h2>高级设置（可选）</h2>
            <p class="muted-line">
              这里覆盖
              <a href="https://docs.openclaw.ai/zh-CN/channels/telegram" target="_blank" rel="noreferrer">OpenClaw 官方 Telegram 文档</a>
              的高级配置项。每个功能下面都有一句作用说明，不懂就先保持默认值。
            </p>
            <sl-details summary="展开高级设置（按需）">
              <div class="tg-advanced-grid">
                <section class="tg-advanced-section">
                  <h3>访问控制与会话</h3>
                  <p>控制谁能用、在哪些群里可用、历史保留多少轮。</p>
                  <div class="grid">
                    <label class="tg-check-field">
                      <span class="tg-check-row">
                        启用 Telegram 渠道
                        <input id="tg_enabled" type="checkbox" />
                      </span>
                      <small class="tg-help">关闭后 Telegram 渠道不会启动。</small>
                    </label>
                    <label>
                      私聊权限（dmPolicy）
                      <select id="tg_dm_policy">
                        <option value="pairing">pairing：配对后可用（推荐）</option>
                        <option value="allowlist">allowlist：仅白名单</option>
                        <option value="open">open：所有私聊用户</option>
                        <option value="disabled">disabled：禁用私聊</option>
                      </select>
                      <small class="tg-help">决定私聊消息是否被接受。</small>
                    </label>
                    <label>
                      群组权限（groupPolicy）
                      <select id="tg_group_policy">
                        <option value="allowlist">allowlist：仅白名单用户</option>
                        <option value="open">open：群内任何人都可用</option>
                        <option value="disabled">disabled：禁用群组消息</option>
                      </select>
                      <small class="tg-help">决定群组里哪些发送者能触发机器人。</small>
                    </label>
                    <label class="tg-check-field">
                      <span class="tg-check-row">
                        群里必须 @ 机器人才回复
                        <input id="tg_require_mention" type="checkbox" />
                      </span>
                      <small class="tg-help">适合活跃群，避免机器人抢答。</small>
                    </label>
                    <label>
                      私聊允许列表（allowFrom，每行一个）
                      <textarea id="tg_allow_from" rows="4"></textarea>
                      <small class="tg-help">支持用户 ID 或 @username。用于 allowlist/open 策略。</small>
                    </label>
                    <label>
                      群组发送者允许列表（groupAllowFrom，每行一个）
                      <textarea id="tg_group_allow_from" rows="4"></textarea>
                      <small class="tg-help">配合 groupPolicy=allowlist 使用。</small>
                    </label>
                    <label>
                      私聊历史上限（dmHistoryLimit）
                      <input id="tg_dm_history_limit" type="number" min="0" step="1" placeholder="留空使用默认" />
                      <small class="tg-help">按用户轮次限制历史；0 表示禁用历史。</small>
                    </label>
                    <label>
                      群组历史上限（historyLimit）
                      <input id="tg_history_limit" type="number" min="0" step="1" placeholder="留空使用默认" />
                      <small class="tg-help">群组上下文轮次；0 表示禁用。</small>
                    </label>
                  </div>
                </section>

                <section class="tg-advanced-section">
                  <h3>消息与回复行为</h3>
                  <p>控制流式回复、分块、链接预览、回复关联等体验项。</p>
                  <div class="grid">
                    <label>
                      流式回复模式（streamMode）
                      <select id="tg_stream_mode">
                        <option value="partial">partial：边生成边更新草稿</option>
                        <option value="block">block：分块草稿更新</option>
                        <option value="off">off：关闭流式草稿</option>
                      </select>
                      <small class="tg-help">适合想“更实时”还是“更稳定”的场景。</small>
                    </label>
                    <label class="tg-check-field">
                      <span class="tg-check-row">
                        启用分块流式消息（blockStreaming）
                        <input id="tg_block_streaming" type="checkbox" />
                      </span>
                      <small class="tg-help">开启后会更早发出消息块，而不是只更新草稿。</small>
                    </label>
                    <label>
                      文本分块模式（chunkMode）
                      <select id="tg_chunk_mode">
                        <option value="length">length：按长度切分</option>
                        <option value="newline">newline：优先按段落切分</option>
                      </select>
                      <small class="tg-help">newline 更自然，length 更稳定。</small>
                    </label>
                    <label>
                      文本分块长度（textChunkLimit）
                      <input id="tg_text_chunk_limit" type="number" min="1" step="1" placeholder="留空使用默认 4000" />
                      <small class="tg-help">过小会碎片化，过大可能触发 Telegram 长度限制。</small>
                    </label>
                    <label>
                      回复关联模式（replyToMode）
                      <select id="tg_reply_to_mode">
                        <option value="off">off：不引用</option>
                        <option value="first">first：首条回复引用</option>
                        <option value="all">all：每条都引用</option>
                      </select>
                      <small class="tg-help">帮助用户知道机器人在回复哪条消息。</small>
                    </label>
                    <label class="tg-check-field">
                      <span class="tg-check-row">
                        开启链接预览（linkPreview）
                        <input id="tg_link_preview" type="checkbox" />
                      </span>
                      <small class="tg-help">关闭后消息更紧凑，适合命令型对话。</small>
                    </label>
                    <label>
                      媒体大小上限 MB（mediaMaxMb）
                      <input id="tg_media_max_mb" type="number" min="1" step="1" placeholder="留空使用默认 5" />
                      <small class="tg-help">限制上传/下载媒体大小，防止资源占用过高。</small>
                    </label>
                    <label>
                      API 超时秒数（timeoutSeconds）
                      <input id="tg_timeout_seconds" type="number" min="1" step="1" placeholder="留空使用默认 500" />
                      <small class="tg-help">网络差时可适当调大，卡顿时可调小。</small>
                    </label>
                  </div>
                </section>

                <section class="tg-advanced-section">
                  <h3>Webhook 与网络</h3>
                  <p>默认长轮询即可用；只有你明确需要公网回调时才配 Webhook。</p>
                  <div class="grid">
                    <label>
                      Token 文件路径（tokenFile）
                      <input id="tg_token_file" type="text" placeholder="例如 /run/secrets/tg_token" />
                      <small class="tg-help">你用文件挂载密钥时填写；否则留空即可。</small>
                    </label>
                    <label>
                      代理地址（proxy）
                      <input id="tg_proxy" type="text" placeholder="例如 socks5://127.0.0.1:1080" />
                      <small class="tg-help">网络受限时可用代理访问 Telegram API。</small>
                    </label>
                    <label>
                      Webhook URL（webhookUrl）
                      <input id="tg_webhook_url" type="text" placeholder="例如 https://公网IP:端口/telegram-webhook" />
                      <small class="tg-help">填写后切到 Webhook 模式。</small>
                    </label>
                    <label>
                      Webhook Secret（webhookSecret）
                      <input id="tg_webhook_secret" type="password" autocomplete="off" />
                      <small class="tg-help">Webhook 模式建议必须设置，用于校验来源。</small>
                    </label>
                    <label>
                      Webhook Path（webhookPath）
                      <input id="tg_webhook_path" type="text" placeholder="/telegram-webhook" />
                      <small class="tg-help">本地监听路径，默认 `/telegram-webhook`。</small>
                    </label>
                    <label>
                      网络家族自动选择（network.autoSelectFamily）
                      <select id="tg_network_auto_select_family">
                        <option value="default">default：使用系统默认</option>
                        <option value="true">true：启用自动选择</option>
                        <option value="false">false：禁用自动选择</option>
                      </select>
                      <small class="tg-help">主要用于 Node 22+ 的 IPv4/IPv6 网络兼容调优。</small>
                    </label>
                    <label class="tg-check-field">
                      <span class="tg-check-row">
                        允许渠道写回配置（configWrites）
                        <input id="tg_config_writes" type="checkbox" />
                      </span>
                      <small class="tg-help">关闭后，/config 与群组迁移不会自动写配置文件。</small>
                    </label>
                  </div>
                </section>

                <section class="tg-advanced-section">
                  <h3>按钮、反应与动作权限</h3>
                  <p>控制智能体能不能发按钮、加反应、发消息、删消息、发贴纸。</p>
                  <div class="grid">
                    <label>
                      内联按钮范围（capabilities.inlineButtons）
                      <select id="tg_inline_buttons">
                        <option value="allowlist">allowlist：仅白名单可用</option>
                        <option value="all">all：私聊+群组都可用</option>
                        <option value="group">group：仅群组</option>
                        <option value="dm">dm：仅私聊</option>
                        <option value="off">off：禁用</option>
                      </select>
                      <small class="tg-help">决定按钮功能可在哪些场景使用。</small>
                    </label>
                    <label>
                      反应强度（reactionLevel）
                      <select id="tg_reaction_level">
                        <option value="off">off：不允许反应</option>
                        <option value="ack">ack：仅确认反应</option>
                        <option value="minimal">minimal：少量反应</option>
                        <option value="extensive">extensive：自由反应</option>
                      </select>
                      <small class="tg-help">越高越“活泼”，也越可能打扰用户。</small>
                    </label>
                    <label>
                      反应通知范围（reactionNotifications）
                      <select id="tg_reaction_notifications">
                        <option value="own">own：只通知机器人相关反应</option>
                        <option value="all">all：通知所有反应</option>
                        <option value="off">off：关闭反应通知</option>
                      </select>
                      <small class="tg-help">决定反应事件是否进入智能体上下文。</small>
                    </label>
                    <label>
                      命令菜单注册策略（commands.native）
                      <select id="tg_commands_native">
                        <option value="default">default：跟随全局配置</option>
                        <option value="auto">auto：按渠道自动决定</option>
                        <option value="true">true：强制启用原生命令</option>
                        <option value="false">false：禁用原生命令</option>
                      </select>
                      <small class="tg-help">控制 Telegram 机器人菜单是否注册原生命令（/status 等）。</small>
                    </label>
                    <label class="tg-check-field">
                      <span class="tg-check-row">
                        允许 sendMessage 动作
                        <input id="tg_action_send_message" type="checkbox" />
                      </span>
                      <small class="tg-help">关掉后智能体工具不能主动发 Telegram 消息。</small>
                    </label>
                    <label class="tg-check-field">
                      <span class="tg-check-row">
                        允许 reactions 动作
                        <input id="tg_action_reactions" type="checkbox" />
                      </span>
                      <small class="tg-help">关掉后智能体不能主动给消息加 emoji 反应。</small>
                    </label>
                    <label class="tg-check-field">
                      <span class="tg-check-row">
                        允许 deleteMessage 动作
                        <input id="tg_action_delete_message" type="checkbox" />
                      </span>
                      <small class="tg-help">关掉后智能体不能删除 Telegram 消息。</small>
                    </label>
                    <label class="tg-check-field">
                      <span class="tg-check-row">
                        允许 sticker / sticker-search 动作
                        <input id="tg_action_sticker" type="checkbox" />
                      </span>
                      <small class="tg-help">开启后可发贴纸和检索贴纸缓存。</small>
                    </label>
                  </div>
                </section>

                <section class="tg-advanced-section">
                  <h3>扩展 JSON（覆盖官方高级结构）</h3>
                  <p>这些字段用于承载文档里更复杂的结构（群组/话题、多账号、自定义命令、草稿分块策略）。</p>
                  <div class="grid">
                    <label>
                      groups JSON（groups + topics）
                      <textarea id="tg_groups_json" rows="8" placeholder='例如 { "*": { "requireMention": true } }'></textarea>
                      <small class="tg-help">可配置每群组/每话题覆盖，如 requireMention、skills、systemPrompt 等。</small>
                    </label>
                    <label>
                      accounts JSON（多账号）
                      <textarea id="tg_accounts_json" rows="8" placeholder='例如 { "main": { "botToken": "..." } }'></textarea>
                      <small class="tg-help">多 Bot 账号场景使用；留空表示不覆盖。</small>
                    </label>
                    <label>
                      customCommands JSON（自定义命令）
                      <textarea
                        id="tg_custom_commands_json"
                        rows="8"
                        placeholder='例如 [{ "command": "backup", "description": "Git 备份" }]'
                      ></textarea>
                      <small class="tg-help">配置 Telegram 菜单中的自定义命令条目。</small>
                    </label>
                    <label>
                      draftChunk JSON（草稿分块策略）
                      <textarea
                        id="tg_draft_chunk_json"
                        rows="8"
                        placeholder='例如 { "minChars": 200, "maxChars": 800, "breakPreference": "paragraph" }'
                      ></textarea>
                      <small class="tg-help">细调草稿流式更新的分块行为。</small>
                    </label>
                  </div>
                </section>

                <section class="tg-advanced-section">
                  <h3>重试策略（retry）</h3>
                  <p>网络不稳定时建议保留重试，避免偶发失败直接掉消息。</p>
                  <div class="grid">
                    <label>
                      重试次数（attempts）
                      <input id="tg_retry_attempts" type="number" min="1" step="1" placeholder="留空使用默认" />
                      <small class="tg-help">越大越稳，但失败恢复会更慢。</small>
                    </label>
                    <label>
                      最小重试间隔 ms（minDelayMs）
                      <input id="tg_retry_min_delay_ms" type="number" min="1" step="1" placeholder="留空使用默认" />
                      <small class="tg-help">建议 200~1000 区间。</small>
                    </label>
                    <label>
                      最大重试间隔 ms（maxDelayMs）
                      <input id="tg_retry_max_delay_ms" type="number" min="1" step="1" placeholder="留空使用默认" />
                      <small class="tg-help">建议大于最小间隔。</small>
                    </label>
                    <label>
                      抖动系数（jitter，0~1）
                      <input id="tg_retry_jitter" type="number" min="0" max="1" step="0.01" placeholder="留空使用默认" />
                      <small class="tg-help">分散重试峰值，建议 0.1~0.3。</small>
                    </label>
                  </div>
                </section>
              </div>
              <div class="actions" style="margin-top: 14px">
                <button id="tg_save_advanced" class="btn-soft" type="button">保存高级设置</button>
                <button id="tg_reset_advanced" class="btn-soft" type="button">重置高级配置</button>
              </div>
            </sl-details>
          </article>
        </section>

        <section class="card">
          <h2>操作记录</h2>
          <p class="muted-line">每次点击后的结果都会记录在这里，方便你定位问题。</p>
          <pre id="messages" class="output"></pre>
        </section>
      </main>
    </div>

    <script type="module" src="/app.js"></script>
  </body>
</html>
</file>

<file path="src/server.js">
import path from "node:path";
import fs from "node:fs/promises";
import { execFile } from "node:child_process";
import { randomBytes } from "node:crypto";
import { fileURLToPath } from "node:url";
import Fastify from "fastify";
import fastifyStatic from "@fastify/static";
import { z } from "zod";
import { loadPanelConfig, savePanelConfig, defaults } from "./panel-config.js";
import {
  applySettings,
  ensureOpenClawConfigPermissions,
  extractSettings,
  loadOpenClawConfig,
  openClawSettingsSchema,
  removeModelFromCatalog,
  removeProviderFromCatalog,
  saveOpenClawConfig,
  updateModelInCatalog,
  updateProviderInCatalog
} from "./openclaw-config.js";
import { runServiceAction } from "./systemd.js";
import { createLogStream, getErrorSummary, getTailLogs } from "./logs.js";
import { testDiscordBot, testFeishuBot, testSlackBot, testTelegramBot } from "./channel-tests.js";
import { expandHome, toPositiveInt } from "./utils.js";
import {
  applyPanelDirectUpdate,
  checkBotDirectUpdate,
  checkPanelDirectUpdate,
  mutateBotDirectUpdate,
  stagePanelDirectUpdate
} from "./direct-update.js";
import { buildDashboardSummary } from "./dashboard-service.js";
import { getSkillConfig, listSkillsStatus, prepareSkillConfigUpdate, setSkillEnabled } from "./skills-service.js";
import { approvePendingGatewayPairings, approveTelegramPairing, setupTelegramBasic } from "./channel-onboarding.js";
import {
  abortChatRun,
  createChatSession,
  createChatEventSubscription,
  getChatHistory,
  listChatSessions,
  resetChatSession,
  sendChatMessage,
  stageChatAttachment
} from "./chat-service.js";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const app = Fastify({
  logger: false
});

await app.register(fastifyStatic, {
  root: path.join(__dirname, "..", "public"),
  prefix: "/"
});

await app.register(fastifyStatic, {
  root: path.join(__dirname, "..", "node_modules", "@shoelace-style", "shoelace", "cdn"),
  prefix: "/shoelace/",
  decorateReply: false
});

const actionSchema = z.enum(["start", "stop", "restart", "status"]);
const updateTargetSchema = z.enum(["bot", "panel"]);
const updateCheckQuerySchema = z.object({
  target: updateTargetSchema.optional().default("bot")
});
const tagPayloadSchema = z.object({
  tag: z.string().optional().default(""),
  target: updateTargetSchema.optional().default("bot")
});
const skillEnabledPayloadSchema = z.object({
  enabled: z.boolean()
});
const skillConfigPatchPayloadSchema = z
  .object({
    enabled: z.boolean().optional(),
    apiKey: z.string().optional(),
    clearApiKey: z.boolean().optional().default(false),
    env: z.record(z.string()).optional()
  })
  .superRefine((payload, ctx) => {
    const hasEnabled = typeof payload.enabled === "boolean";
    const apiKey = String(payload.apiKey || "").trim();
    const clearApiKey = payload.clearApiKey === true;
    const envPatch = payload.env && typeof payload.env === "object" ? payload.env : {};
    const hasEnv = Object.keys(envPatch).some((key) => String(key || "").trim());
    if (!hasEnabled && !apiKey && !clearApiKey && !hasEnv) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: "至少提供一个可写入字段（enabled/apiKey/clearApiKey/env）"
      });
    }
    if (clearApiKey && apiKey) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: "clearApiKey=true 时不能同时提供 apiKey"
      });
    }
  });
const chatHistoryQuerySchema = z.object({
  sessionKey: z.string().min(1, "sessionKey 不能为空"),
  limit: z.coerce.number().int().positive().max(1000).optional()
});
const chatStreamQuerySchema = z.object({
  sessionKey: z.string().min(1, "sessionKey 不能为空"),
  includeAgent: z.coerce.boolean().optional().default(true)
});
const chatSendPayloadSchema = z.object({
  sessionKey: z.string().min(1, "sessionKey 不能为空"),
  message: z.string().optional().default(""),
  thinking: z.string().optional().default(""),
  attachments: z.array(z.any()).optional().default([]),
  idempotencyKey: z.string().optional().default(""),
  timeoutMs: z.number().int().positive().max(120000).optional()
});
const chatAbortPayloadSchema = z.object({
  sessionKey: z.string().min(1, "sessionKey 不能为空"),
  runId: z.string().optional().default("")
});
const chatSessionResetPayloadSchema = z.object({
  sessionKey: z.string().min(1, "sessionKey 不能为空"),
  reason: z.enum(["new", "reset"]).optional().default("new")
});
const chatSessionNewPayloadSchema = z.object({
  keyPrefix: z.string().optional().default("")
});
const chatAttachmentStagePayloadSchema = z.object({
  fileName: z.string().min(1, "fileName 不能为空"),
  mimeType: z.string().optional().default("application/octet-stream"),
  base64: z.string().min(1, "base64 不能为空")
});
const telegramSetupPayloadSchema = z.object({
  botToken: z.string().min(1, "Bot Token 不能为空")
});
const telegramPairingPayloadSchema = z.object({
  code: z.string().min(1, "验证码不能为空")
});
const providerPathParamSchema = z.object({
  providerId: z.string().min(1, "providerId 不能为空")
});
const modelPathParamSchema = z.object({
  providerId: z.string().min(1, "providerId 不能为空"),
  modelId: z.string().min(1, "modelId 不能为空")
});
const updateProviderPayloadSchema = z.object({
  nextProviderId: z.string().min(1, "供应商名称不能为空"),
  api: z.string().min(1, "API 模式不能为空"),
  baseUrl: z.string().min(1, "API 地址不能为空"),
  apiKey: z.string().optional()
});
const updateModelPayloadSchema = z.object({
  nextModelId: z.string().min(1, "模型 ID 不能为空"),
  name: z.string().optional(),
  contextWindow: z.number().int().positive().optional(),
  maxTokens: z.number().int().positive().optional()
});
const rawOpenClawConfigPayloadSchema = z.object({
  rawText: z.string().min(1, "配置 JSON 不能为空"),
  expectedMtimeMs: z.number().nonnegative().optional()
});

function normalizeBaseUrl(value) {
  const text = String(value || "").trim();
  if (!text) {
    return "";
  }
  return text.replace(/\/+$/, "");
}

function buildPublicUrl({ scheme, host, port }) {
  const finalHost = String(host || "").trim();
  const parsedPort = Number(port);
  if (!finalHost || !Number.isFinite(parsedPort) || parsedPort <= 0) {
    return "";
  }
  const finalScheme = String(scheme || "http").trim().toLowerCase() === "https" ? "https" : "http";
  return `${finalScheme}://${finalHost}:${Math.floor(parsedPort)}`;
}

function buildDeploymentMeta(panelConfig) {
  const reverseProxy = panelConfig?.reverse_proxy || {};
  const panelListenHost = String(panelConfig?.panel?.listen_host || "127.0.0.1").trim();
  const panelLocalHost = panelListenHost === "0.0.0.0" ? "127.0.0.1" : panelListenHost;
  const panelListenPort = Number(panelConfig?.panel?.listen_port || 0);
  const panelLocalUrl =
    Number.isFinite(panelListenPort) && panelListenPort > 0 ? `http://${panelLocalHost}:${Math.floor(panelListenPort)}` : "";
  const panelPublicUrl =
    normalizeBaseUrl(reverseProxy.panel_public_base_url) ||
    buildPublicUrl({
      scheme: reverseProxy.public_scheme,
      host: reverseProxy.public_host,
      port: reverseProxy.panel_public_port
    });
  const gatewayPublicUrl = buildPublicUrl({
    scheme: reverseProxy.public_scheme,
    host: reverseProxy.public_host,
    port: reverseProxy.gateway_public_port
  });
  const webhookBaseUrl = normalizeBaseUrl(reverseProxy.webhook_public_base_url) || gatewayPublicUrl;

  return {
    panelLocalUrl,
    panelPublicUrl,
    gatewayPublicUrl,
    webhookBaseUrl,
    hasPublicEndpoint: Boolean(panelPublicUrl),
    hasWebhookEndpoint: Boolean(webhookBaseUrl)
  };
}

function trimText(value) {
  return String(value || "").trim();
}

function runCommand(command, args, timeout = 15000, options = {}) {
  const extraEnv =
    options?.env && typeof options.env === "object" && !Array.isArray(options.env) ? options.env : {};
  const commandEnv = {
    ...process.env,
    ...extraEnv
  };
  return new Promise((resolve) => {
    execFile(command, args, { timeout, maxBuffer: 5 * 1024 * 1024, env: commandEnv }, (error, stdout, stderr) => {
      resolve({
        ok: !error,
        stdout: String(stdout || "").trim(),
        stderr: String(stderr || "").trim(),
        message: error?.message || ""
      });
    });
  });
}

const OPENCLAW_CLI_CANDIDATES = ["/usr/bin/openclaw", "/usr/local/bin/openclaw", "openclaw"];
const OPENCLAW_CMD_NOT_FOUND_PATTERNS = [
  /ENOENT/i,
  /not found/i,
  /executable file not found/i,
  /is not recognized as an internal or external command/i,
  /无法将.*识别为 cmdlet/i
];
const TOKEN_MISSING_ERROR = "openclaw 配置中未发现 gateway.auth.token";

function isCommandMissingError(detail) {
  const text = trimText(detail);
  if (!text) {
    return false;
  }
  return OPENCLAW_CMD_NOT_FOUND_PATTERNS.some((pattern) => pattern.test(text));
}

function buildOpenClawCommandCandidates() {
  const preferred = trimText(process.env.OPENCLAW_BIN);
  const result = [];
  const seen = new Set();
  for (const item of [preferred, ...OPENCLAW_CLI_CANDIDATES]) {
    const command = trimText(item);
    if (!command || seen.has(command)) {
      continue;
    }
    seen.add(command);
    result.push(command);
  }
  return result;
}

async function readGatewayTokenFromOpenClawCli(openclawConfigPath) {
  const cliEnv = openclawConfigPath
    ? {
        OPENCLAW_CONFIG_PATH: expandHome(openclawConfigPath)
      }
    : {};
  const candidates = buildOpenClawCommandCandidates();
  let lastError = "";
  let allMissing = true;
  let tokenMissing = false;

  for (const command of candidates) {
    const cliResult = await runCommand(command, ["config", "get", "gateway.auth.token"], 15000, {
      env: cliEnv
    });

    if (cliResult.ok) {
      const token = trimText(cliResult.stdout);
      if (token) {
        return {
          ok: true,
          token,
          command
        };
      }
      allMissing = false;
      tokenMissing = true;
      lastError = lastError || TOKEN_MISSING_ERROR;
      continue;
    }

    const detail = trimText(cliResult.stderr || cliResult.message);
    if (detail) {
      lastError = detail;
    }
    if (isCommandMissingError(detail)) {
      continue;
    }
    allMissing = false;
    return {
      ok: false,
      allMissing: false,
      error: detail || "openclaw 命令执行失败"
    };
  }

  return {
    ok: false,
    allMissing,
    tokenMissing,
    error: lastError
  };
}

function generateGatewayToken() {
  return randomBytes(32).toString("hex");
}

function maskToken(value) {
  const token = trimText(value);
  if (!token) {
    return "";
  }
  if (token.length <= 8) {
    return "*".repeat(token.length);
  }
  return `${token.slice(0, 4)}***${token.slice(-4)}`;
}

function readGatewayTokenFromConfig(openclawConfig) {
  return trimText(openclawConfig?.gateway?.auth?.token);
}

async function resolveGatewayTokenForSync(panelConfig) {
  const fromPanelEnv = trimText(process.env.OPENCLAW_GATEWAY_TOKEN);
  if (fromPanelEnv) {
    return {
      token: fromPanelEnv,
      source: "panel-env"
    };
  }

  const currentConfig = await loadOpenClawConfig(panelConfig.openclaw.config_path);
  const tokenFromConfig = readGatewayTokenFromConfig(currentConfig);
  if (tokenFromConfig) {
    return {
      token: tokenFromConfig,
      source: "openclaw-config-file"
    };
  }

  const openclawConfigPath = trimText(panelConfig?.openclaw?.config_path);
  const cliResult = await readGatewayTokenFromOpenClawCli(openclawConfigPath);
  if (cliResult.ok) {
    return {
      token: cliResult.token,
      source: "openclaw-cli-config"
    };
  }

  if (cliResult.allMissing || cliResult.tokenMissing) {
    return {
      token: generateGatewayToken(),
      source: "generated-local"
    };
  }

  const cliError = trimText(cliResult.error);
  throw new Error(
    cliError
      ? `未能读取 Gateway Token：${cliError}`
      : `未能读取 Gateway Token：${TOKEN_MISSING_ERROR}`
  );
}

function resolveUpdateTarget(panelConfig, target = "bot") {
  const selectedTarget = updateTargetSchema.parse(target);
  if (selectedTarget === "panel") {
    return {
      target: selectedTarget,
      releaseRepo: trimText(panelConfig?.update?.panel_release_repo),
      panelServiceName: trimText(panelConfig?.update?.panel_service_name) || "openclaw-panel",
      panelAppDir: trimText(panelConfig?.update?.panel_app_dir),
      upgradeMode: "staged-apply"
    };
  }

  return {
    target: selectedTarget,
    releaseRepo: trimText(panelConfig?.update?.bot_release_repo),
    upgradeMode: "direct"
  };
}

function normalizeSkillConfigPatch(payload = {}) {
  const patch = {};
  if (typeof payload.enabled === "boolean") {
    patch.enabled = payload.enabled;
  }

  const apiKey = trimText(payload.apiKey);
  if (apiKey) {
    patch.apiKey = apiKey;
  }
  if (payload.clearApiKey === true) {
    patch.clearApiKey = true;
  }

  if (payload.env && typeof payload.env === "object" && !Array.isArray(payload.env)) {
    const envPatch = {};
    for (const [key, value] of Object.entries(payload.env)) {
      const envKey = trimText(key);
      if (!envKey) {
        continue;
      }
      envPatch[envKey] = trimText(value);
    }
    if (Object.keys(envPatch).length > 0) {
      patch.env = envPatch;
    }
  }

  return patch;
}

function validateSkillConfigWriteback({ patch = {}, config = {} }) {
  if (typeof patch.enabled === "boolean" && config.enabled !== patch.enabled) {
    throw new Error("enabled 写回校验失败");
  }
  if (patch.clearApiKey === true && config.hasApiKey) {
    throw new Error("apiKey 清除校验失败");
  }
  if (patch.apiKey && !config.hasApiKey) {
    throw new Error("apiKey 写回校验失败");
  }

  if (patch.env && typeof patch.env === "object") {
    const currentEnv = config.env && typeof config.env === "object" ? config.env : {};
    for (const [key, value] of Object.entries(patch.env)) {
      const expectedExists = Boolean(trimText(value));
      const actualExists = Object.prototype.hasOwnProperty.call(currentEnv, key);
      if (expectedExists && !actualExists) {
        throw new Error(`环境变量写回校验失败：${key}`);
      }
      if (!expectedExists && actualExists) {
        throw new Error(`环境变量删除校验失败：${key}`);
      }
    }
  }
}

async function rollbackOpenClawConfig(pathname, backupPath) {
  if (!pathname || !backupPath) {
    return {
      ok: false,
      message: "缺少回滚路径"
    };
  }
  try {
    await fs.copyFile(backupPath, pathname);
    return {
      ok: true,
      message: "已自动回滚到备份配置"
    };
  } catch (error) {
    return {
      ok: false,
      message: error.message || String(error)
    };
  }
}

app.get("/api/health", async () => {
  return {
    ok: true,
    service: "openclaw-panel",
    timestamp: new Date().toISOString()
  };
});

app.get("/api/panel-config", async () => {
  const { config, filePath } = await loadPanelConfig();
  return {
    ok: true,
    filePath,
    config,
    deployment: buildDeploymentMeta(config)
  };
});

app.put("/api/panel-config", async (request, reply) => {
  try {
    const payload = request.body || {};
    const merged = {
      ...defaults,
      ...payload,
      panel: { ...defaults.panel, ...(payload.panel || {}) },
      runtime: { ...defaults.runtime, ...(payload.runtime || {}) },
      reverse_proxy: { ...defaults.reverse_proxy, ...(payload.reverse_proxy || {}) },
      openclaw: { ...defaults.openclaw, ...(payload.openclaw || {}) },
      docker: { ...defaults.docker, ...(payload.docker || {}) },
      update: { ...defaults.update, ...(payload.update || {}) },
      log: { ...defaults.log, ...(payload.log || {}) }
    };
    const saved = await savePanelConfig(merged);
    return {
      ok: true,
      filePath: saved.filePath,
      config: saved.config
    };
  } catch (error) {
    reply.code(400);
    return {
      ok: false,
      message: error.message
    };
  }
});

app.get("/api/settings", async () => {
  const { config: panelConfig } = await loadPanelConfig();
  const openclawConfig = await loadOpenClawConfig(panelConfig.openclaw.config_path);
  return {
    ok: true,
    panelConfig,
    settings: extractSettings(openclawConfig)
  };
});

app.get("/api/dashboard/summary", async (request, reply) => {
  try {
    const { config: panelConfig } = await loadPanelConfig();
    const openclawConfig = await loadOpenClawConfig(panelConfig.openclaw.config_path);
    const summary = await buildDashboardSummary({
      panelConfig,
      openclawConfig
    });
    return {
      ok: true,
      summary
    };
  } catch (error) {
    reply.code(400);
    return {
      ok: false,
      message: error.message
    };
  }
});

app.put("/api/settings", async (request, reply) => {
  try {
    const { config: panelConfig } = await loadPanelConfig();
    const payload = openClawSettingsSchema.parse(request.body || {});
    const current = await loadOpenClawConfig(panelConfig.openclaw.config_path);
    const next = applySettings(current, payload);
    const saved = await saveOpenClawConfig(panelConfig.openclaw.config_path, next);
    return {
      ok: true,
      message: "配置写入成功",
      path: saved.path,
      backupPath: saved.backupPath
    };
  } catch (error) {
    reply.code(400);
    return {
      ok: false,
      message: error.message
    };
  }
});

app.post("/api/gateway/token/sync", async (request, reply) => {
  try {
    const { config: panelConfig } = await loadPanelConfig();
    const currentConfig = await loadOpenClawConfig(panelConfig.openclaw.config_path);
    const tokenResult = await resolveGatewayTokenForSync(panelConfig);

    const prevMode = trimText(currentConfig?.gateway?.auth?.mode);
    const prevToken = trimText(currentConfig?.gateway?.auth?.token);

    const nextGateway =
      currentConfig?.gateway && typeof currentConfig.gateway === "object" && !Array.isArray(currentConfig.gateway)
        ? { ...currentConfig.gateway }
        : {};
    const nextAuth =
      nextGateway?.auth && typeof nextGateway.auth === "object" && !Array.isArray(nextGateway.auth)
        ? { ...nextGateway.auth }
        : {};
    nextAuth.mode = "token";
    nextAuth.token = tokenResult.token;
    nextGateway.auth = nextAuth;

    const nextConfig = {
      ...currentConfig,
      gateway: nextGateway
    };
    const saved = await saveOpenClawConfig(panelConfig.openclaw.config_path, nextConfig);
    const changed = prevMode !== "token" || prevToken !== tokenResult.token;

    return {
      ok: true,
      result: {
        changed,
        source: tokenResult.source,
        token: tokenResult.token,
        tokenMasked: maskToken(tokenResult.token),
        message: changed ? "Gateway Token 已自动同步到真实配置文件" : "Gateway Token 已是最新，无需改动",
        path: saved.path,
        backupPath: saved.backupPath
      }
    };
  } catch (error) {
    reply.code(400);
    return {
      ok: false,
      message: error.message
    };
  }
});

app.get("/api/gateway/token/current", async (request, reply) => {
  try {
    const { config: panelConfig } = await loadPanelConfig();
    const currentConfig = await loadOpenClawConfig(panelConfig.openclaw.config_path);
    const token = readGatewayTokenFromConfig(currentConfig);
    const exists = Boolean(token);

    return {
      ok: true,
      result: {
        exists,
        source: "openclaw-config",
        token,
        tokenMasked: maskToken(token)
      }
    };
  } catch (error) {
    reply.code(400);
    return {
      ok: false,
      message: error.message
    };
  }
});

app.post("/api/gateway/pairing/approve-pending", async (request, reply) => {
  try {
    const { config: panelConfig } = await loadPanelConfig();
    const result = await approvePendingGatewayPairings({
      panelConfig
    });
    return {
      ok: result.ok,
      result
    };
  } catch (error) {
    reply.code(400);
    return {
      ok: false,
      message: error.message
    };
  }
});

app.get("/api/openclaw-config/raw", async (request, reply) => {
  try {
    const { config: panelConfig } = await loadPanelConfig();
    const configuredPath = panelConfig?.openclaw?.config_path;
    const realPath = expandHome(configuredPath);

    let rawText = "";
    let mtimeMs = 0;
    let size = 0;
    let exists = true;
    try {
      rawText = await fs.readFile(realPath, "utf8");
      const stats = await fs.stat(realPath);
      mtimeMs = Number(stats.mtimeMs || 0);
      size = Number(stats.size || Buffer.byteLength(rawText, "utf8"));
    } catch (error) {
      if (error.code === "ENOENT") {
        exists = false;
      } else {
        throw error;
      }
    }

    return {
      ok: true,
      exists,
      path: realPath,
      rawText,
      mtimeMs,
      size
    };
  } catch (error) {
    reply.code(400);
    return {
      ok: false,
      message: error.message
    };
  }
});

app.put("/api/openclaw-config/raw", async (request, reply) => {
  try {
    const payload = rawOpenClawConfigPayloadSchema.parse(request.body || {});
    const rawText = String(payload.rawText || "");
    const expectedMtimeMs = Number(payload.expectedMtimeMs);
    let parsed;
    try {
      parsed = JSON.parse(rawText);
    } catch (error) {
      throw new Error(`配置 JSON 解析失败：${error.message}`);
    }

    const { config: panelConfig } = await loadPanelConfig();
    if (Number.isFinite(expectedMtimeMs) && expectedMtimeMs > 0) {
      const realPath = expandHome(panelConfig.openclaw.config_path);
      let currentMtimeMs = 0;
      try {
        const stats = await fs.stat(realPath);
        currentMtimeMs = Number(stats.mtimeMs || 0);
      } catch (error) {
        if (error.code !== "ENOENT") {
          throw error;
        }
      }
      if (!Number.isFinite(currentMtimeMs) || Math.abs(currentMtimeMs - expectedMtimeMs) > 1) {
        const conflict = new Error("配置文件已被其他进程更新，请先点“刷新真实配置”再保存。");
        conflict.statusCode = 409;
        throw conflict;
      }
    }

    const saved = await saveOpenClawConfig(panelConfig.openclaw.config_path, parsed);
    const latestRaw = await fs.readFile(saved.path, "utf8");
    const stats = await fs.stat(saved.path);
    const refreshed = await loadOpenClawConfig(panelConfig.openclaw.config_path);

    return {
      ok: true,
      message: "配置文件写入成功",
      path: saved.path,
      backupPath: saved.backupPath,
      rawText: latestRaw,
      mtimeMs: Number(stats.mtimeMs || 0),
      size: Number(stats.size || Buffer.byteLength(latestRaw, "utf8")),
      settings: extractSettings(refreshed)
    };
  } catch (error) {
    reply.code(Number.isInteger(error?.statusCode) ? error.statusCode : 400);
    return {
      ok: false,
      message: error.message
    };
  }
});

app.put("/api/models/providers/:providerId", async (request, reply) => {
  try {
    const params = providerPathParamSchema.parse(request.params || {});
    const payload = updateProviderPayloadSchema.parse(request.body || {});
    const { config: panelConfig } = await loadPanelConfig();
    const current = await loadOpenClawConfig(panelConfig.openclaw.config_path);
    const result = updateProviderInCatalog(current, {
      providerId: params.providerId,
      nextProviderId: payload.nextProviderId,
      api: payload.api,
      baseUrl: payload.baseUrl,
      ...(Object.prototype.hasOwnProperty.call(payload, "apiKey") ? { apiKey: payload.apiKey } : {})
    });
    const saved = await saveOpenClawConfig(panelConfig.openclaw.config_path, result.nextConfig);
    return {
      ok: true,
      message: "供应商更新成功",
      providerId: result.providerId,
      primary: result.primary,
      path: saved.path,
      backupPath: saved.backupPath
    };
  } catch (error) {
    reply.code(400);
    return {
      ok: false,
      message: error.message
    };
  }
});

app.put("/api/models/providers/:providerId/models/:modelId", async (request, reply) => {
  try {
    const params = modelPathParamSchema.parse(request.params || {});
    const payload = updateModelPayloadSchema.parse(request.body || {});
    const { config: panelConfig } = await loadPanelConfig();
    const current = await loadOpenClawConfig(panelConfig.openclaw.config_path);
    const result = updateModelInCatalog(current, {
      providerId: params.providerId,
      modelId: params.modelId,
      nextModelId: payload.nextModelId,
      ...(Object.prototype.hasOwnProperty.call(payload, "name") ? { name: payload.name } : {}),
      ...(Object.prototype.hasOwnProperty.call(payload, "contextWindow")
        ? { contextWindow: payload.contextWindow }
        : {}),
      ...(Object.prototype.hasOwnProperty.call(payload, "maxTokens") ? { maxTokens: payload.maxTokens } : {})
    });
    const saved = await saveOpenClawConfig(panelConfig.openclaw.config_path, result.nextConfig);
    return {
      ok: true,
      message: "模型更新成功",
      providerId: result.providerId,
      modelId: result.modelId,
      modelName: result.modelName,
      primary: result.primary,
      path: saved.path,
      backupPath: saved.backupPath
    };
  } catch (error) {
    reply.code(400);
    return {
      ok: false,
      message: error.message
    };
  }
});

app.delete("/api/models/providers/:providerId/models/:modelId", async (request, reply) => {
  try {
    const params = modelPathParamSchema.parse(request.params || {});
    const { config: panelConfig } = await loadPanelConfig();
    const current = await loadOpenClawConfig(panelConfig.openclaw.config_path);
    const result = removeModelFromCatalog(current, {
      providerId: params.providerId,
      modelId: params.modelId
    });
    const saved = await saveOpenClawConfig(panelConfig.openclaw.config_path, result.nextConfig);
    return {
      ok: true,
      message: "模型删除成功",
      providerId: result.providerId,
      modelId: result.modelId,
      providerRemoved: result.providerRemoved,
      primary: result.primary,
      path: saved.path,
      backupPath: saved.backupPath
    };
  } catch (error) {
    reply.code(400);
    return {
      ok: false,
      message: error.message
    };
  }
});

app.delete("/api/models/providers/:providerId", async (request, reply) => {
  try {
    const params = providerPathParamSchema.parse(request.params || {});
    const { config: panelConfig } = await loadPanelConfig();
    const current = await loadOpenClawConfig(panelConfig.openclaw.config_path);
    const result = removeProviderFromCatalog(current, {
      providerId: params.providerId
    });
    const saved = await saveOpenClawConfig(panelConfig.openclaw.config_path, result.nextConfig);
    return {
      ok: true,
      message: "供应商删除成功",
      providerId: result.providerId,
      primary: result.primary,
      path: saved.path,
      backupPath: saved.backupPath
    };
  } catch (error) {
    reply.code(400);
    return {
      ok: false,
      message: error.message
    };
  }
});

app.get("/api/skills/status", async (request, reply) => {
  try {
    const { config: panelConfig } = await loadPanelConfig();
    const result = await listSkillsStatus({ panelConfig });
    return {
      ok: true,
      result
    };
  } catch (error) {
    reply.code(400);
    return {
      ok: false,
      message: error.message
    };
  }
});

app.get("/api/skills/:skillKey/config", async (request, reply) => {
  try {
    const skillKey = String(request.params?.skillKey || "").trim();
    const { config: panelConfig } = await loadPanelConfig();
    const result = await getSkillConfig({ panelConfig, skillKey });
    return {
      ok: true,
      result
    };
  } catch (error) {
    reply.code(400);
    return {
      ok: false,
      message: error.message
    };
  }
});

app.put("/api/skills/:skillKey/config", async (request, reply) => {
  try {
    const skillKey = String(request.params?.skillKey || "").trim();
    const rawPatch = skillConfigPatchPayloadSchema.parse(request.body || {});
    const patch = normalizeSkillConfigPatch(rawPatch);
    const { config: panelConfig } = await loadPanelConfig();
    const prepared = await prepareSkillConfigUpdate({
      panelConfig,
      skillKey,
      patch
    });
    const saved = await saveOpenClawConfig(panelConfig.openclaw.config_path, prepared.nextConfig);
    try {
      const config = await getSkillConfig({
        panelConfig,
        skillKey: prepared.skillKey
      });
      validateSkillConfigWriteback({
        patch,
        config
      });
      return {
        ok: true,
        result: {
          skillKey: prepared.skillKey,
          config,
          path: saved.path,
          backupPath: saved.backupPath
        }
      };
    } catch (error) {
      const rollback = await rollbackOpenClawConfig(saved.path, saved.backupPath);
      const rollbackMessage = rollback.ok ? "已自动回滚到写入前版本。" : `自动回滚失败：${rollback.message}`;
      throw new Error(`Skill 配置写入后校验失败：${error.message}。${rollbackMessage}`);
    }
  } catch (error) {
    reply.code(400);
    return {
      ok: false,
      message: error.message
    };
  }
});

app.post("/api/skills/:skillKey/enabled", async (request, reply) => {
  try {
    const skillKey = String(request.params?.skillKey || "").trim();
    const payload = skillEnabledPayloadSchema.parse(request.body || {});
    const { config: panelConfig } = await loadPanelConfig();
    const result = await setSkillEnabled({
      panelConfig,
      skillKey,
      enabled: payload.enabled
    });
    return {
      ok: true,
      result
    };
  } catch (error) {
    reply.code(400);
    return {
      ok: false,
      message: error.message
    };
  }
});

app.get("/api/chat/sessions", async (request, reply) => {
  try {
    const { config: panelConfig } = await loadPanelConfig();
    const result = await listChatSessions({ panelConfig });
    return {
      ok: true,
      result
    };
  } catch (error) {
    reply.code(400);
    return {
      ok: false,
      message: error.message
    };
  }
});

app.get("/api/chat/history", async (request, reply) => {
  try {
    const query = chatHistoryQuerySchema.parse(request.query || {});
    const { config: panelConfig } = await loadPanelConfig();
    const result = await getChatHistory({
      panelConfig,
      sessionKey: query.sessionKey,
      limit: query.limit
    });
    return {
      ok: true,
      result
    };
  } catch (error) {
    reply.code(400);
    return {
      ok: false,
      message: error.message
    };
  }
});

app.post("/api/chat/send", async (request, reply) => {
  try {
    const payload = chatSendPayloadSchema.parse(request.body || {});
    const { config: panelConfig } = await loadPanelConfig();
    const result = await sendChatMessage({
      panelConfig,
      sessionKey: payload.sessionKey,
      message: payload.message,
      thinking: payload.thinking,
      attachments: payload.attachments,
      idempotencyKey: payload.idempotencyKey,
      timeoutMs: payload.timeoutMs
    });
    return {
      ok: true,
      result
    };
  } catch (error) {
    reply.code(400);
    return {
      ok: false,
      message: error.message
    };
  }
});

app.post("/api/chat/abort", async (request, reply) => {
  try {
    const payload = chatAbortPayloadSchema.parse(request.body || {});
    const { config: panelConfig } = await loadPanelConfig();
    const result = await abortChatRun({
      panelConfig,
      sessionKey: payload.sessionKey,
      runId: payload.runId
    });
    return {
      ok: true,
      result
    };
  } catch (error) {
    reply.code(400);
    return {
      ok: false,
      message: error.message
    };
  }
});

app.post("/api/chat/session/reset", async (request, reply) => {
  try {
    const payload = chatSessionResetPayloadSchema.parse(request.body || {});
    const { config: panelConfig } = await loadPanelConfig();
    const result = await resetChatSession({
      panelConfig,
      sessionKey: payload.sessionKey,
      reason: payload.reason
    });
    return {
      ok: true,
      result
    };
  } catch (error) {
    reply.code(400);
    return {
      ok: false,
      message: error.message
    };
  }
});

app.post("/api/chat/session/new", async (request, reply) => {
  try {
    const payload = chatSessionNewPayloadSchema.parse(request.body || {});
    const { config: panelConfig } = await loadPanelConfig();
    const result = await createChatSession({
      panelConfig,
      keyPrefix: payload.keyPrefix
    });
    return {
      ok: true,
      result
    };
  } catch (error) {
    reply.code(400);
    return {
      ok: false,
      message: error.message
    };
  }
});

app.post("/api/chat/attachments/stage", async (request, reply) => {
  try {
    const payload = chatAttachmentStagePayloadSchema.parse(request.body || {});
    const { config: panelConfig } = await loadPanelConfig();
    const result = await stageChatAttachment({
      panelConfig,
      fileName: payload.fileName,
      mimeType: payload.mimeType,
      base64: payload.base64
    });
    return {
      ok: true,
      result
    };
  } catch (error) {
    reply.code(400);
    return {
      ok: false,
      message: error.message
    };
  }
});

app.get("/api/chat/stream", async (request, reply) => {
  let query;
  try {
    query = chatStreamQuerySchema.parse(request.query || {});
  } catch (error) {
    reply.code(400);
    return {
      ok: false,
      message: error.message
    };
  }

  const { config: panelConfig } = await loadPanelConfig();
  const sessionKey = String(query.sessionKey || "").trim();
  const includeAgent = query.includeAgent !== false;
  let stopped = false;
  let reconnectTimer = null;
  let heartbeatTimer = null;
  let currentSubscription = null;
  let reconnectAttempt = 0;

  const send = (event, payload) => {
    if (stopped) {
      return;
    }
    reply.raw.write(`event: ${event}\n`);
    reply.raw.write(`data: ${JSON.stringify(payload)}\n\n`);
  };

  const stopCurrentSubscription = () => {
    if (!currentSubscription) {
      return;
    }
    try {
      currentSubscription.close();
    } catch {
      // ignore close failure
    }
    currentSubscription = null;
  };

  const scheduleReconnect = (reason = "") => {
    if (stopped) {
      return;
    }
    reconnectAttempt += 1;
    const delayMs = Math.min(10_000, Math.max(1_000, reconnectAttempt * 1_000));
    send("status", {
      state: "reconnecting",
      sessionKey,
      attempt: reconnectAttempt,
      delayMs,
      reason: String(reason || "").trim() || "gateway disconnected"
    });
    reconnectTimer = setTimeout(() => {
      reconnectTimer = null;
      connectGateway();
    }, delayMs);
  };

  const connectGateway = () => {
    if (stopped) {
      return;
    }
    stopCurrentSubscription();

    currentSubscription = createChatEventSubscription({
      panelConfig,
      sessionKey,
      includeAgent,
      onEvent: (eventPayload) => {
        send(eventPayload.type || "message", eventPayload);
      },
      onError: (error) => {
        send("stream-error", {
          sessionKey,
          message: error?.message || String(error)
        });
      },
      onClose: ({ code, reason }) => {
        if (stopped) {
          return;
        }
        send("status", {
          state: "gateway-closed",
          sessionKey,
          code,
          reason: String(reason || "")
        });
        scheduleReconnect(reason);
      }
    });

    currentSubscription.ready
      .then(() => {
        if (stopped) {
          return;
        }
        reconnectAttempt = 0;
        send("status", {
          state: "connected",
          sessionKey,
          includeAgent,
          at: new Date().toISOString()
        });
      })
      .catch((error) => {
        if (stopped) {
          return;
        }
        send("status", {
          state: "connect-failed",
          sessionKey,
          message: error?.message || String(error)
        });
        scheduleReconnect(error?.message || String(error));
      });
  };

  reply.raw.writeHead(200, {
    "content-type": "text/event-stream",
    "cache-control": "no-cache",
    connection: "keep-alive"
  });

  send("ready", {
    sessionKey,
    includeAgent,
    at: new Date().toISOString()
  });

  heartbeatTimer = setInterval(() => {
    send("heartbeat", {
      sessionKey,
      ts: Date.now()
    });
  }, 15_000);

  connectGateway();

  request.raw.on("close", () => {
    stopped = true;
    if (heartbeatTimer) {
      clearInterval(heartbeatTimer);
      heartbeatTimer = null;
    }
    if (reconnectTimer) {
      clearTimeout(reconnectTimer);
      reconnectTimer = null;
    }
    stopCurrentSubscription();
  });
});

app.post("/api/service/:action", async (request, reply) => {
  try {
    const action = actionSchema.parse(request.params.action);
    const { config: panelConfig } = await loadPanelConfig();
    const result = await runServiceAction(action, panelConfig);
    return {
      ok: result.ok,
      result
    };
  } catch (error) {
    reply.code(400);
    return {
      ok: false,
      message: error.message
    };
  }
});

app.get("/api/logs/tail", async (request, reply) => {
  try {
    const lines = toPositiveInt(request.query?.lines, 200);
    const filter = String(request.query?.filter || "");
    const { config: panelConfig } = await loadPanelConfig();
    const data = await getTailLogs({ panelConfig, lines, filter });
    return {
      ok: true,
      lines: data
    };
  } catch (error) {
    reply.code(400);
    return {
      ok: false,
      message: error.message
    };
  }
});

app.get("/api/logs/errors", async (request, reply) => {
  try {
    const count = toPositiveInt(request.query?.count, 20);
    const { config: panelConfig } = await loadPanelConfig();
    const lines = await getErrorSummary({ panelConfig, count });
    return {
      ok: true,
      lines
    };
  } catch (error) {
    reply.code(400);
    return {
      ok: false,
      message: error.message
    };
  }
});

app.get("/api/logs/stream", async (request, reply) => {
  const filter = String(request.query?.filter || "").toLowerCase();
  const { config: panelConfig } = await loadPanelConfig();

  reply.raw.writeHead(200, {
    "content-type": "text/event-stream",
    "cache-control": "no-cache",
    connection: "keep-alive"
  });

  const send = (event, payload) => {
    reply.raw.write(`event: ${event}\n`);
    reply.raw.write(`data: ${JSON.stringify(payload)}\n\n`);
  };

  const pass = (line) => !filter || line.toLowerCase().includes(filter);
  const stop = createLogStream({
    panelConfig,
    onLine: (line) => {
      if (pass(line)) {
        send("line", { line });
      }
    },
    onError: (line) => {
      send("error", { line });
    }
  });

  const heartbeat = setInterval(() => {
    send("heartbeat", { ts: Date.now() });
  }, 15000);

  request.raw.on("close", () => {
    clearInterval(heartbeat);
    stop();
  });
});

app.post("/api/test/telegram", async (request, reply) => {
  const payload = request.body || {};
  const result = await testTelegramBot(payload.botToken || "");
  return {
    ok: result.ok,
    message: result.message
  };
});

app.post("/api/channels/telegram/setup", async (request, reply) => {
  try {
    const parsed = telegramSetupPayloadSchema.safeParse(request.body || {});
    if (!parsed.success) {
      reply.code(400);
      return {
        ok: false,
        message: parsed.error.issues?.[0]?.message || "请求参数错误"
      };
    }
    const { config: panelConfig } = await loadPanelConfig();
    const result = await setupTelegramBasic({
      panelConfig,
      botToken: parsed.data.botToken
    });
    return {
      ok: result.ok,
      result
    };
  } catch (error) {
    reply.code(400);
    return {
      ok: false,
      message: error.message
    };
  }
});

app.post("/api/channels/telegram/pairing/approve", async (request, reply) => {
  try {
    const parsed = telegramPairingPayloadSchema.safeParse(request.body || {});
    if (!parsed.success) {
      reply.code(400);
      return {
        ok: false,
        message: parsed.error.issues?.[0]?.message || "请求参数错误"
      };
    }
    const { config: panelConfig } = await loadPanelConfig();
    const result = await approveTelegramPairing({
      panelConfig,
      code: parsed.data.code
    });
    return {
      ok: result.ok,
      result
    };
  } catch (error) {
    reply.code(400);
    return {
      ok: false,
      message: error.message
    };
  }
});

app.post("/api/test/feishu", async (request) => {
  const payload = request.body || {};
  const result = await testFeishuBot(payload.appId || "", payload.appSecret || "");
  return {
    ok: result.ok,
    message: result.message
  };
});

app.post("/api/test/discord", async (request) => {
  const payload = request.body || {};
  const result = await testDiscordBot(payload.token || "");
  return {
    ok: result.ok,
    message: result.message
  };
});

app.post("/api/test/slack", async (request) => {
  const payload = request.body || {};
  const result = await testSlackBot({
    mode: payload.mode || "socket",
    botToken: payload.botToken || "",
    appToken: payload.appToken || "",
    signingSecret: payload.signingSecret || ""
  });
  return {
    ok: result.ok,
    message: result.message
  };
});

app.get("/api/update/check", async (request, reply) => {
  try {
    const query = updateCheckQuerySchema.parse(request.query || {});
    const { config: panelConfig } = await loadPanelConfig();
    const targetConfig = resolveUpdateTarget(panelConfig, query.target);
    const githubToken = trimText(panelConfig?.update?.github_token);
    const result =
      targetConfig.target === "panel"
        ? await checkPanelDirectUpdate({
            releaseRepo: targetConfig.releaseRepo,
            githubToken,
            appDir: targetConfig.panelAppDir
          })
        : await checkBotDirectUpdate({
            runCmd: runCommand,
            releaseRepo: targetConfig.releaseRepo
          });
    return {
      ok: true,
      result: {
        ...result,
        target: targetConfig.target,
        upgradeMode: targetConfig.upgradeMode
      }
    };
  } catch (error) {
    reply.code(400);
    return {
      ok: false,
      message: error.message
    };
  }
});

app.post("/api/update/upgrade", async (request, reply) => {
  try {
    const payload = tagPayloadSchema.parse(request.body || {});
    const { config: panelConfig } = await loadPanelConfig();
    const targetConfig = resolveUpdateTarget(panelConfig, payload.target);
    const githubToken = trimText(panelConfig?.update?.github_token);
    let result;
    if (targetConfig.target === "panel") {
      result = await stagePanelDirectUpdate({
        tag: payload.tag,
        releaseRepo: targetConfig.releaseRepo,
        githubToken,
        appDir: targetConfig.panelAppDir
      });
    } else {
      result = await mutateBotDirectUpdate({
        action: "upgrade",
        tag: payload.tag,
        runCmd: runCommand
      });
    }
    return {
      ok: result.ok,
      result: {
        ...result,
        target: targetConfig.target,
        upgradeMode: targetConfig.upgradeMode
      }
    };
  } catch (error) {
    reply.code(400);
    return {
      ok: false,
      message: error.message
    };
  }
});

app.post("/api/update/rollback", async (request, reply) => {
  try {
    const payload = tagPayloadSchema.parse(request.body || {});
    const { config: panelConfig } = await loadPanelConfig();
    const targetConfig = resolveUpdateTarget(panelConfig, payload.target);
    const githubToken = trimText(panelConfig?.update?.github_token);
    let result;
    if (targetConfig.target === "panel") {
      if (!trimText(payload.tag)) {
        throw new Error("回滚必须填写目标版本号");
      }
      result = await stagePanelDirectUpdate({
        tag: payload.tag,
        releaseRepo: targetConfig.releaseRepo,
        githubToken,
        appDir: targetConfig.panelAppDir
      });
      result.action = "rollback-stage";
      result.message = result.ok
        ? `已准备回滚版本包 ${trimText(payload.tag)}，请点击“应用更新并重启”完成回滚。`
        : result.message;
    } else {
      result = await mutateBotDirectUpdate({
        action: "rollback",
        tag: payload.tag,
        runCmd: runCommand
      });
    }
    return {
      ok: result.ok,
      result: {
        ...result,
        target: targetConfig.target,
        upgradeMode: targetConfig.upgradeMode
      }
    };
  } catch (error) {
    reply.code(400);
    return {
      ok: false,
      message: error.message
    };
  }
});

app.post("/api/update/apply", async (request, reply) => {
  try {
    const payload = tagPayloadSchema.parse(request.body || {});
    const { config: panelConfig } = await loadPanelConfig();
    const targetConfig = resolveUpdateTarget(panelConfig, payload.target);
    const githubToken = trimText(panelConfig?.update?.github_token);
    let result;
    if (targetConfig.target === "panel") {
      result = await applyPanelDirectUpdate({
        tag: payload.tag,
        releaseRepo: targetConfig.releaseRepo,
        githubToken,
        appDir: targetConfig.panelAppDir,
        panelServiceName: targetConfig.panelServiceName
      });
    } else {
      result = await mutateBotDirectUpdate({
        action: "upgrade",
        tag: payload.tag,
        runCmd: runCommand
      });
    }
    return {
      ok: result.ok,
      result: {
        ...result,
        target: targetConfig.target,
        upgradeMode: targetConfig.upgradeMode
      }
    };
  } catch (error) {
    reply.code(400);
    return {
      ok: false,
      message: error.message
    };
  }
});

const PAGE_FILE_BY_PATH = {
  "/": "pages/dashboard.html",
  "/dashboard": "pages/dashboard.html",
  "/status-overview": "pages/dashboard.html",
  "/skills": "pages/skills.html",
  "/chat-console": "pages/chat-console.html",
  "/model": "pages/model.html",
  "/model/add": "pages/model-add.html",
  "/config-generator": "pages/config-generator.html",
  "/channels": "pages/channels.html",
  "/channels/telegram": "pages/channels-telegram.html",
  "/channels/feishu": "pages/channels-feishu.html",
  "/channels/discord": "pages/channels-discord.html",
  "/channels/slack": "pages/channels-slack.html",
  "/update": "pages/update.html",
  "/service": "pages/service.html",
  "/logs": "pages/logs.html"
};

app.get("/", async (_request, reply) => {
  return reply.sendFile("pages/dashboard.html");
});

app.setNotFoundHandler(async (request, reply) => {
  if (request.raw.url?.startsWith("/api/")) {
    reply.code(404);
    return {
      ok: false,
      message: "API not found"
    };
  }
  const rawUrl = String(request.raw.url || "/");
  const pathname = rawUrl.split("?")[0] || "/";
  const pageFile = PAGE_FILE_BY_PATH[pathname];
  if (pageFile) {
    return reply.sendFile(pageFile);
  }
  return reply.sendFile("index.html");
});

async function main() {
  const { config } = await loadPanelConfig();
  try {
    const permissionSync = await ensureOpenClawConfigPermissions(config.openclaw.config_path);
    if (permissionSync.changed) {
      console.log(
        `[openclaw-config] permission normalized: ownerFixed=${permissionSync.ownerFixed} modeFixed=${permissionSync.modeFixed} path=${permissionSync.path}`
      );
    }
  } catch (error) {
    console.warn(
      `[openclaw-config] failed to normalize config file permission: ${error?.message || String(error)}`
    );
  }
  const host = config.panel.listen_host;
  const port = config.panel.listen_port;

  await app.listen({ host, port });
  console.log(`OpenClaw panel listening on http://${host}:${port}`);
}

main().catch((error) => {
  console.error(error);
  process.exit(1);
});
</file>

<file path="public/styles.css">
:root {
  --bg: #f3f4f6;
  --surface: #ffffff;
  --surface-muted: #f3f5f8;
  --border: #e2e6ec;
  --border-strong: #bfc6d2;
  --text: #111827;
  --muted: #6b7280;
  --primary: #2457d6;
  --primary-hover: #1f4bb8;
  --primary-text: #ffffff;
  --soft-button: #eef1f6;
  --soft-button-hover: #e1e6ef;
  --sidebar-item-bg: #f1f1f1;
  --sidebar-item-bg-hover: #ebebeb;
  --sidebar-item-border: #d9d9d9;
  --cfg-field-bg: #ebebeb;
  --cfg-field-bg-readonly: #e5e5e5;
  --cfg-field-border: #cccccc;
  --cfg-output-bg: #eeeeee;
  --cfg-field-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.72), 0 1px 2px rgba(17, 24, 39, 0.06);
  --nested-card-bg: #efefef;
  --nested-card-border: #d2d2d2;
  --success: #1e7a3a;
  --danger: #b42318;
  --code-bg: #f5f7fb;
  --inner-card-bg: #e9ecf2;
  --inner-card-bg-strong: #e0e5ee;
  --model-provider-group-bg: #eeeeee;
  --model-provider-group-border: #d4d4d4;
  --model-chip-shadow: 0 1px 2px rgba(17, 24, 39, 0.08);
  --model-family-claude-bg: #f2cf62;
  --model-family-claude-fg: #2f2300;
  --model-family-gpt-bg: #111111;
  --model-family-gpt-fg: #f8f8f8;
  --model-family-gemini-bg: #84b5ff;
  --model-family-gemini-fg: #0f2d5f;
  --model-family-other-bg: #d7d7d7;
  --model-family-other-fg: #2f2f2f;
}

:root[data-theme="dark"],
body[data-theme="dark"] {
  --bg: #111111;
  --surface: #1a1a1a;
  --surface-muted: #212121;
  --border: #303030;
  --border-strong: #424242;
  --text: #e8e8e8;
  --muted: #a0a0a0;
  --primary: #4f7cff;
  --primary-hover: #3d66dc;
  --primary-text: #ffffff;
  --soft-button: #282828;
  --soft-button-hover: #333333;
  --sidebar-item-bg: #262626;
  --sidebar-item-bg-hover: #2d2d2d;
  --sidebar-item-border: #3d3d3d;
  --cfg-field-bg: #232323;
  --cfg-field-bg-readonly: #2a2a2a;
  --cfg-field-border: #3c3c3c;
  --cfg-output-bg: #1e1e1e;
  --cfg-field-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.03);
  --nested-card-bg: #242424;
  --nested-card-border: #3d3d3d;
  --success: #3fbf7f;
  --danger: #ff6d6d;
  --code-bg: #141414;
  --inner-card-bg: #252525;
  --inner-card-bg-strong: #2a2a2a;
  --model-provider-group-bg: #232323;
  --model-provider-group-border: #3d3d3d;
  --model-chip-shadow: 0 1px 2px rgba(0, 0, 0, 0.4);
  --model-family-claude-bg: #ad8410;
  --model-family-claude-fg: #120d00;
  --model-family-gpt-bg: #f5f5f5;
  --model-family-gpt-fg: #111111;
  --model-family-gemini-bg: #3467b5;
  --model-family-gemini-fg: #e9f1ff;
  --model-family-other-bg: #575757;
  --model-family-other-fg: #f2f2f2;
}

* {
  box-sizing: border-box;
}

html,
body {
  height: 100%;
}

body {
  margin: 0;
  min-height: 100vh;
  height: 100vh;
  font-family: "Segoe UI", "Noto Sans SC", "PingFang SC", "Microsoft YaHei", sans-serif;
  background: var(--bg);
  color: var(--text);
  overflow: hidden;
}

.layout {
  min-height: 100vh;
  height: 100vh;
  display: grid;
  grid-template-columns: 210px 1fr;
}

.sidebar {
  border-right: 1px solid var(--border);
  background: var(--surface);
  padding: 18px 14px;
  display: flex;
  flex-direction: column;
  gap: 16px;
  position: sticky;
  top: 0;
  height: 100vh;
  overflow-y: auto;
}

.brand h1 {
  margin: 4px 0 6px;
  font-size: 22px;
  font-weight: 700;
}

.eyebrow {
  margin: 0;
  font-size: 12px;
  color: var(--muted);
  letter-spacing: 0.04em;
  text-transform: uppercase;
}

.sub {
  margin: 0;
  color: var(--muted);
  font-size: 13px;
  line-height: 1.45;
}

.sidebar-group {
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 12px;
  background: var(--surface-muted);
  display: grid;
  gap: 10px;
}

.group-title {
  margin: 0;
  font-size: 14px;
}

.status-chip {
  display: inline-flex;
  align-items: center;
  gap: 8px;
  border: 1px solid var(--border);
  border-radius: 999px;
  padding: 6px 10px;
  font-size: 13px;
  background: var(--surface);
}

.dot {
  width: 8px;
  height: 8px;
  border-radius: 999px;
  background: var(--success);
}

.meta {
  display: grid;
  gap: 4px;
  font-size: 12px;
  color: var(--muted);
}

.tabs {
  display: grid;
  gap: 8px;
}

.tab {
  display: block;
  border-radius: 8px;
  border: 1px solid var(--border);
  background: var(--surface-muted);
  color: var(--text);
  padding: 10px 12px;
  text-align: left;
  font-size: 14px;
  text-decoration: none;
}

.sidebar-tabs .tab {
  border-color: var(--sidebar-item-border);
  background: var(--sidebar-item-bg);
  transition: background-color 0.18s ease, border-color 0.18s ease;
}

.sidebar-tabs .tab:hover {
  border-color: color-mix(in srgb, var(--sidebar-item-border) 70%, var(--primary));
  background: var(--sidebar-item-bg-hover);
}

.tab.is-active {
  background: var(--primary);
  color: var(--primary-text);
  border-color: var(--primary);
}

.config-generator-card input,
.config-generator-card select,
.config-generator-card textarea {
  background: var(--cfg-field-bg);
  border-color: var(--cfg-field-border);
  box-shadow: var(--cfg-field-shadow);
}

.config-generator-card input[readonly] {
  background: var(--cfg-field-bg-readonly);
}

.config-generator-card input:focus,
.config-generator-card select:focus,
.config-generator-card textarea:focus {
  box-shadow: 0 0 0 2px color-mix(in srgb, var(--primary) 18%, transparent);
}

.config-generator-card #cfg_output {
  background: var(--cfg-output-bg);
  border-color: var(--cfg-field-border);
}

.config-generator-card #cfg_output.is-error {
  color: var(--danger);
  border-color: color-mix(in srgb, var(--danger) 58%, var(--cfg-field-border));
  background: color-mix(in srgb, var(--danger) 9%, var(--cfg-output-bg));
}

.config-generator-card #cfg_status.is-fail {
  color: var(--danger);
  border-color: color-mix(in srgb, var(--danger) 58%, var(--cfg-field-border));
  background: color-mix(in srgb, var(--danger) 9%, var(--cfg-field-bg-readonly));
}

.config-generator-card #cfg_status.is-done {
  color: var(--success);
  border-color: color-mix(in srgb, var(--success) 52%, var(--cfg-field-border));
}

.config-generator-card #cfg_status.is-working {
  border-color: color-mix(in srgb, var(--primary) 50%, var(--cfg-field-border));
}

.cfg-secret-field {
  position: relative;
  display: flex;
  align-items: center;
}

.cfg-secret-field input {
  width: 100%;
  padding-right: 44px;
}

.cfg-secret-toggle {
  position: absolute;
  right: 6px;
  top: 50%;
  transform: translateY(-50%);
  width: 30px;
  height: 30px;
  padding: 0;
  border: 1px solid var(--cfg-field-border);
  background: var(--cfg-field-bg-readonly);
  color: var(--muted);
  font-size: 14px;
  line-height: 1;
}

.cfg-secret-toggle:hover {
  color: var(--text);
  background: var(--soft-button-hover);
  border-color: var(--border);
}

.cfg-secret-toggle.is-visible {
  color: var(--primary);
  border-color: color-mix(in srgb, var(--primary) 35%, var(--cfg-field-border));
  background: color-mix(in srgb, var(--primary) 12%, var(--cfg-field-bg-readonly));
}

.config-generator-card .actions {
  margin-top: 12px;
  margin-bottom: 12px;
}

.update-status-card,
.update-version-card,
.update-advanced-card {
  background: var(--nested-card-bg);
  border: 1px solid var(--nested-card-border);
  border-radius: 10px;
  box-shadow: var(--cfg-field-shadow);
}

.update-status-card {
  padding: 10px 12px;
  margin-top: 1.2rem;
  margin-bottom: 1rem;
}

.update-status-card .status-row {
  margin: 0;
  justify-content: center;
}

.update-status-card .update-status-hint {
  text-align: center;
  margin: 0.6rem 0 0;
}

.update-version-card {
  padding: 12px;
}

.update-progress-card {
  margin-bottom: 1rem;
  padding: 10px 12px;
  border: 1px solid var(--nested-card-border);
  border-radius: 10px;
  background: var(--nested-card-bg);
  box-shadow: var(--cfg-field-shadow);
}

.update-progress-head {
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 10px;
  font-size: 12px;
  color: var(--muted);
  margin-bottom: 8px;
}

.update-progress-card progress {
  width: 100%;
  height: 8px;
}

.update-progress-card.is-working .update-progress-head {
  color: var(--primary);
}

.update-progress-card.is-done .update-progress-head {
  color: var(--success);
}

.update-progress-card.is-fail .update-progress-head {
  color: var(--danger);
}

.update-advanced-card {
  margin-top: 0.75rem;
  padding: 12px;
}

.content {
  padding: 22px;
  display: grid;
  gap: 14px;
  align-content: start;
  height: 100vh;
  overflow-y: auto;
  overscroll-behavior: contain;
}

.page-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 12px;
  padding: 12px 2px;
}

.page-header-left {
  display: flex;
  align-items: center;
  gap: 10px;
  min-width: 0;
}

.page-header-actions {
  display: flex;
  align-items: center;
  gap: 10px;
  flex-wrap: wrap;
}

.page-back-link {
  width: 34px;
  height: 34px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  border: 1px solid var(--border);
  border-radius: 9px;
  background: var(--soft-button);
  color: var(--text);
  text-decoration: none;
  font-size: 18px;
  line-height: 1;
  flex-shrink: 0;
}

.page-back-link:hover {
  background: var(--soft-button-hover);
}

.page-header-link {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 10px 12px;
  text-decoration: none;
  color: var(--text);
}

.page-title {
  margin: 0;
  font-size: 24px;
  line-height: 1.2;
}

.page-subtitle {
  margin: 4px 0 0;
  font-size: 13px;
  color: var(--muted);
}

.panel {
  display: none;
}

.panel.is-visible {
  display: grid;
  gap: 12px;
}

.card {
  border: 2px solid var(--border-strong);
  border-radius: 10px;
  padding: 16px;
  background: var(--surface);
}

.card h2 {
  margin: 0 0 8px;
  font-size: 20px;
}

.muted-line {
  margin: 0 0 12px;
  color: var(--muted);
  font-size: 13px;
}

.muted-line.success {
  color: var(--success);
}

.muted-line.fail {
  color: var(--danger);
}

.grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
  gap: 12px;
}

label {
  display: grid;
  gap: 6px;
  font-size: 13px;
  color: var(--muted);
}

.field-stack {
  display: grid;
  gap: 8px;
}

.custom-field {
  display: none;
}

.custom-field.is-visible {
  display: block;
}

input,
textarea,
select,
button {
  border-radius: 8px;
  border: 1px solid var(--border);
  background: var(--surface);
  color: var(--text);
  padding: 10px 12px;
  font-family: inherit;
}

input:focus,
textarea:focus,
select:focus {
  outline: none;
  border-color: var(--primary);
}

textarea {
  resize: vertical;
  min-height: 88px;
}

input[readonly] {
  color: var(--muted);
}

button {
  cursor: pointer;
  background: var(--primary);
  color: var(--primary-text);
  border-color: var(--primary);
  font-weight: 600;
}

button:hover {
  background: var(--primary-hover);
  border-color: var(--primary-hover);
}

.btn-soft {
  background: var(--soft-button);
  border-color: var(--border);
  color: var(--text);
}

.btn-soft:hover {
  background: var(--soft-button-hover);
}

.actions {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  align-items: center;
}

.inline-check {
  display: flex;
  align-items: center;
  justify-content: space-between;
}

.inline-check input[type="checkbox"] {
  width: 18px;
  height: 18px;
  accent-color: var(--primary);
}

.filter {
  min-width: 300px;
}

.output {
  max-height: 330px;
  overflow: auto;
  margin: 12px 0 0;
  padding: 12px;
  border-radius: 8px;
  border: 1px solid var(--border);
  background: var(--code-bg);
  white-space: pre-wrap;
  word-break: break-word;
  font-family: "JetBrains Mono", "Cascadia Mono", ui-monospace, SFMono-Regular, Menlo, monospace;
  font-size: 12px;
  line-height: 1.5;
}

.status-row {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-bottom: 10px;
}

.provider-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  gap: 12px;
}

.model-flow-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
  gap: 10px;
}

.model-flow-btn {
  text-align: left;
  justify-content: flex-start;
}

.model-provider-mode-switch {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
}

.model-provider-mode-btn.is-active {
  border-color: var(--primary);
  box-shadow: inset 0 0 0 1px var(--primary);
  background: var(--surface);
}

.model-overview-card {
  display: grid;
  gap: 14px;
}

.model-overview-head {
  display: flex;
  align-items: flex-start;
  justify-content: space-between;
  gap: 12px;
}

.model-add-toggle {
  min-height: 40px;
  border-radius: 10px;
  border: 1px solid var(--border);
  padding: 0 14px;
  font-size: 14px;
  font-weight: 700;
  line-height: 1;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  text-decoration: none;
  white-space: nowrap;
}

.model-add-toggle.is-active {
  border-color: var(--primary);
  box-shadow: inset 0 0 0 1px var(--primary);
}

.model-add-toggle-primary {
  background: var(--primary);
  border-color: var(--primary);
  color: var(--primary-text);
}

.model-add-toggle-primary:hover {
  background: var(--primary-hover);
  border-color: var(--primary-hover);
}

.model-add-workspace {
  display: grid;
  gap: 12px;
}

.model-add-workspace input,
.model-add-workspace select,
.model-add-workspace textarea {
  background: var(--cfg-field-bg);
  border-color: var(--cfg-field-border);
  box-shadow: var(--cfg-field-shadow);
}

.model-add-workspace input[readonly] {
  background: var(--cfg-field-bg-readonly);
}

.model-add-save-status {
  margin: 0;
  padding: 10px 12px;
  border-radius: 8px;
  border: 1px solid var(--border);
  background: var(--surface-muted);
  color: var(--muted);
}

.model-add-save-status.is-working {
  color: var(--primary);
  border-color: color-mix(in srgb, var(--primary) 40%, var(--border));
  background: color-mix(in srgb, var(--primary) 9%, var(--surface-muted));
}

.model-add-save-status.is-done {
  color: var(--success);
  border-color: color-mix(in srgb, var(--success) 40%, var(--border));
  background: color-mix(in srgb, var(--success) 10%, var(--surface-muted));
}

.model-add-save-status.is-fail {
  color: var(--danger);
  border-color: color-mix(in srgb, var(--danger) 40%, var(--border));
  background: color-mix(in srgb, var(--danger) 9%, var(--surface-muted));
}

.model-provider-groups {
  display: grid;
  gap: 12px;
  grid-template-columns: repeat(auto-fill, minmax(280px, 320px));
  justify-content: flex-start;
}

.model-provider-group {
  border: 1px solid var(--model-provider-group-border);
  border-radius: 10px;
  background: var(--model-provider-group-bg);
  padding: 12px;
  display: grid;
  grid-template-rows: auto minmax(0, 1fr);
  gap: 10px;
  height: 320px;
}

.model-provider-group-empty {
  grid-template-rows: 1fr;
}

.model-provider-empty-body {
  min-height: 100%;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: flex-start;
  gap: 10px;
}

.model-provider-empty-title {
  margin: 0;
  font-size: 15px;
  font-weight: 700;
  color: var(--text);
}

.model-provider-empty-hint {
  margin: 0;
  font-size: 13px;
  line-height: 1.5;
  color: var(--muted);
}

.model-provider-empty-action {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  min-height: 34px;
  border-radius: 8px;
  border: 1px solid var(--primary);
  padding: 0 12px;
  font-size: 13px;
  font-weight: 700;
  text-decoration: none;
  background: var(--primary);
  color: var(--primary-text);
}

.model-provider-empty-action:hover {
  background: var(--primary-hover);
  border-color: var(--primary-hover);
}

.model-provider-group-head {
  display: grid;
  gap: 4px;
}

.model-provider-group-head-row {
  display: flex;
  align-items: flex-start;
  justify-content: space-between;
  gap: 8px;
  flex-wrap: wrap;
}

.model-provider-group-actions {
  display: flex;
  align-items: center;
  gap: 6px;
  flex-wrap: wrap;
}

.model-provider-group-title {
  margin: 0;
  font-size: 16px;
}

.model-provider-group-meta {
  margin: 0;
  font-size: 12px;
  color: var(--muted);
  word-break: break-all;
}

.model-chip-grid {
  display: flex;
  flex-direction: column;
  gap: 10px;
  min-height: 0;
  overflow-y: auto;
  padding-right: 2px;
}

.model-chip {
  text-align: left;
  display: grid;
  gap: 6px;
  padding: 12px;
  border-radius: 10px;
  border: 1px solid transparent;
  box-shadow: var(--model-chip-shadow);
  background: var(--model-chip-bg, var(--model-family-other-bg));
  color: var(--model-chip-fg, var(--model-family-other-fg));
  cursor: pointer;
}

.model-chip:hover {
  background: var(--model-chip-bg, var(--model-family-other-bg));
  border-color: transparent;
  filter: brightness(0.98);
}

.model-chip:disabled {
  opacity: 0.65;
  cursor: not-allowed;
}

.model-chip.is-disabled {
  opacity: 0.65;
  cursor: not-allowed;
}

.model-chip.is-current {
  border-color: color-mix(in srgb, var(--primary) 65%, transparent);
  box-shadow: inset 0 0 0 1px color-mix(in srgb, var(--primary) 55%, transparent), var(--model-chip-shadow);
}

.model-chip-name {
  font-size: 14px;
  font-weight: 700;
  word-break: break-word;
}

.model-chip-meta {
  font-size: 12px;
  line-height: 1.35;
  opacity: 0.92;
  word-break: break-all;
}

.model-chip-current {
  justify-self: start;
  display: inline-flex;
  align-items: center;
  border-radius: 999px;
  padding: 2px 8px;
  font-size: 11px;
  border: 1px solid currentColor;
}

.model-chip-actions {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
}

.model-provider-action-btn,
.model-chip-action {
  min-height: 28px;
  border-radius: 8px;
  border: 1px solid color-mix(in srgb, currentColor 24%, transparent);
  background: color-mix(in srgb, var(--surface) 28%, transparent);
  color: inherit;
  font-size: 11px;
  font-weight: 700;
  padding: 0 8px;
  cursor: pointer;
}

.model-provider-action-btn:hover,
.model-chip-action:hover {
  filter: brightness(0.96);
}

.model-provider-action-btn:focus-visible,
.model-chip-action:focus-visible {
  outline: 2px solid color-mix(in srgb, var(--primary) 56%, transparent);
  outline-offset: 1px;
}

.model-provider-action-btn-danger,
.model-chip-action-danger {
  border-color: color-mix(in srgb, #dc2626 64%, transparent);
  background: color-mix(in srgb, #dc2626 16%, transparent);
  color: #7f1d1d;
}

body[data-theme="dark"] .model-provider-action-btn-danger,
body[data-theme="dark"] .model-chip-action-danger {
  color: #fecaca;
}

.model-chip.family-claude {
  --model-chip-bg: var(--model-family-claude-bg);
  --model-chip-fg: var(--model-family-claude-fg);
}

.model-chip.family-gpt {
  --model-chip-bg: var(--model-family-gpt-bg);
  --model-chip-fg: var(--model-family-gpt-fg);
}

.model-chip.family-gemini {
  --model-chip-bg: var(--model-family-gemini-bg);
  --model-chip-fg: var(--model-family-gemini-fg);
}

.model-chip.family-other {
  --model-chip-bg: var(--model-family-other-bg);
  --model-chip-fg: var(--model-family-other-fg);
}

#model_provider_edit_dialog::part(panel),
#model_item_edit_dialog::part(panel) {
  width: min(560px, calc(100vw - 32px));
}

.model-dialog-grid {
  display: grid;
  gap: 10px;
}

.model-dialog-grid input,
.model-dialog-grid select,
.model-dialog-grid textarea {
  background: var(--cfg-field-bg);
  border-color: var(--cfg-field-border);
  box-shadow: var(--cfg-field-shadow);
}

.model-dialog-grid input[readonly] {
  background: var(--cfg-field-bg-readonly);
}

.model-dialog-hint {
  margin: 8px 0 0;
}

.model-raw-config-card {
  display: grid;
  gap: 10px;
}

.model-raw-config-meta {
  margin: 0;
}

.model-raw-config-editor {
  width: 100%;
  min-height: 360px;
  resize: vertical;
  background: var(--cfg-field-bg);
  border: 1px solid var(--cfg-field-border);
  box-shadow: var(--cfg-field-shadow);
  border-radius: 8px;
  padding: 12px;
  color: var(--text);
  font-family: "JetBrains Mono", "Cascadia Mono", ui-monospace, SFMono-Regular, Menlo, monospace;
  font-size: 12px;
  line-height: 1.5;
}

.model-raw-config-editor:focus {
  outline: 2px solid color-mix(in srgb, var(--primary) 24%, transparent);
  outline-offset: 1px;
}

.model-raw-config-status {
  margin: 0;
}

.model-raw-config-status.is-fail {
  color: var(--danger);
}

.model-raw-config-status.is-done {
  color: var(--success);
}

.is-hidden {
  display: none !important;
}

.provider-card {
  border: 1px solid var(--border);
  border-radius: 10px;
  padding: 12px;
  background: var(--surface-muted);
  display: grid;
  gap: 10px;
}

.provider-header {
  display: grid;
  gap: 4px;
}

.provider-title {
  margin: 0;
  font-size: 16px;
}

.provider-meta {
  margin: 0;
  font-size: 12px;
  color: var(--muted);
  word-break: break-all;
}

.model-list {
  display: grid;
  gap: 8px;
}

.model-row {
  border: 1px solid var(--border);
  border-radius: 8px;
  background: var(--surface);
  padding: 10px;
  display: grid;
  gap: 8px;
}

.model-row.is-current {
  border-color: var(--primary);
  box-shadow: inset 0 0 0 1px var(--primary);
}

.model-row-top {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 8px;
}

.model-id {
  font-size: 13px;
  font-weight: 600;
  word-break: break-all;
}

.tag-current {
  display: inline-flex;
  align-items: center;
  border-radius: 999px;
  border: 1px solid var(--success);
  color: var(--success);
  padding: 2px 8px;
  font-size: 12px;
}

.model-meta {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
  font-size: 12px;
  color: var(--muted);
}

.model-switch-btn {
  width: fit-content;
}

.pill {
  display: inline-flex;
  align-items: center;
  border-radius: 999px;
  padding: 5px 10px;
  border: 1px solid var(--border);
  font-size: 12px;
  background: var(--surface-muted);
}

.pill.success {
  color: var(--success);
  border-color: var(--success);
}

.pill.fail {
  color: var(--danger);
  border-color: var(--danger);
}

.error-list {
  list-style: none;
  margin: 10px 0 0;
  padding: 0;
  display: grid;
  gap: 8px;
}

.error-list li {
  border: 1px solid var(--danger);
  border-radius: 8px;
  padding: 8px;
  background: var(--surface);
  font-family: "JetBrains Mono", "Cascadia Mono", ui-monospace, SFMono-Regular, Menlo, monospace;
  font-size: 12px;
}

.stack-list {
  display: grid;
  gap: 10px;
}

.stack-item {
  border: 1px solid var(--border);
  border-radius: 8px;
  background: var(--surface-muted);
  padding: 10px 12px;
  display: grid;
  gap: 6px;
}

.stack-item.is-selected {
  border-color: var(--primary);
  box-shadow: inset 0 0 0 1px var(--primary);
}

.stack-item-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 10px;
  flex-wrap: wrap;
}

.stack-item-title {
  font-size: 14px;
  font-weight: 700;
}

.stack-item-meta {
  font-size: 12px;
  color: var(--muted);
  word-break: break-all;
}

.chip-line {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
}

.mini-chip {
  display: inline-flex;
  align-items: center;
  border-radius: 999px;
  padding: 2px 8px;
  font-size: 12px;
  border: 1px solid var(--border);
  background: var(--surface);
}

/* sr-only: 视觉隐藏但保留 DOM（屏幕阅读器 + JS 可访问） */
.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border: 0;
}

.dashboard-overview-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 12px;
  flex-wrap: wrap;
}

.dashboard-overview-actions {
  margin-left: auto;
}

.dashboard-overview-actions sl-button::part(base) {
  font-weight: 600;
}

.dashboard-hero-status {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 22px;
  margin: 0;
}

.dashboard-hero-status .dot {
  width: 12px;
  height: 12px;
  flex-shrink: 0;
}

.dashboard-hero-model {
  font-size: 14px;
  font-weight: 400;
  color: var(--muted);
  margin-left: 4px;
}

.dashboard-surface-card {
  background: var(--surface-muted);
}

.dashboard-surface-card h2 {
  margin-bottom: 6px;
  font-size: 19px;
}

/* 扁平统计条（替代 KPI 卡片） */
.dashboard-stat-row {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
  gap: 8px;
  margin-top: 8px;
}

.dashboard-stat {
  display: flex;
  flex-direction: column;
  gap: 2px;
  padding: 10px 12px;
  border-radius: 8px;
  background: var(--inner-card-bg);
}

.dashboard-stat-error {
  background: #fee2e2;
  border: 1px solid #f5b7b1;
}

body[data-theme="dark"] .dashboard-stat-error {
  background: #2a1515;
  border-color: #5b2323;
}

.dashboard-stat-label {
  font-size: 12px;
  color: var(--muted);
}

.dashboard-stat-value {
  font-size: 16px;
  font-weight: 700;
  word-break: break-word;
}

.dashboard-quick-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
  gap: 10px;
}

.dashboard-gateway-token-box {
  margin-top: 12px;
  border: 1px solid var(--nested-card-border);
  border-radius: 10px;
  background: var(--nested-card-bg);
  padding: 12px;
  display: flex;
  gap: 12px;
  align-items: center;
  justify-content: space-between;
}

.dashboard-gateway-token-main {
  flex: 1 1 auto;
  min-width: 0;
}

.dashboard-gateway-token-box h3 {
  margin: 0;
  font-size: 15px;
}

.dashboard-gateway-token-box .btn-soft {
  white-space: nowrap;
}

.dashboard-gateway-token-actions {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.dashboard-gateway-token-status {
  margin-top: 6px;
}

.dashboard-gateway-token-row {
  margin-top: 10px;
  display: flex;
  align-items: center;
  gap: 8px;
  flex-wrap: wrap;
}

.dashboard-gateway-token-input {
  flex: 1 1 280px;
  min-width: 220px;
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
}

.dashboard-gateway-token-status.is-done {
  color: var(--success);
}

.dashboard-gateway-token-status.is-fail {
  color: var(--danger);
}

.dashboard-quick-btn {
  text-align: left;
  justify-content: flex-start;
}

/* 模型切换行 */
.dashboard-model-switch-row {
  display: flex;
  align-items: flex-end;
  gap: 10px;
  flex-wrap: wrap;
}

.dashboard-model-switch-label {
  flex: 1 1 200px;
}

/* 技能切换按钮 */
.dashboard-skills-toggle-btn {
  margin-top: 6px;
  font-size: 13px;
}

/* 扁平技能 item（替代 sl-card） */
.dashboard-runtime-item-flat {
  padding: 10px 12px;
  border-radius: 10px;
  background: var(--inner-card-bg);
}

.dashboard-runtime-grid {
  display: grid;
  grid-template-columns: minmax(280px, 340px) minmax(0, 1fr);
  gap: 12px;
  align-items: start;
}

.dashboard-runtime-card {
  border-radius: 12px;
  background: var(--inner-card-bg);
  padding: 10px;
  display: grid;
  gap: 8px;
  min-height: 240px;
}

.dashboard-runtime-head {
  display: flex;
  justify-content: space-between;
  align-items: flex-end;
  gap: 8px;
  flex-wrap: wrap;
}

.dashboard-runtime-head h3 {
  margin: 0;
  font-size: 14px;
}

.dashboard-runtime-head .muted-line {
  margin: 0;
  font-size: 12px;
}

.dashboard-runtime-card .stack-list {
  min-height: 0;
  overflow: auto;
  max-height: 540px;
  padding: 4px;
  border-radius: 10px;
  background: var(--surface);
  display: grid;
  gap: 10px;
}

.dashboard-channel-runtime-list {
  grid-template-columns: 1fr;
}

.dashboard-skills-runtime-list {
  grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
}

.dashboard-runtime-item {
  --padding: 10px 12px;
}

.dashboard-runtime-item::part(base) {
  border: none;
  border-radius: 10px;
  background: var(--inner-card-bg);
  box-shadow: none;
}

.dashboard-runtime-item-channel::part(base) {
  background: var(--inner-card-bg-strong);
}

.dashboard-runtime-item-body {
  display: grid;
  gap: 8px;
}

.dashboard-runtime-item .stack-item-title {
  font-size: 14px;
}

.dashboard-runtime-item .stack-item-meta {
  margin: 0;
  font-size: 12px;
  color: var(--muted);
  line-height: 1.4;
}

.dashboard-runtime-item .chip-line {
  justify-content: flex-end;
}

.dashboard-runtime-item sl-tag::part(base) {
  border-radius: 999px;
}

.dashboard-list-empty {
  margin: 0;
  border-radius: 10px;
  background: var(--inner-card-bg);
  padding: 12px;
  color: var(--muted);
  font-size: 13px;
}

@media (max-width: 1180px) {
  .dashboard-runtime-grid {
    grid-template-columns: 1fr;
  }

  .dashboard-runtime-card .stack-list {
    max-height: 360px;
  }
}

@media (max-width: 980px) {
  .dashboard-overview-actions {
    margin-left: 0;
  }

  .dashboard-skills-runtime-list {
    grid-template-columns: 1fr;
  }

  .model-provider-groups {
    grid-template-columns: 1fr;
  }

  .model-provider-group {
    height: auto;
  }

  .model-chip-grid {
    overflow: visible;
  }
}

.chat-workspace {
  display: grid;
  gap: 12px;
}

.chat-topbar {
  display: flex;
  justify-content: space-between;
  gap: 12px;
  flex-wrap: wrap;
}

.chat-messages {
  border: 1px solid var(--border);
  border-radius: 10px;
  background: var(--surface-muted);
  min-height: 320px;
  max-height: 540px;
  overflow: auto;
  padding: 12px;
  display: grid;
  gap: 10px;
}

.chat-empty {
  color: var(--muted);
  font-size: 13px;
  text-align: center;
  padding: 18px 8px;
}

.chat-message {
  max-width: min(100%, 840px);
  border: 1px solid var(--border);
  border-radius: 12px;
  background: var(--surface);
  padding: 10px 12px;
  display: grid;
  gap: 6px;
}

.chat-message.user {
  margin-left: auto;
  border-color: var(--primary);
}

.chat-message.assistant {
  margin-right: auto;
}

.chat-message.streaming {
  border-style: dashed;
}

.chat-message-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 8px;
  font-size: 12px;
  color: var(--muted);
}

.chat-role {
  font-weight: 700;
  color: var(--text);
}

.chat-thinking {
  display: inline-flex;
  align-items: center;
  border: 1px solid var(--border);
  border-radius: 999px;
  padding: 2px 8px;
  font-size: 11px;
}

.chat-message-body {
  white-space: pre-wrap;
  word-break: break-word;
  line-height: 1.5;
}

.chat-message-body strong {
  font-weight: 700;
}

.chat-message-body code {
  font-family: "JetBrains Mono", "Cascadia Mono", ui-monospace, SFMono-Regular, Menlo, monospace;
  background: var(--code-bg);
  border: 1px solid var(--border);
  border-radius: 6px;
  padding: 1px 6px;
  font-size: 12px;
}

.chat-message-body .chat-code {
  margin: 6px 0;
  padding: 8px 10px;
  border-radius: 8px;
  border: 1px solid var(--border);
  background: var(--code-bg);
  overflow-x: auto;
}

.chat-message-body .chat-code code {
  border: 0;
  padding: 0;
  background: transparent;
  border-radius: 0;
  font-size: 12px;
}

.chat-inline-hint {
  min-height: 20px;
}

.chat-inline-hint.error {
  color: var(--danger);
}

.chat-inline-hint.ok {
  color: var(--success);
}

.chat-debug summary {
  cursor: pointer;
  font-size: 13px;
  color: var(--muted);
}

.chat-debug[open] {
  display: grid;
  gap: 10px;
}

.chat-attachment-list {
  border: 1px solid var(--border);
  border-radius: 10px;
  background: var(--surface-muted);
  min-height: 56px;
  padding: 10px;
  display: grid;
  gap: 8px;
}

.chat-attachment-list.is-dragover {
  border-color: var(--primary);
  box-shadow: inset 0 0 0 1px var(--primary);
}

.chat-attachment-item {
  border: 1px solid var(--border);
  border-radius: 8px;
  background: var(--surface);
  padding: 8px 10px;
  display: grid;
  gap: 8px;
}

.chat-attachment-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 10px;
}

.chat-attachment-name {
  font-size: 13px;
  font-weight: 600;
  word-break: break-all;
}

.chat-attachment-meta {
  color: var(--muted);
  font-size: 12px;
}

.chat-attachment-preview {
  max-width: 220px;
  max-height: 140px;
  border-radius: 8px;
  border: 1px solid var(--border);
  object-fit: cover;
}

@media (max-width: 980px) {
  body {
    height: auto;
    overflow: auto;
  }

  .layout {
    grid-template-columns: 1fr;
    height: auto;
  }

  .sidebar {
    border-right: 0;
    border-bottom: 1px solid var(--border);
    position: static;
    height: auto;
    overflow: visible;
  }

  .tabs {
    grid-template-columns: repeat(2, minmax(0, 1fr));
  }

  .tab {
    text-align: center;
  }

  .chat-messages {
    min-height: 260px;
  }

  .chat-attachment-preview {
    max-width: 160px;
    max-height: 120px;
  }

  .content {
    height: auto;
    overflow: visible;
  }
}

@media (max-width: 768px) {
  .content {
    padding: 14px;
  }

  .page-header {
    flex-direction: column;
    align-items: flex-start;
  }

  .filter {
    min-width: 100%;
  }

  .tabs {
    grid-template-columns: 1fr;
  }

  .dashboard-gateway-token-box {
    flex-direction: column;
    align-items: flex-start;
  }

  .dashboard-gateway-token-actions {
    width: 100%;
  }

  .dashboard-gateway-token-actions > .btn-soft {
    width: 100%;
  }

  .dashboard-gateway-token-row {
    width: 100%;
  }

  .dashboard-gateway-token-input {
    min-width: 100%;
  }
}
</file>

<file path="public/index.html">
<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>OpenClaw 龙虾控制台</title>
        <script>
      (function initThemeEarly() {
        var theme = "light";
        try {
          var saved = window.localStorage.getItem("openclaw-panel-theme");
          theme = saved === "dark" ? "dark" : "light";
        } catch (_error) {
          theme = "light";
        }
        var root = document.documentElement;
        root.dataset.theme = theme;
        root.classList.toggle("sl-theme-dark", theme === "dark");
        root.classList.toggle("sl-theme-light", theme !== "dark");
      })();
    </script>    <link rel="stylesheet" href="/shoelace/themes/light.css" />
    <link rel="stylesheet" href="/shoelace/themes/dark.css" />
    <link rel="stylesheet" href="/styles.css" />
    <script type="module" src="/shoelace/shoelace-autoloader.js"></script>
  </head>
  <body data-theme="light">
    <div class="layout">
      <aside class="sidebar">
        <div class="brand">
          <p class="eyebrow">OpenClaw</p>
          <h1>龙虾控制台</h1>
          <p class="sub">管理你的 AI 助手：模型、渠道、技能，一站搞定。</p>
        </div>

        <nav class="tabs sidebar-tabs">
          <a class="tab" data-tab-target="panel-dashboard" href="/dashboard">仪表盘</a>
          <a class="tab is-active" data-tab-target="panel-model" href="/model">模型配置</a>
          <a class="tab" data-tab-target="panel-chat-console" href="/chat-console">智能对话</a>
          <a class="tab" data-tab-target="panel-skills" href="/skills">技能管理</a>
          <a class="tab" data-tab-target="panel-config-generator" href="/config-generator">配置生成器</a>
          <a class="tab" data-tab-target="panel-channel" href="/channels">平台接入</a>
          <a class="tab" data-tab-target="panel-update" href="/update">版本更新</a>
          <a class="tab" data-tab-target="panel-service" href="/service">服务控制</a>
          <a class="tab" data-tab-target="panel-logs" href="/logs">运行日志</a>
        </nav>
      </aside>

      <main class="content">
        <header class="page-header">
          <div>
            <h2 class="page-title">龙虾控制台</h2>
            <p class="page-subtitle">你的 AI 助手管理中心</p>
          </div>
          <button id="theme_toggle" class="btn-soft" type="button">切换到深夜模式</button>
        </header>

        <section class="panel" data-panel="panel-dashboard">
          <!-- ① 健康状态栏（原仪表盘总览，扁平化） -->
          <article class="card dashboard-overview-card">
            <div class="dashboard-overview-row">
              <div>
                <h2 class="dashboard-hero-status">
                  <span class="dot"></span>
                  <span id="runtime_state">面板已连接</span>
                  <span class="dashboard-hero-model" id="dashboard_hero_model"></span>
                </h2>
              </div>
              <div class="actions dashboard-overview-actions">
                <sl-button id="dashboard_summary_refresh" variant="primary" size="small">刷新总览</sl-button>
              </div>
            </div>
            <!-- 技术元数据：保留 ID，对小白隐藏 -->
            <div class="sr-only" aria-hidden="true">
              <span id="meta_service_name">service: -</span>
              <span id="meta_log_source">log: -</span>
            </div>
            <div class="dashboard-stat-row">
              <div class="dashboard-stat">
                <span class="dashboard-stat-label">运行状态</span>
                <span id="dashboard_summary_runtime" class="dashboard-stat-value">-</span>
                <span id="dashboard_summary_runtime_meta" class="sr-only">等待刷新</span>
              </div>
              <div class="dashboard-stat">
                <span class="dashboard-stat-label">当前模型</span>
                <span id="dashboard_summary_model" class="dashboard-stat-value">-</span>
                <span id="dashboard_summary_model_meta" class="sr-only">等待刷新</span>
              </div>
              <div class="dashboard-stat">
                <span class="dashboard-stat-label">渠道</span>
                <span id="dashboard_summary_channels" class="dashboard-stat-value">-</span>
                <span id="dashboard_summary_channels_meta" class="sr-only">等待刷新</span>
              </div>
              <div class="dashboard-stat">
                <span class="dashboard-stat-label">技能</span>
                <span id="dashboard_summary_skills" class="dashboard-stat-value">-</span>
                <span id="dashboard_summary_skills_meta" class="sr-only">等待刷新</span>
              </div>
              <div class="dashboard-stat dashboard-stat-error">
                <span class="dashboard-stat-label">错误</span>
                <span id="dashboard_summary_errors" class="dashboard-stat-value">-</span>
                <span id="dashboard_summary_errors_meta" class="sr-only">等待刷新</span>
              </div>
              <div class="dashboard-stat">
                <span class="dashboard-stat-label">版本</span>
                <span id="dashboard_summary_version" class="dashboard-stat-value">-</span>
                <span id="dashboard_summary_version_meta" class="sr-only">等待刷新</span>
              </div>
            </div>
            <p id="dashboard_summary_hint" class="muted-line">点击"刷新总览"后显示最新状态。</p>
          </article>

          <!-- ② 快捷操作（提升到第 2 位） -->
          <article class="card dashboard-surface-card">
            <h2>我想要...</h2>
            <div class="dashboard-quick-grid">
              <button class="btn-soft dashboard-quick-btn" data-dashboard-jump="panel-chat-console" type="button">打开智能对话</button>
              <button class="btn-soft dashboard-quick-btn" data-dashboard-jump="panel-model" type="button">配置模型</button>
              <button class="btn-soft dashboard-quick-btn" data-dashboard-jump="panel-channel" type="button">配置平台接入</button>
              <button class="btn-soft dashboard-quick-btn" data-dashboard-jump="panel-skills" type="button">管理技能</button>
              <button class="btn-soft dashboard-quick-btn" data-dashboard-jump="panel-update" type="button">检查版本更新</button>
              <button class="btn-soft dashboard-quick-btn" data-dashboard-jump="panel-service" type="button">服务控制</button>
            </div>
          </article>

          <!-- ③ 切换 AI 模型（精简版） -->
          <article class="card dashboard-surface-card">
            <h2>切换 AI 模型</h2>
            <p class="muted-line">当前模型：<strong id="dashboard_model_display">-</strong></p>
            <!-- 隐藏字段：保留 ID 防 JS 报错 -->
            <div class="sr-only" aria-hidden="true">
              <input id="dashboard_current_model" type="text" readonly />
              <input id="dashboard_current_provider" type="text" readonly />
              <input id="dashboard_current_context_window" type="text" readonly />
              <input id="dashboard_current_thinking_strength" type="text" readonly />
              <input id="dashboard_quick_context_tokens" data-dashboard-context-input="1" type="number" min="0" step="1" />
            </div>
            <div class="dashboard-model-switch-row">
              <label class="dashboard-model-switch-label">
                切换到
                <select id="dashboard_quick_model_ref"></select>
              </label>
              <button id="dashboard_quick_switch" class="btn-soft" type="button">切换</button>
            </div>
            <p class="muted-line">从长上下文模型切到短上下文模型时，请确保当前会话已用上下文不超过目标模型上限，否则会报错。</p>
            <p id="dashboard_quick_switch_hint" class="muted-line">选择目标模型后点击切换。</p>
          </article>

          <!-- ④ 地址与接入配置（折叠，默认收起） -->
          <article class="card dashboard-surface-card">
            <sl-details summary="地址与接入配置（初次部署时需要）">
              <div class="grid">
                <label>
                  本地地址
                  <input id="dashboard_panel_local_url" type="text" readonly />
                </label>
                <label>
                  公网地址
                  <input id="dashboard_panel_public_url" type="text" readonly />
                </label>
                <label>
                  网关地址
                  <input id="dashboard_gateway_public_url" type="text" readonly />
                </label>
                <label>
                  Webhook 地址
                  <input id="dashboard_webhook_base_url" type="text" readonly />
                </label>
              </div>
              <p id="dashboard_public_hint" class="muted-line">
                若为空，请在 <code>data/panel/panel.config.json</code> 的 <code>reverse_proxy</code> 中填写公网 IP 与端口。
              </p>
            </sl-details>
          </article>

          <!-- ⑤ 运行态明细（技能列表折叠/过滤） -->
          <article class="card dashboard-surface-card">
            <h2>运行态明细</h2>
            <p class="muted-line">当前在跑什么一目了然。</p>
            <div class="dashboard-runtime-grid">
              <article class="dashboard-runtime-card">
                <div class="dashboard-runtime-head">
                  <h3>渠道运行态</h3>
                  <span class="muted-line">最近检查与错误</span>
                </div>
                <div id="dashboard_channel_runtime_list" class="stack-list dashboard-channel-runtime-list"></div>
              </article>
              <article class="dashboard-runtime-card">
                <div class="dashboard-runtime-head">
                  <h3>技能运行态</h3>
                  <span id="dashboard_skills_summary_text" class="muted-line">按技能展示状态</span>
                </div>
                <div id="dashboard_skills_runtime_list" class="stack-list dashboard-skills-runtime-list"></div>
                <button id="dashboard_skills_toggle_all" class="btn-soft dashboard-skills-toggle-btn" type="button" style="display:none;">显示全部</button>
              </article>
            </div>
          </article>
        </section>

        <section class="panel" data-panel="panel-skills">
          <article class="card">
            <h2>技能管理</h2>
            <p class="muted-line">查看和管理你的 AI 技能，包括启停和配置。</p>
            <div class="actions">
              <button id="skills_refresh" type="button">刷新技能列表</button>
            </div>
            <div class="grid">
              <label>
                总数
                <input id="skills_total" type="text" readonly />
              </label>
              <label>
                已启用
                <input id="skills_enabled" type="text" readonly />
              </label>
              <label>
                已禁用
                <input id="skills_disabled" type="text" readonly />
              </label>
            </div>
            <div id="skills_list" class="stack-list"></div>
          </article>

          <article class="card">
            <sl-details summary="查看技能配置（开发者）">
              <h2>技能配置详情</h2>
              <p class="muted-line">查看当前选中技能的有效配置（敏感字段已脱敏）。</p>
              <pre id="skills_config_preview" class="output">请选择一个技能查看配置</pre>
            </sl-details>
          </article>

          <article class="card">
            <h2>修改技能设置</h2>
            <p class="muted-line">只会写你填写的字段。留空代表不改；环境变量写成 <code>KEY=</code> 代表删除该键。</p>
            <div class="grid">
              <label>
                启用状态
                <select id="skills_edit_enabled">
                  <option value="" selected>保持不变</option>
                  <option value="true">启用</option>
                  <option value="false">禁用</option>
                </select>
              </label>
              <label>
                密钥（留空不改）
                <input id="skills_edit_api_key" type="password" autocomplete="off" placeholder="输入新密钥（可选）" />
              </label>
              <label class="inline-check">
                清除当前密钥
                <input id="skills_edit_clear_api_key" type="checkbox" />
              </label>
            </div>
            <sl-details summary="高级设置（环境变量）">
              <label>
                环境变量补丁（每行一个 KEY=VALUE）
                <textarea
                  id="skills_edit_env_patch"
                  rows="6"
                  placeholder="例如：&#10;HTTP_PROXY=http://127.0.0.1:7890&#10;OPENAI_BASE_URL=&#10;# 上面第二行表示删除 OPENAI_BASE_URL"
                ></textarea>
              </label>
            </sl-details>
            <div class="actions">
              <button id="skills_save_config" type="button">保存设置</button>
            </div>
            <p id="skills_save_result" class="muted-line">请选择技能后再进行修改。</p>
          </article>
        </section>

        <section class="panel" data-panel="panel-chat-console">
          <article class="card">
            <h2>智能对话</h2>
            <p class="muted-line">面向小白用户的聊天工作台：选会话、发消息、看实时回复，必要时再展开高级调试信息。</p>

            <div class="chat-workspace">
              <div class="chat-topbar">
                <div class="actions">
                  <button id="chat_new_session" type="button">新建会话</button>
                  <button id="chat_refresh_sessions" class="btn-soft" type="button">刷新会话</button>
                </div>
                <div class="actions">
                  <label class="inline-check">
                    显示思考状态
                    <input id="chat_show_thinking" type="checkbox" checked />
                  </label>
                  <label>
                    思考深度
                    <select id="chat_thinking_level">
                      <option value="">自动</option>
                      <option value="minimal">简略</option>
                      <option value="low">较少</option>
                      <option value="medium">适中</option>
                      <option value="high">深入</option>
                    </select>
                  </label>
                </div>
              </div>

              <div class="grid">
                <label>
                  当前会话
                  <select id="chat_session_select"></select>
                </label>
                <label class="sr-only">
                  最近任务 ID
                  <input id="chat_last_run_id" type="text" readonly />
                </label>
                <label class="sr-only">
                  实时通道状态
                  <input id="chat_stream_status" type="text" readonly />
                </label>
              </div>

              <div id="chat_messages" class="chat-messages">
                <div class="chat-empty">请选择会话后开始对话</div>
              </div>

              <label>
                输入消息
                <textarea id="chat_message_input" rows="4" placeholder="输入后按 Enter 发送，Shift+Enter 换行"></textarea>
              </label>
              <div class="actions">
                <button id="chat_pick_files" class="btn-soft" type="button">添加附件</button>
                <input id="chat_file_input" type="file" multiple hidden />
                <span id="chat_attachment_hint" class="muted-line">支持点击上传、粘贴或拖拽文件（图片会显示预览）</span>
              </div>
              <div id="chat_attachment_list" class="chat-attachment-list">
                <div class="chat-empty">当前没有附件</div>
              </div>

              <div class="actions">
                <button id="chat_send_message" type="button">发送消息</button>
                <button id="chat_abort_run" class="btn-soft" type="button">停止回复</button>
                <button id="chat_reset_session" class="btn-soft" type="button">清空当前会话</button>
              </div>
              <p id="chat_inline_hint" class="muted-line chat-inline-hint"></p>

              <details class="chat-debug">
                <summary>排障工具（遇到问题时展开）</summary>
                <div class="grid">
                  <label class="sr-only">
                    幂等键（可选）
                    <input id="chat_idempotency_key" type="text" placeholder="留空自动生成" />
                  </label>
                </div>
                <div class="actions">
                  <button id="chat_load_history" class="btn-soft" type="button">刷新历史</button>
                  <button id="chat_reconnect_stream" class="btn-soft" type="button">重新连接</button>
                </div>
                <label>
                  历史记录（原始数据）
                  <pre id="chat_history_output" class="output">请选择会话后加载历史</pre>
                </label>
                <label>
                  实时事件（原始数据）
                  <pre id="chat_stream_output" class="output">等待流式事件...</pre>
                </label>
              </details>
            </div>
          </article>
        </section>

        <section class="panel is-visible" data-panel="panel-model">
          <article class="card">
            <h2>模型配置</h2>
            <p class="muted-line">
              选择你需要的操作：切换已有模型，或添加新的模型服务。
            </p>
            <div class="model-flow-grid">
              <button class="btn-soft model-flow-btn" data-model-flow-jump="model_default_section" type="button">切换默认模型</button>
              <button class="btn-soft model-flow-btn" data-model-flow-jump="model_provider_mode_section" type="button">添加新模型服务</button>
            </div>
          </article>

          <article id="model_default_section" class="card">
            <h2>切换默认模型</h2>
            <p class="muted-line">选择要使用的默认模型，然后点击保存。</p>
            <div class="grid">
              <label>
                当前默认模型
                <select id="model_default_ref"></select>
              </label>
              <label class="sr-only">
                主模型引用
                <input id="model_current_primary" type="text" readonly />
              </label>
              <label class="sr-only">
                提供商标识
                <input id="model_current_provider" type="text" readonly />
              </label>
              <label class="sr-only">
                API 模式
                <input id="model_current_api" type="text" readonly />
              </label>
              <label class="sr-only">
                API 地址
                <input id="model_current_baseurl" type="text" readonly />
              </label>
              <label class="sr-only">
                模型 ID
                <input id="model_current_id" type="text" readonly />
              </label>
            </div>
            <sl-details summary="模型详细信息">
              <div class="grid">
                <label>
                  模型名称
                  <input id="model_current_name" type="text" readonly />
                </label>
                <label>
                  上下文长度
                  <input id="model_current_context_window" type="text" readonly />
                </label>
                <label>
                  最大输出长度
                  <input id="model_current_max_tokens" type="text" readonly />
                </label>
              </div>
            </sl-details>
            <div class="actions">
              <button id="save_default_model">保存默认模型</button>
            </div>
            <p class="muted-line">提示：这里只切换默认模型，不会新增或删除模型服务。</p>
          </article>

          <article class="card">
            <h2>可用模型</h2>
            <p class="muted-line">在这里直接按提供商查看并切换模型。切换前建议填写当前会话上下文，系统会在可能超限时提醒你。</p>
            <sl-details summary="切换前检查（可选）">
              <div class="grid">
                <label>
                  当前对话已用量
                  <input
                    id="dashboard_context_tokens"
                    data-dashboard-context-input="1"
                    type="number"
                    min="0"
                    step="1"
                    placeholder="用于切换时上下文超限提示"
                  />
                </label>
              </div>
              <p id="dashboard_context_hint" class="muted-line">当目标模型上下文更短，且当前会话上下文超过目标上限时，将弹出风险提示。</p>
            </sl-details>
            <div id="model_provider_cards" class="provider-grid"></div>
          </article>

          <article id="model_provider_mode_section" class="card">
            <h2>添加新模型服务</h2>
            <p class="muted-line">基础配置适合绝大多数用户；只有你需要自定义 models JSON 时，再切换到自定义模式。</p>
            <div class="model-provider-mode-switch">
              <button
                class="btn-soft model-provider-mode-btn is-active"
                type="button"
                data-model-provider-mode="template"
                aria-pressed="true"
              >
                快速配置（推荐）
              </button>
              <button class="btn-soft model-provider-mode-btn" type="button" data-model-provider-mode="custom" aria-pressed="false">
                高级模式
              </button>
            </div>
            <p id="model_provider_mode_hint" class="muted-line">当前为快速配置模式：你通常只需要填写服务名称、接口地址和密钥。</p>
          </article>

          <article id="model_provider_template_section" class="card" data-model-provider-mode-panel="template">
            <h2>快速配置</h2>
            <p class="muted-line">选择模型类型，填写基本信息即可使用。</p>
            <div class="grid">
              <label>
                模型类型
                <select id="model_template_key">
                  <option value="aicodecat-gpt">GPT 系列</option>
                  <option value="aicodecat-claude">Claude 系列</option>
                  <option value="aicodecat-gemini">Gemini 系列</option>
                </select>
              </label>
              <label>
                服务名称
                <input id="template_provider_id" type="text" />
              </label>
              <label>
                接口地址
                <input id="template_base_url" type="url" />
              </label>
              <label>
                密钥
                <input id="template_api_key" type="password" autocomplete="off" />
              </label>
            </div>
            <details>
              <summary>高级参数（通常不用改）</summary>
              <div class="grid">
                <label>
                  接口协议
                  <div class="field-stack">
                    <select id="template_api">
                      <option value="openai-responses">openai-responses（GPT Responses）</option>
                      <option value="openai-completions">openai-completions（GPT 兼容）</option>
                      <option value="anthropic-messages">anthropic-messages（Claude）</option>
                      <option value="google-generative-ai">google-generative-ai（Gemini）</option>
                      <option value="custom">自定义</option>
                    </select>
                    <input id="template_api_custom" class="custom-field" type="text" placeholder="输入自定义 API 模式" />
                  </div>
                </label>
                <label>
                  设为默认模型
                  <select id="template_default_model_id"></select>
                </label>
                <label class="inline-check">
                  保存后设为当前默认模型
                  <input id="template_set_as_primary" type="checkbox" />
                </label>
              </div>
            </details>
            <label>
              模板内置模型（可直接用）
              <pre id="template_model_preview" class="output"></pre>
            </label>
            <div class="actions">
              <button id="save_provider_template">保存</button>
            </div>
            <p class="muted-line">提示：保存后默认只新增模型服务；勾选「保存后设为当前默认模型」才会同时切换默认模型。</p>
          </article>

          <article id="model_provider_custom_section" class="card is-hidden" data-model-provider-mode-panel="custom">
            <h2>高级模式</h2>
            <p class="muted-line">需要完全自定义时，直接编辑模型 JSON 数组。每个模型至少要有 id 和 name。</p>
            <div class="grid">
              <label>
                服务名称
                <input id="custom_provider_id" type="text" placeholder="例如 my-provider" />
              </label>
              <label>
                接口协议
                <div class="field-stack">
                  <select id="custom_api">
                    <option value="openai-responses">openai-responses（GPT Responses）</option>
                    <option value="openai-completions">openai-completions（GPT 兼容）</option>
                    <option value="anthropic-messages">anthropic-messages（Claude）</option>
                    <option value="google-generative-ai">google-generative-ai（Gemini）</option>
                    <option value="custom">自定义</option>
                  </select>
                  <input id="custom_api_custom" class="custom-field" type="text" placeholder="输入自定义 API 模式" />
                </div>
              </label>
              <label>
                接口地址
                <input id="custom_base_url" type="url" placeholder="例如 https://api.example.com/v1" />
              </label>
              <label>
                密钥
                <input id="custom_api_key" type="password" autocomplete="off" />
              </label>
              <label>
                默认模型 ID
                <div class="field-stack">
                  <select id="custom_default_model_id"></select>
                  <input
                    id="custom_default_model_id_custom"
                    class="custom-field"
                    type="text"
                    placeholder="输入 models 数组中的某个 id"
                  />
                </div>
              </label>
              <label class="inline-check">
                保存后设为当前默认模型
                <input id="custom_set_as_primary" type="checkbox" />
              </label>
            </div>
            <label>
              models 数组 JSON
              <textarea id="custom_models_json" rows="10" placeholder='[{"id":"model-id","name":"模型名","reasoning":true,"input":["text","image"],"contextWindow":200000,"maxTokens":64000}]'></textarea>
            </label>
            <div class="actions">
              <button id="save_provider_custom">保存</button>
            </div>
          </article>
        </section>

        <section class="panel" data-panel="panel-config-generator">
          <article class="card">
            <h2>高级配置工具</h2>
            <p class="muted-line">普通用户请使用「模型配置」页面，这里面向开发者。</p>
            <sl-details summary="展开配置工具">

            <div class="grid">
              <label>
                服务商
                <div class="field-stack">
                  <select id="cfg_provider">
                    <option value="aicodecat">aicodecat</option>
                    <option value="custom">自定义</option>
                  </select>
                  <input id="cfg_provider_custom" class="custom-field" type="text" placeholder="输入自定义服务商 ID" />
                </div>
              </label>

              <label>
                接口协议
                <div class="field-stack">
                  <select id="cfg_apimode">
                    <option value="anthropic-messages">anthropic-messages（Claude）</option>
                    <option value="openai-responses" selected>openai-responses（GPT）</option>
                    <option value="openai-completions">openai-completions（GPT 兼容）</option>
                    <option value="google-generative-ai">google-generative-ai（Gemini）</option>
                    <option value="custom">自定义</option>
                  </select>
                  <input id="cfg_apimode_custom" class="custom-field" type="text" placeholder="输入自定义 API 模式" />
                </div>
              </label>
            </div>

            <div class="grid">
              <label>
                接口地址
                <div class="field-stack">
                  <select id="cfg_baseurl">
                    <option value="https://aicode.cat/v1" selected>https://aicode.cat/v1 (GPT)</option>
                    <option value="https://aicode.cat">https://aicode.cat (Claude)</option>
                    <option value="https://aicode.cat/v1beta">https://aicode.cat/v1beta (Gemini)</option>
                    <option value="custom">自定义</option>
                  </select>
                  <input id="cfg_baseurl_custom" class="custom-field" type="url" placeholder="输入自定义 Base URL" />
                </div>
              </label>

              <label>
                模型 ID
                <div class="field-stack">
                  <select id="cfg_model_id"></select>
                  <input id="cfg_model_id_custom" class="custom-field" type="text" placeholder="输入自定义模型 ID" />
                </div>
              </label>
            </div>

            <div class="grid">
              <label>
                密钥
                <input id="cfg_apikey" type="password" autocomplete="off" placeholder="输入密钥" />
              </label>
              <label>
                保留已有配置
                <select id="cfg_inherit_existing">
                  <option value="false" selected>否（只生成当前页面配置）</option>
                  <option value="true">是（保留当前配置中的其他字段）</option>
                </select>
              </label>
              <label>
                状态
                <input id="cfg_status" type="text" value="就绪" readonly />
              </label>
            </div>

            <label>
              原始配置
              <textarea id="cfg_input" rows="8" placeholder="粘贴你的 ~/.openclaw/openclaw.json"></textarea>
            </label>

            <div class="actions">
              <button id="cfg_generate" type="button">生成配置</button>
              <button id="cfg_copy" class="btn-soft" type="button">复制结果</button>
            </div>

            <label>
              生成结果
              <pre id="cfg_output" class="output">响应将显示在这里</pre>
            </label>
            </sl-details>
          </article>
        </section>

        <section class="panel" data-panel="panel-channel">
          <article class="card">
            <h2>平台接入</h2>
            <p class="muted-line">配置你的聊天平台连接，修改后点击保存生效。</p>
            <p class="muted-line sr-only">
              范围说明：本页面只写入 `channels.telegram` / `channels.feishu` / `channels.discord` / `channels.slack`（以及飞书兼容所需
              `accounts.main`），不会创建任何面板私有“虚拟渠道”。
            </p>
            <div class="actions">
              <button id="save_settings">保存渠道配置</button>
            </div>
          </article>

          <article class="card">
            <h2>Telegram</h2>
            <p class="muted-line sr-only">对应 channels.telegram.*，默认建议 DM 策略用 pairing。</p>
            <div class="grid">
              <label class="inline-check">
                启用 Telegram
                <input id="tg_enabled" type="checkbox" />
              </label>
              <label>
                机器人令牌
                <input id="tg_bot_token" type="text" autocomplete="off" />
              </label>
              <label>
                私聊权限
                <select id="tg_dm_policy">
                  <option value="pairing">配对验证（推荐）</option>
                  <option value="allowlist">白名单</option>
                  <option value="open">完全开放</option>
                  <option value="disabled">关闭</option>
                </select>
              </label>
              <label>
                群聊权限
                <select id="tg_group_policy">
                  <option value="allowlist">白名单</option>
                  <option value="open">完全开放</option>
                  <option value="disabled">关闭</option>
                </select>
              </label>
              <label>
                消息发送方式
                <select id="tg_stream_mode">
                  <option value="partial">逐步发送（推荐）</option>
                  <option value="block">整条发送</option>
                  <option value="off">关闭</option>
                </select>
              </label>
              <label class="inline-check">
                群聊需要 @ 才回复
                <input id="tg_require_mention" type="checkbox" />
              </label>
            </div>
            <div class="grid">
              <label>
                允许的用户（每行一个）
                <textarea id="tg_allow_from" rows="4"></textarea>
              </label>
              <label>
                允许的群组（每行一个）
                <textarea id="tg_group_allow_from" rows="4"></textarea>
              </label>
            </div>
            <div class="actions">
              <button id="test_telegram" class="btn-soft">测试 Telegram</button>
              <button id="save_and_test_telegram" class="btn-soft">保存并测试 Telegram</button>
            </div>
            <p id="tg_test_result" class="muted-line">最近测试：未执行</p>
          </article>

          <article class="card">
            <h2>飞书</h2>
            <p class="muted-line sr-only">对应 channels.feishu.*，兼容 accounts.main。</p>
            <div class="grid">
              <label class="inline-check">
                启用 Feishu
                <input id="fs_enabled" type="checkbox" />
              </label>
              <label>
                App ID
                <input id="fs_app_id" type="text" />
              </label>
              <label>
                应用密钥
                <input id="fs_app_secret" type="password" autocomplete="off" />
              </label>
              <label>
                Domain
                <select id="fs_domain">
                  <option value="feishu">feishu</option>
                  <option value="lark">lark</option>
                </select>
              </label>
              <label>
                连接方式
                <select id="fs_connection_mode">
                  <option value="websocket">长连接（推荐）</option>
                  <option value="webhook">回调模式</option>
                </select>
              </label>
              <label>
                私聊权限
                <select id="fs_dm_policy">
                  <option value="pairing">配对验证（推荐）</option>
                  <option value="allowlist">白名单</option>
                  <option value="open">完全开放</option>
                </select>
              </label>
              <label>
                群聊权限
                <select id="fs_group_policy">
                  <option value="allowlist">白名单</option>
                  <option value="open">完全开放</option>
                  <option value="disabled">关闭</option>
                </select>
              </label>
              <label class="inline-check">
                群聊需要 @ 才回复
                <input id="fs_require_mention" type="checkbox" />
              </label>
            </div>
            <div class="grid">
              <label>
                允许的用户（每行一个）
                <textarea id="fs_allow_from" rows="4"></textarea>
              </label>
              <label>
                允许的群组（每行一个）
                <textarea id="fs_group_allow_from" rows="4"></textarea>
              </label>
            </div>
            <div class="actions">
              <button id="test_feishu" class="btn-soft">测试 Feishu</button>
              <button id="save_and_test_feishu" class="btn-soft">保存并测试 Feishu</button>
            </div>
            <p id="fs_test_result" class="muted-line">最近测试：未执行</p>
          </article>

          <article class="card">
            <h2>Discord</h2>
            <p class="muted-line sr-only">
              对应 `channels.discord.*`，`requireMention` 映射到 `channels.discord.guilds["*"].requireMention`。
            </p>
            <div class="grid">
              <label class="inline-check">
                启用 Discord
                <input id="dc_enabled" type="checkbox" />
              </label>
              <label>
                机器人令牌
                <input id="dc_token" type="password" autocomplete="off" />
              </label>
              <label>
                私聊权限
                <select id="dc_dm_policy">
                  <option value="pairing">配对验证（推荐）</option>
                  <option value="allowlist">白名单</option>
                  <option value="open">完全开放</option>
                  <option value="disabled">关闭</option>
                </select>
              </label>
              <label>
                群聊权限
                <select id="dc_group_policy">
                  <option value="allowlist">白名单</option>
                  <option value="open">完全开放</option>
                  <option value="disabled">关闭</option>
                </select>
              </label>
              <label class="inline-check">
                允许其他机器人触发
                <input id="dc_allow_bots" type="checkbox" />
              </label>
              <label class="inline-check">
                群聊需要 @ 才回复
                <input id="dc_require_mention" type="checkbox" />
              </label>
            </div>
            <div class="grid">
              <label>
                允许的用户（每行一个）
                <textarea id="dc_allow_from" rows="4"></textarea>
              </label>
            </div>
            <div class="actions">
              <button id="test_discord" class="btn-soft">测试 Discord</button>
            </div>
            <p id="dc_test_result" class="muted-line">最近测试：未执行</p>
          </article>

          <article class="card">
            <h2>Slack</h2>
            <p class="muted-line sr-only">对应 channels.slack.*，支持 socket/http 两种模式。</p>
            <div class="grid">
              <label class="inline-check">
                启用 Slack
                <input id="sl_enabled" type="checkbox" />
              </label>
              <label>
                连接模式
                <select id="sl_mode">
                  <option value="socket">socket</option>
                  <option value="http">http</option>
                </select>
              </label>
              <label>
                机器人令牌（xoxb-...）
                <input id="sl_bot_token" type="password" autocomplete="off" />
              </label>
              <label>
                应用令牌（xapp-...，socket 模式常用）
                <input id="sl_app_token" type="password" autocomplete="off" />
              </label>
              <label>
                签名密钥（http 模式必填）
                <input id="sl_signing_secret" type="password" autocomplete="off" />
              </label>
              <label>
                私聊权限
                <select id="sl_dm_policy">
                  <option value="pairing">配对验证（推荐）</option>
                  <option value="allowlist">白名单</option>
                  <option value="open">完全开放</option>
                  <option value="disabled">关闭</option>
                </select>
              </label>
              <label>
                群聊权限
                <select id="sl_group_policy">
                  <option value="allowlist">白名单</option>
                  <option value="open">完全开放</option>
                  <option value="disabled">关闭</option>
                </select>
              </label>
              <label class="inline-check">
                允许其他机器人触发
                <input id="sl_allow_bots" type="checkbox" />
              </label>
              <label class="inline-check">
                群聊需要 @ 才回复
                <input id="sl_require_mention" type="checkbox" />
              </label>
            </div>
            <div class="grid">
              <label>
                允许的用户（每行一个）
                <textarea id="sl_allow_from" rows="4"></textarea>
              </label>
            </div>
            <div class="actions">
              <button id="test_slack" class="btn-soft">测试 Slack</button>
            </div>
            <p id="sl_test_result" class="muted-line">最近测试：未执行</p>
          </article>
        </section>

        <section class="panel" data-panel="panel-update">
          <article class="card">
            <h2>OpenClaw 版本更新</h2>
            <p class="muted-line">检查并升级到最新版本，升级失败时可一键回滚。</p>

            <div class="status-row">
              <span class="pill" id="update_state">未检查</span>
              <span class="muted-line" id="update_hint">建议先点“检查更新”，再执行升级。</span>
            </div>

            <div class="grid">
              <label>
                当前版本
                <input id="update_current_tag" type="text" readonly />
              </label>
              <label>
                最新版本
                <input id="update_latest_tag" type="text" readonly />
              </label>
              <label>
                目标版本
                <input id="update_target_tag" type="text" placeholder="例如 v2026.2.14" />
              </label>
            </div>

            <div class="actions">
              <button id="check_update">检查更新</button>
              <button id="upgrade_update">升级到目标版本</button>
              <button id="rollback_update" class="btn-soft">回滚到目标版本</button>
            </div>
          </article>
        </section>

        <section class="panel" data-panel="panel-service">
          <article class="card">
            <h2>服务控制</h2>
            <div class="status-row">
              <span class="pill" id="service_state">未知</span>
              <span class="muted-line" id="service_hint">页面会自动刷新一次状态，你也可以点击“刷新状态”。</span>
            </div>
            <div class="actions">
              <button data-action="status">刷新状态</button>
              <button data-action="start">启动</button>
              <button data-action="stop">停止</button>
              <button data-action="restart">重启</button>
            </div>
            <pre id="service_output" class="output"></pre>
          </article>
        </section>

        <section class="panel" data-panel="panel-logs">
          <article class="card">
            <h2>运行日志</h2>
            <div class="actions">
              <label class="filter">
                关键字过滤
                <input id="log_filter" type="text" placeholder="error / timeout / token ..." />
              </label>
              <button id="load_tail">加载最近日志</button>
              <button id="start_stream">开始实时查看</button>
              <button id="stop_stream" class="btn-soft">停止实时查看</button>
              <button id="load_errors" class="btn-soft">查看最近错误</button>
            </div>
            <pre id="log_output" class="output"></pre>
            <ul id="error_summary" class="error-list"></ul>
          </article>
        </section>

        <section class="card">
          <h2>操作时间线</h2>
          <p class="muted-line">每次点击后的结果都会记录在这里，方便你定位问题。</p>
          <pre id="messages" class="output"></pre>
        </section>
      </main>
    </div>

    <script type="module" src="/app.js"></script>
  </body>
</html>
</file>

<file path="public/app.js">
import { els, hasPanel, setMessage, setupTabs, setupTheme } from "./js/core/panel-core.js";
import { setupConfigGenerator } from "./js/pages/config-generator-page.js";
import {
  loadStatusOverview,
  setupDashboard,
  setupModelEditor,
  setSaveModelSettingsHandler
} from "./js/pages/model-dashboard-page.js";
import { loadSkillsStatus, setupSkillsPage } from "./js/pages/skills-page.js";
import { loadChatSessions, setupChatConsole } from "./js/pages/chat-page.js";
import {
  approveTelegramPairingFlow,
  checkAllUpdates,
  checkUpdate,
  loadErrorSummary,
  loadInitialData,
  loadTail,
  mutateVersion,
  resetTelegramAdvancedSettings,
  runService,
  saveAndTestFeishu,
  saveAndTestTelegram,
  saveModelSettings,
  saveSettings,
  setChannelTestResult,
  setupTelegramBasicFlow,
  startStream,
  stopStream,
  testDiscord,
  testFeishu,
  testSlack,
  testTelegram
} from "./js/pages/system-page.js";

setSaveModelSettingsHandler(saveModelSettings);

setupTheme();
setupTabs();

if (hasPanel("panel-dashboard")) {
  setupDashboard();
}
if (hasPanel("panel-skills")) {
  setupSkillsPage();
}
if (hasPanel("panel-chat-console")) {
  setupChatConsole();
}
if (hasPanel("panel-model") || hasPanel("panel-model-add")) {
  setupModelEditor();
}
if (hasPanel("panel-config-generator")) {
  setupConfigGenerator();
}

document.querySelector("#save_settings")?.addEventListener("click", () => {
  saveSettings().catch((error) => setMessage(error.message, "error"));
});

document.querySelectorAll("[data-action]").forEach((btn) => {
  btn.addEventListener("click", () => {
    runService(btn.dataset.action).catch((error) => setMessage(error.message, "error"));
  });
});

document.querySelector("#load_tail")?.addEventListener("click", () => {
  loadTail().catch((error) => setMessage(error.message, "error"));
});

document.querySelector("#load_errors")?.addEventListener("click", () => {
  loadErrorSummary().catch((error) => setMessage(error.message, "error"));
});

document.querySelector("#start_stream")?.addEventListener("click", startStream);
document.querySelector("#stop_stream")?.addEventListener("click", stopStream);

document.querySelector("#tg_setup_basic")?.addEventListener("click", () => {
  setupTelegramBasicFlow().catch((error) => setMessage(error.message, "error"));
});
document.querySelector("#tg_pairing_approve")?.addEventListener("click", () => {
  approveTelegramPairingFlow().catch((error) => setMessage(error.message, "error"));
});
document.querySelector("#tg_save_advanced")?.addEventListener("click", () => {
  saveSettings().catch((error) => setMessage(error.message, "error"));
});
document.querySelector("#tg_reset_advanced")?.addEventListener("click", () => {
  resetTelegramAdvancedSettings().catch((error) => setMessage(error.message, "error"));
});
document.querySelector("#save_and_test_telegram")?.addEventListener("click", () => {
  saveAndTestTelegram().catch((error) => setMessage(error.message, "error"));
});
document.querySelector("#save_and_test_feishu")?.addEventListener("click", () => {
  saveAndTestFeishu().catch((error) => setMessage(error.message, "error"));
});

function bindChannelTestButton(buttonSelector, runTest, resultElementId, channelName) {
  document.querySelector(buttonSelector)?.addEventListener("click", () => {
    runTest().catch((error) => {
      const detail = String(error?.message || "请求失败");
      setChannelTestResult(resultElementId, detail, false);
      setMessage(`${channelName} 测试失败：${detail}`, "error");
    });
  });
}

bindChannelTestButton("#test_telegram", testTelegram, "tg_test_result", "Telegram");
bindChannelTestButton("#test_feishu", testFeishu, "fs_test_result", "Feishu");
bindChannelTestButton("#test_discord", testDiscord, "dc_test_result", "Discord");
bindChannelTestButton("#test_slack", testSlack, "sl_test_result", "Slack");
document.querySelector("#bot_check_update")?.addEventListener("click", () => {
  checkUpdate({ target: "bot" }).catch((error) => setMessage(error.message, "error"));
});
document.querySelector("#bot_upgrade_update")?.addEventListener("click", () => {
  mutateVersion("upgrade", { target: "bot" }).catch((error) => setMessage(error.message, "error"));
});
document.querySelector("#bot_rollback_update")?.addEventListener("click", () => {
  mutateVersion("rollback", { target: "bot" }).catch((error) => setMessage(error.message, "error"));
});
document.querySelector("#panel_check_update")?.addEventListener("click", () => {
  checkUpdate({ target: "panel" }).catch((error) => setMessage(error.message, "error"));
});
document.querySelector("#panel_upgrade_update")?.addEventListener("click", () => {
  mutateVersion("upgrade", { target: "panel" }).catch((error) => setMessage(error.message, "error"));
});
document.querySelector("#panel_apply_update")?.addEventListener("click", () => {
  mutateVersion("apply", { target: "panel" }).catch((error) => setMessage(error.message, "error"));
});
document.querySelector("#panel_rollback_update")?.addEventListener("click", () => {
  mutateVersion("rollback", { target: "panel" }).catch((error) => setMessage(error.message, "error"));
});

const isUpdatePage = hasPanel("panel-update");

loadInitialData()
  .then(() => {
    if (els.runtimeState) {
      els.runtimeState.textContent = "面板已连接";
    }
    setMessage("初始化完成", "ok");

    if (els.serviceState) {
      runService("status").catch(() => {});
    }
    if (els.logOutput) {
      loadTail().catch(() => {});
    }
    if (hasPanel("panel-dashboard") || els.errorSummary) {
      loadErrorSummary({ silent: true }).catch((error) => setMessage(`错误摘要加载失败：${error.message}`, "error"));
      checkUpdate({ silent: true }).catch((error) => setMessage(`版本信息加载失败：${error.message}`, "error"));
      loadStatusOverview({ silent: true }).catch((error) => setMessage(`状态总览加载失败：${error.message}`, "error"));
    }
    if (hasPanel("panel-skills")) {
      loadSkillsStatus({ silent: true }).catch((error) => setMessage(`Skills 页面加载失败：${error.message}`, "error"));
    }
    if (hasPanel("panel-chat-console")) {
      loadChatSessions({ silent: true }).catch((error) => setMessage(`智能对话页加载失败：${error.message}`, "error"));
    }
    if (isUpdatePage) {
      checkAllUpdates({ silent: true }).catch((error) => setMessage(`版本信息加载失败：${error.message}`, "error"));
    }
  })
  .catch((error) => {
    if (els.runtimeState) {
      els.runtimeState.textContent = "面板连接失败";
    }
    setMessage(`初始化失败：${error.message}`, "error");
  });
</file>

</files>
